{"meta":{"title":"温斯渤","subtitle":"To Be A Better Man.","description":"热爱安卓","author":"温斯渤","url":"http://www.wensibo.top"},"pages":[{"title":"","date":"2018-10-20T09:30:35.646Z","updated":"2018-10-20T09:30:35.646Z","comments":false,"path":"categories/index.html","permalink":"http://www.wensibo.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-20T09:28:53.774Z","updated":"2018-10-20T09:28:53.774Z","comments":false,"path":"tags/index.html","permalink":"http://www.wensibo.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一口一口吃掉Gradle（二）：深入学习Groovy","slug":"gradle2","date":"2018-03-16T08:32:25.000Z","updated":"2018-10-21T08:26:20.784Z","comments":true,"path":"2018/03/16/gradle2/","link":"","permalink":"http://www.wensibo.top/2018/03/16/gradle2/","excerpt":"上一篇文章我们从整体上初步认识了Gradle，也说了Gradle的学习曲线，这篇文章我们就按照顺序来讲解Groovy语言。需要说明的是这篇文章大部分内容是翻译自Groovy的官方文档，不过中间也有些许内容是我自己学习过程中总结整理的，如果大家英语好的话建议直接看英文文档。","text":"上一篇文章我们从整体上初步认识了Gradle，也说了Gradle的学习曲线，这篇文章我们就按照顺序来讲解Groovy语言。需要说明的是这篇文章大部分内容是翻译自Groovy的官方文档，不过中间也有些许内容是我自己学习过程中总结整理的，如果大家英语好的话建议直接看英文文档。 这是一个系列的Gradle文章： 一口一口吃掉Gradle（一）：初识Gradle 一口一口吃掉Gradle（二）：深入学习Groovy Groovy是一门什么语言在Groovy的官网上有对Groovy的一段描述：1Groovy tries to be as natural as possible for Java developers. We’ve tried to follow the principle of least surprise when designing Groovy, particularly for developers learning Groovy who’ve come from a Java background. 大意是说Groovy就是为了JAVA程序员“量身定做”的，既然这么说的话，我们学习Groovy应该是比较容易的。当然事实也是如此，不过Groovy作为一门脚本语言，也有它与JAVA的区别之处，例如在JAVA中我们需要每一行都要分号作为结束标志，但是Groovy却可以省略；我们调用JAVA中的方法时需要使用括号，而Groovy中也可以省略。当然还有很多特点使得Groovy相比JAVA来说都是一门更简洁的语言。接下来我们就来了解一番。 搭建Groovy开发环境尽管Gradle使用了Groovy作为开发语言，但是确切地说Gradle使用的是基于Groovy的领域特定语言(DSL)，也就是说Gradle只是使用了Groovy中的一些语法。所以当我们来了解Groovy时最好还是搭建Groovy的开发环境。 Linux环境下12345678910111213## 到sdkman官网下载对应的安装shell script，然后调用bash解析器去执行## 在这个过程中最好关闭代理curl -s get.sdkman.io | bash## 继续执行下面的命令source ~/.sdkman/bin/sdkman-init.sh## 安装Groovysdk install groovy## 查看Groovy版本groovy -versionGroovy Version: 2.4.14 JVM: 1.8.0_131 Vendor: Oracle Corporation OS: Linux 如果能够成功显示如上的Groovy版本则说明安装成功。 Windows环境下点击这个连接到Groovy官网下载所需的版本，之后安装并设置环境变量即可。以上步骤完成之后同样在命令行中测试groovy -version，看看能够正确显示Groovy的版本号。 Groovy自带编辑器使用终端或者命令行执行groovyConsole等待一下即可打开Groovy自带的编辑器，我们可以直接在上面写程序，之后使用快捷键Ctrl+R可以执行代码查看执行结果；使用快捷键Ctrl+W可以清空控制台的输出信息。另外需要了解的一点就是Groovy的代码需要保存在.groovy文件中。 注释Groovy与JAVA有很多的相同点，在注释上尤为明显，举例如下：12345678910111213141516171819202122232425262728293031//单行注释println \"single line comments\" //注释可以位于语句后方/* 多行 注释 */println \"multiline comments\" /*多行注释还可以 这样写*/println 1 /*还可以写在语句中间*/ +2 /*没错，这样写也是可以的*///文档注释与JAVA类似/** * 类说明 */class Person &#123; /** 变量说明 */ String name /** * 说明方法的含义 * * @param 参数含义 * @return 返回值含义 */ String greet(String otherPerson) &#123; \"Hello $&#123;otherPerson&#125;\" &#125;&#125;//特殊的单行注释，这种注释通常是用来给UNIX系统声明允许脚本运行的类型的#!/usr/bin/env groovyprintln \"Hello from the shebang line\" 关键字 as assert break case catch class const continue def default do else enum extends false finally for goto if implements import in instanceof interface new null package return super switch this throw throws trait true try while 标识符普通标识符标识符以字母，美元符号或下划线开始。不能以一个数字开始。合法标识符如下：1234def namedef item3def with_underscoredef $dollarStart 下面是一些非法标识符：123def 3tierdef a+bdef a#b 特殊一点的就是关键字在.之后的都可以作为合法的标识符：12345foo.asfoo.assertfoo.breakfoo.casefoo.catch 引用标识符引用标识符是指出现在.表达式的后面，例如person.”name”中的name，一般的用法如下：1234567def map = [:]map.\"an identifier with a space and double quotes\" = \"ALLOWED\" // 向map添加一个键值对map.'with-dash-signs-and-single-quotes' = \"ALLOWED\" // 向map再添加一个键值对assert map.\"an identifier with a space and double quotes\" == \"ALLOWED\"assert map.'with-dash-signs-and-single-quotes' == \"ALLOWED\" 另外由于Groovy支持多种字符串表达方式(接下来会讲到)，所以以下的表达方式也都是允许的：123456map.'single quote'map.\"double quote\"map.'''triple single quote'''map.\"\"\"triple double quote\"\"\"map./slashy string/map.$/dollar slashy string/$ 此外，由于Groovy提供了自己的String，称之为GString，他是一种有插值的字符串(即可以在字符串中引用其它变量)，所以以下的这些也算是合法的标识符：1234def firstname = \"Homer\"map.\"Simpson-$&#123;firstname&#125;\" = \"Homer Simpson\"assert map.'Simpson-Homer' == \"Homer Simpson\" 字符串Groovy中的字符串有两大类，第一种与JAVA的一样，即java.lang.String，另一种则是Groovy独有的：groovy.lang.GString，后者的作用就是可以在字符串中引用其他变量(即插值)。 单引号字符串单引号字符串是普通的java.lang.String，不支持插值。1'a single quoted string' 三单引号字符串三单引号字符串同样也是普通的java.lang.String，也是不支持插值。三单引号字符串是可以跨行和保留所有的缩进：1234567def startingAndEndingWithANewline = ''' line one line twoline three'''assert startingAndEndingWithANewline.startsWith('\\n')assert startingAndEndingWithANewline.endsWith('\\n') 上述的字符串中第一行与最后一行都是换行，可见三单引号字符串是保留了所有的换行，而实际上，Groovy将其中的换行解释为\\n，将所有的空白字符则是保留原样。如果我们想要转义字符的话只要在需要转义的字符前方添加反斜杠\\，例如我们想要去掉上方字符串的前后两个换行，则可以这样处理1234567def startingAndEndingWithoutANewline = '''\\ line one line twoline three\\'''assert !startingAndEndingWithoutANewline.startsWith('\\n')assert !startingAndEndingWithoutANewline.endsWith('\\n') 双引号字符串双引号字符串稍微有点特殊，刚才我们说的插值就是在这里使用的，请看下方的例子：1234def name = \"Guillaume\" // 普通字符串def greeting = \"Hello $&#123;name&#125;\" // 含有插值的字符串assert greeting.toString() == 'Hello Guillaume' 可以看到没有含有插值的字符串就是普通的JAVA字符串，含有的则是GString，他可以访问其他的变量，表达的方式有两种：${}和$，前者一般用于代替字符串或者表达式，后者则用于A.B的形式中，且也只能适用于这种形式中，如果表达式中含有例如括号，大括号，闭包(稍后讲解)等都是会报错的：1234567891011def sum = \"The sum of 2 and 3 equals $&#123;2 + 3&#125;\"assert sum.toString() == 'The sum of 2 and 3 equals 5'def person = [name: 'Guillaume', age: 36]assert \"$person.name is $person.age years old\" == 'Guillaume is 36 years old'def number = 3.14shouldFail(MissingPropertyException) &#123; // 这样写是会报错的，因为解释器会将其解释为：\"$&#123;number.toString&#125;()\" println \"$number.toString()\"&#125; 如果想要转义$或者${}占位符，只需要加上反斜杠\\就行1assert '$&#123;name&#125;' == \"\\$&#123;name&#125;\" java.lang.String与groovy.lang.GString配合使用也是我们经常遇到的，在下面的例子中，takeString方法需要的参数是String类型的，但是我们传进去的却是GString类型的，此时GSTring的toString()方法会被调用。使得传入时能够保证类型一致。 1234567891011String takeString(String message) &#123; assert message instanceof String return message&#125;def message = \"The message is $&#123;'hello'&#125;\" assert message instanceof GString def result = takeString(message) assert result instanceof Stringassert result == 'The message is hello' 最后需要注意一点的就是，普通Java字符串是不可变的，而一个GString依赖于插入的值，它的String是可变的。即使有相同的字符串结果，GString和String也没有相同的hashCode，例如：1assert \"one: $&#123;1&#125;\".hashCode() != \"one: 1\".hashCode() 所以在选择Map的键值时我们应当避免选择GString，看看下面的例子你就清楚了：1234def key = \"a\"def m = [\"$&#123;key&#125;\": \"letter $&#123;key&#125;\"]assert m[\"a\"] == null 其他字符串Groovy中还有另外三种字符串，分别是：三双引号字符串、斜杠字符串、美元符修饰的斜杠字符串，由于这三种字符串用得比较少，这里就略过了，有兴趣的朋友可以直接到Groovy的官方文档中查阅。 列表List由于Groovy中没有定义任何集合类，因此List也是沿用了java.util.List，其默认的实现则是java.util.ArrayList，不过我们也可以使用as关键字将其转换。变量定义：List 变量由[ ]定义，比如：1def aList = [5,'string',true] //List 由[]定义，其元素可以是任何对象 变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动往该索引添加元素12345678assert aList[1] == 'string' assert aList[-1] == true //当索引为-1时表示倒数最后一个assert aList[-2] == 'string' //当索引为-2时表示倒数第二个，以此类推assert aList[5] == null //第 6 个元素为空 aList[100] = 100 //设置第 101 个元素的值为 100assert aList[100] == 100assert aList[0,2] == [5,true] // 一次访问两个元素，并返回一个包含这两个元素的新列表assert aList[0..2] == [6,'string',true] // 使用范围访问列表中这个范围内的元素，从start到end元素位置 那么，aList 到现在为止有多少个元素呢？1println aList.size() // 结果是 101 现在我们打算将ArrayList转换为其他的具体实现类12345678def arrayList = [1, 2, 3]assert arrayList instanceof java.util.ArrayList // 默认情况下是ArrayLisdef linkedList = [2, 3, 4] as LinkedList // 使用as关键字将其转换为LinkedListassert linkedList instanceof java.util.LinkedList LinkedList otherLinked = [3, 4, 5] // 声明的时候直接指定为LinkedListassert otherLinked instanceof java.util.LinkedList 数组数组的声明与List类似，且都是用[ ]来表示的，之所以不能像JAVA一样采用{}来初始化数组，是因为在Groovy中{}会被误解为闭包标志。我们需要通过类型转换或者类型定义来定义数组，与List不同的是，数组中的元素类型需要一致，并且数组的大小不能改变：123456789101112String[] arrStr = ['Ananas', 'Banana', 'Kiwi'] //可以在定义的时候直接指定为数组，assert arrStr instanceof String[] assert !(arrStr instanceof List)def numArr = [1, 2, 3] as int[] // 使用as关键字转换成数组assert numArr instanceof int[] numArr[0] = 3assert numArr[0] == 3assert numArr.size() == 3 映射Map变量定义：Map 变量由[:]定义，比如1def aMap = ['key1':'value1','key2':true] Map 由 [:] 定义，注意其中的冒号。冒号左边是 key，右边是value。在Groovy中key 不一定是字符串，也可以是其他对象，value也可以是任何对象。另外，key 可以用’’或”” 包起来，也可以不用引号包起来。比如：123456789101112def aNewMap = [key1:\"value\",key2:true] //其中的 key1 和 key2 默认被处理成字符串 \"key1\" 和 \"key2\" assert aNewMap.\"key1\" == \"value\"``` 不过 key 要是不使用引号包起来的话，也会带来一定混淆，比如：```groovydef key1=\"wowo\"def aConfusedMap=[key1:\"who am i?\"]//aConfuseMap 中的 key1 到底是\"key1\"还是变量 key1 的值“wowo”？显然，答案是字符串\"key1\"。如果要是\"wowo\"的话，则 aConfusedMap 的定义必须设置成： def aConfusedMap=[(key1):\"who am i?\"] Map 中元素的存取更加方便，它支持多种方法：1234567def aMap = [key1:1,key2:2,key3:3,4:4]assert aMap.key1 == 1 //这种表达方法好像 key1 就是 aMap 的一个成员变量一样 assert aMap.\"key1\" ==1 //因为我们将key1看成了字符串，因此也可以直接这样访问assert aMap['key1'] ==1 //这种表达方法更传统一点 assert aMap[4] ==4 //对于数字则需要使用这种方式来访问了aMap.anotherkey = \"i am map\" //为 map 添加新元素 assert aMap == [key1:1, key2:2, key3:3, 4:4, anotherkey:\"i am map\"] 闭包闭包的定义闭包(Closure)是Groovy中一种非常重要的数据类型，他是一段可以执行的代码。定义的格式如下：12def xxx = &#123;paramters -&gt; code&#125; //参数可以是0个或者多个，每个参数之间用`,`分隔开；后面的代码可以一行也可以多行def xxx = &#123;无参数只有 code&#125; //这种没有参数的情况则不需要-&gt;符号 根据上面的格式我们再来看看几个具体的实例： 123456789101112131415&#123; item++ &#125; //1 &#123; println it &#125; //2 &#123; it -&gt; println it &#125; //3 &#123; name -&gt; println name &#125; //4 &#123; -&gt; item++ &#125; //5 &#123; String x, int y -&gt; println \"hey $&#123;x&#125; the value is $&#123;y&#125;\" //6&#125;&#123; String x, int y=6 -&gt; println \"hey $&#123;x&#125; the value is $&#123;y&#125;\" //7&#125;&#123; reader -&gt; def line = reader.readLine() //8 line.trim()&#125; 上面的几个例子中： 1、闭包中引用了一个item变量，并做自增操作； 2、闭包中直接打印it变量，it变量是闭包中默认的参数，他就是第三行代码的缩减形式； 3、与上一行其实是一样的，这里只是显示的将it变量标了出来； 4、与第三行代码其实是一个道理只是将参数名字改了一下而已； 5、这里没有参数只有一个箭头符号与代码，这样写的意思就是闭包中没有任何参数，连默认的参数都没有，所以如果我们调用闭包的时候传入了参数，那么就会报错； 6、这个闭包定义了两个指定类型的参数，并在代码中使用插值引用了两个参数的值； 7、这个闭包相比上个闭包只是在参数定义上有了区别，在参数定义的时候可以指定默认值； 8、这个闭包定义了一个没有指定类型的参数，并且代码块中是可以有多个表达式的。 除此之外闭包也是groovy.lang.Closure类的实例，尽管它是一个代码块，但是它可以赋给一个变量或者一个属性作为其他的变量，请看如下的实例：123456def listener = &#123; e -&gt; println \"Clicked on $e.source\" &#125; //1 assert listener instanceof Closure Closure callback = &#123; println 'Done!' &#125; //2 Closure&lt;Boolean&gt; isTextFile = &#123; //3 File it -&gt; it.name.endsWith('.txt') //4 &#125; 上面的几个例子中： 1、闭包是可以赋值给一个变量的； 2、如果不使用def关键字来声明变量，我们可以把闭包赋值给一个groovy.lang.Closure类型的变量； 3、我们可以指定闭包的返回类型，这里的返回类型为Boolean，当然这个是可选的。 4、闭包中代码的最后一行就是闭包的返回值，也可以显示的使用return关键字，也可以不写。 闭包的调用调用闭包有两种方式：1234567def isOdd = &#123; int i-&gt; i%2 == 1 &#125; //1 assert isOdd(3) == true //2 assert isOdd.call(2) == false //3def isEven = &#123; it%2 == 0 &#125; //4 assert isEven(3) == false //5 assert isEven.call(2) == true //6 总结来说就是闭包对象.call(参数)或者直接闭包对象.(参数)，第4行中是省略了闭包参数的写法，直接使用it来代替，所以我们调用的时候需要传入一个参数。当闭包作为闭包或方法的最后一个参数，可以将闭包从参数圆括号中提取出来只接在最后；如果闭包或者方法有一个参数且该参数为闭包，那么可以直接省略掉闭包或方法的圆括号；又如果闭包或者方法的参数中有多个闭包，并且这些闭包必须都要排在参数列表中的最后，则此时这些闭包可以依次写在圆括号外：123456789101112131415161718def testClosure=&#123;param,c -&gt; c(c(param))&#125; //1def testMethod(a1, b1, closure)&#123; //2 closure() //调用闭包 &#125;assert testClosure(5)&#123;it*3&#125; == 45 //3testMethod(1,'test')&#123;println(\"i am in closure\")&#125; //4def testClosure2=&#123;c -&gt; c()&#125; //5def testMethod2(a1, b1, closure, closure2)&#123; //6 closure() // 调用闭包1 closure2() // 调用闭包2&#125;assert testClosure2&#123;\"i am in testClosure2\"&#125; == \"i am in testClosure2\" //7testMethod2(1,'test') &#123;println(\"i am in closure\")&#125; &#123;println \"i am in closure2\"&#125; //8 在上面的例子中： 1、闭包c是作为闭包testClosure的最后一个参数； 2、闭包closure作为方法testMethod的最后一个参数； 3、在调用闭包testClosure时，可以将闭包c写在圆括号外，圆括号内只需要填写其他参数即可； 4、同样的道理，闭包写在圆括号外面。 5、当定义方法或者闭包时只有一个参数，且参数为闭包； 6、当定义的方法或者闭包的参数列表中有多个闭包，并且这些闭包需要排列在参数列表的末尾； 7、调用testClosure2闭包时可以直接省略闭包的圆括号，这种方式也适用于方法； 8、调用testMethod2方法时可以直接将闭包写在圆括号外面，多个闭包以此排列并且不需要使用,将每个闭包分隔开，这种方式也适用于闭包。 闭包的可变参数闭包可以像其它方法那样声明一个可变的参数列表。当参数列表的最后一个参数的长度是可变的时候（或者是一个数组），那么这个闭包就能接收数量不定的参数，请看下面的实例：123456789def concat1 = &#123; String... args -&gt; args.join('') &#125; //1 assert concat1('abc','def') == 'abcdef' //2 def concat2 = &#123; String[] args -&gt; args.join('') &#125; //3 assert concat2('abc', 'def') == 'abcdef'def multiConcat = &#123; int n, String... args -&gt; //4 args.join('')*n&#125;assert multiConcat(2, 'abc','def') == 'abcdefabcdef' 上面的例子中： 1、闭包可以接收数量可变的String参数； 2、可以在调用时使用任意数量的参数，而且不用被包装成一个数组； 3、使用数组也能达到同样的效果； 4、只要最后一个参数是一个数组或者可变长度的的参数类型即可。 在GString中使用闭包之前我们讲到GString与传统的java.lang.String的区别，而在GString中使用闭包一般有两种情形：12345678910def x = 1def gs1 = \"x = $&#123;x&#125;\" //1assert gs1 == 'x = 1' //2def gs2 = \"x = $&#123;-&gt; x&#125;\" //3assert gs2 == 'x = 1' //4x = 2 //5assert gs1 == 'x = 1' //6assert gs2 == 'x = 2' //7 上面例子中的第一行以及第三行就是在GString中使用闭包的两种情形，严格意义上来讲，第一行代码中的${}并不是闭包，而只是一个插值的符号。在注释1与注释3中定义了两个GString之后我们在注释2以及注释4中验证了他们的结果，这个结果也确实与我们预料中的一致。但是接下来的注释5中，我们修改了变量x的值，将其改为2，现在再来看看两个GString的结果，发现采用${}的结果不变，而使用了闭包${-&gt;}的则会更新结果，这究竟是为什么呢？这个主要是因为Groovy对两种符号的加载方式不一样，前者${}名字叫做eagerGString，它的值在GString被创建时就已经确定了，并且一直指向旧的这个对象，当我们去改变他所引用的x对象时，它是不会更新的；而在后者${-&gt;}中，Groovy采用了懒加载(lazy evaluation)的方式，即每次GString转换为String的时候都会再次调用闭包，因此它就可以更新。下面我们再来看一下两个实例加深一下对两者的理解：12345678910111213class Person &#123; String name String toString() &#123; name &#125; &#125;def sam = new Person(name:'Sam') def lucy = new Person(name:'Lucy') def p = sam //1 def gs = \"Name: $&#123;p&#125;\" //2 assert gs == 'Name: Sam' //3 p = lucy //4 assert gs == 'Name: Sam' //5 sam.name = 'Lucy' //6 assert gs == 'Name: Lucy' //7 上面的代码中： 1、首先将对象sam赋值给变量p； 2、使用了插值符号来调用对象的toString()方法； 3、很显然返回的名字是Sam； 4、如果将lucy赋值给p变量； 5、其依旧指向p变量之前指向的旧对象而不会因为p所指的对象的改变而改变GString的值； 6、但是如果我们只是改变了旧对象的属性； 7、那么很显然GString的值还是会更新的。 因此如果使用的是${}的形式，那么改变所指的对象是不能更新GString的值，但是改变对象的属性的话是可以的。 123456789101112class Person &#123; String name String toString() &#123; name &#125;&#125;def sam = new Person(name:'Sam')def lucy = new Person(name:'Lucy')def p = sam// Create a GString with lazy evaluation of \"p\"def gs = \"Name: $&#123;-&gt; p&#125;\"assert gs == 'Name: Sam'p = lucyassert gs == 'Name: Lucy' 同样的例子，如果是选择了${-&gt;}的形式，那么改变所指的对象是可以更新GString的值的，这就是两种形式的区别。 方法方法的声明Groovy中的方法与JAVA的差别不大，声明方法时可以加上一个返回值的类型，或者直接使用def关键字而无需标注返回值类型，采用这种方法的时候方法的返回值类型的不固定的。方法可以接收任意数量的参数，并且参数的类型可以是无类型的也可以是有类型的还可以是有默认值的。我们在java中使用的一些修饰方法的关键词都是可以用来修饰Groovy中的方法，但是在Groovy中默认情况下不适用任何访问修饰词的情况下是代表public的。最后需要再说一下的是，Groovy中的方法总是会返回值的，如果方法中没有return语句，那么方法中的最后一行将会是该方法的返回值，具体的可以看下面的例子。12345678def someMethod() &#123; 'method called' &#125; //没有参数也没有return关键字并且使用def来声明方法 String anotherMethod() &#123; 'another method called' &#125; //方法的返回值确定 def thirdMethod(param1) &#123; \"$param1 passed\" &#125; //方法接收参数，并且参数的类型是未确定的 static String fourthMethod(String param1) &#123; \"$param1 passed\" &#125; //静态方法，并且参数是有类型的//方法接收三个参数，第一个是无类型的，第二个是String类型，第三个是int类型并且默认值是6String fifthMethod(param1,String param2,int param3 = 6) &#123;\"$param1,$param2,$param3\"&#125; assert fifthMethod(1,\"111\") == \"1,111,6\" //如果调用的时候不传入默认的那个参数，则返回结果就会继续使用默认值assert fifthMethod(1,\"111\",5) == \"1,111,5\" //如果传入了第三个参数，那么默认值将会被覆盖 可变参数的方法在讲闭包的时候我们已经讲到了可变参数，方法中的可变参数与闭包的一致，这里就不再赘述，下面讲一下两种特殊情况： 当方法接收可变参数时，我们调用方法时传入的参数为null 123def foo(Object... args) &#123; args &#125; //1assert foo(null) == null //2asser foo(null,null) == [null,null] //3 我们声明的方法foo，他接收一个可变参数，在第二行中我们传入一个null，此时返回的是空，这里的空并不是一个包含null元素的长度为1的数组；但是在第三行中当我们传入了两个null时，却发现返回的确实长度为2的包含两个null元素的数组。这种情况是需要我们在实践中注意的。 当可变函数方法遇到重载方法时 12345def foo(Object... args) &#123; 1 &#125;def foo(Object x) &#123; 2 &#125;assert foo() == 1 //1assert foo(1) == 2 //2assert foo(1, 2) == 1 //3 在这里只需要注意注释2即可，在注释2中我们传入的参数只有一个，但是两个重载的函数都符合我们的参数数量，这个时候Groovy会选择最为确切的方法来调用，两个方法中一个是可变参数，一个是接收一个参数，当然是后者更为确切了，所以后者被调用。因此遇到这种情况时，函数数量最符合的函数将会被调用。 变量Groovy中的变量我们需要分成两类，一类叫做变量(Field)，一类叫做属性(Property)，尽管我们在JAVA中可以认为这两个其实就是一种东西，但是在Groovy中他们还是有稍微的区别的。 变量(Field) 变量是可以使用访问修饰符的(如 public，protected，private) 可以使用零个或多个修饰符(如 static，final，synchronized) 类型是可选的，即可以声明类型也可以声明为无类型 如下面的实例：1234567class Data &#123; private int id =1 protected String description public static final boolean DEBUG = false private mapping //最好不要声明为无类型的 private Map&lt;String,String&gt; mapping1 //最好在声明时加上确切的类型&#125; 尽管Groovy中支持在变量声明的时候声明为无类型，不过这并不是一个好的编程习惯，Groovy官方推荐我们最好在声明时指定类型。 属性(Property)属性与变量有些许的区别，区别在于它不可以使用访问权限修饰符(public，protected，private)，它的声明格式应该如下：1234class Person &#123; String name int age &#125; Property与Field的区别在于，前者会默认为属性添加setter和getter方法，例如下面的这个例子就可以看出两者的区别：1234567891011class A &#123; public String field //1 String property //2 /* private String property public void setProperty(String property) &#123; ... &#125; public String getProperty() &#123; ... &#125; */&#125; 上面的代码中注释1中创建了一个变量，那它就只是创建了一个变量而已；但是注释2中创建了一个属性，而它的作用则相当于接下来三行注释中的代码，即创建了一个private的同名的变量，以及public的setter与public的getter方法。尽管两种声明的方式原理不一样，但是我们访问这两者的方式却是可以一样的，如下所示:123def a = new A()println a.field //1println a.property //2 上面的代码中第一行没有疑问，因为field变量是public的，但是第二行中property却是private，那为什么可以这样去访问到它呢？因为实际上当调用a.property时，调用的是a.getProperty()或者是setProperty(String property)。下面再讲一个特殊的情况，就是使用final关键词来修饰的属性(property)是只读的，也就是说他只有getter方法没有setter方法，来看下面的实例：123456789101112class Person &#123; final String name final int age Person(String name, int age) &#123; this.name = name this.age = age &#125;&#125;def p = new Person('TOM',13)assert p.name == 'TOM' //1p.name='TONY' //2 上面的代码中注释1处中的p.name实际上是调用了p.getName()函数，但是注释2处却会报groovy.lang.ReadOnlyPropertyException异常，因为被final修饰的属性是不会生成setter方法的，因此当我们要设置这个变量的值时就会报错。 接下来最后一个需要注意的点是Groovy很贴心的一个功能，即只要我们按照Java Bean的规范声明了属性的getter和setter方法，那么我们就不需要再去声明这个变量了，我们就可以直接用对象.属性的方法来访问这个属性了，具体的方法我们看下面的例子：12345678910111213141516class PseudoProperties &#123; // 属性&quot;name&quot;可读可写 void setName(String name) &#123;&#125; String getName() &#123;&apos;Foo&apos;&#125; // 属性&quot;age&quot;只可读 int getAge() &#123; 42 &#125; // 属性&quot;groovy&quot;只可写 void setGroovy(boolean groovy) &#123; &#125;&#125;def p = new PseudoProperties()p.name = &apos;Foo&apos; //1 assert p.name == &apos;Foo&apos; //2 assert p.age == 42 //3 p.groovy = true //4 上面的代码中其实声明了三个变量，只是这三个变量的访问权限不一样而已，在注释1处我们可以设置name的值，注释2可以访问name的值，但是我们却只能访问age的值并不能设置它的值，同理我们也只能设置groovy的值但是不能访问。 变量的作用域在Groovy中变量是有作用域的，普通的Groovy类与JAVA类的变量作用域一致，但是有的时候我们也可以直接写Groovy脚本，即不用定义类直接写代码，这个时候的作用域就不太一样了。下面我们来看看实例：123456789101112131415import groovy.transform.Field //不导入则无法使用Field注解String hello = \"hello\" //定义变量，作用域是本地域def world = \"world\" //定义变量，作用域是本地域helloworld = \"hello world\" //全局变量，作用域是绑定域@Field a = 'I am A' //定义一个全局变量avoid check() &#123; println hello //1报错 println world //2报错 assert helloworld == \"hello world\" //3 assert a == \"I am A\" //4 &#125;check() 解释上面的代码之前我们需要了解一下在Groovy脚本中定义的变量有两种作用域，分别是绑定域(Binding Scope)和本地域(Local Scope)。本地域本地域是脚本中使用 def 定义的动态类型变量或用特定类型定义的静态类型变量的作用域。绑定域绑定域为没有任何前缀修饰的变量的作用域。例如在上面的代码中，hello与world变量的作用域就是本地域，而helloworld的作用域为绑定域。两者的区别是什么呢？因为Groovy脚本会被编译成一个类，类名为文件名，该类继承自groovy.lang.Script类，我们刚才讲到的本地域变量会被声明在该类的run()方法内部作为临时变量，它只能在定义它的代码块中被调用，而不能在其他代码块(其他方法)中被调用；绑定域其实也是被声明在run()方法内部的，但是他会被当做参数传递给调用它的方法，所以实际上的我们就可以理解为我们可以在其他方法中调用绑定域的变量。 通过上面的解释，我们可以清楚的看到上面的代码中注释1处和注释2处之所以会报错就是因为访问不到变量，而注释3则是可以访问到的。还有最后一个就是注释4，首先a变量定义前先导入了Field注解，并在使用的时候显示的引用注解，这个时候a变量就变成了一个全局变量，这是因为a变量在编译之后被声明在了类的层级中，即我们在JAVA中所说的全局变量，既然是全局变量，那么所有的方法都是可以访问到他的。这里需要注意的就是使用@Field注解与使用绑定域的结果尽管是一致的但是原理却是不同的，我们可以使用jd-gui这个可以将class字节码转换为java代码的软件查看上述代码编译之后的情况来验证我们上面的说法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081...public class field_scope extends Script&#123; Object a; public field_scope() &#123; String str = \"I am A\"; this.a = str; &#125; public field_scope(Binding context) &#123; super(context); String str = \"I am A\"; this.a = str; &#125; public static void main(String[] args) &#123; CallSite[] arrayOfCallSite = $getCallSiteArray(); arrayOfCallSite[0].call(InvokerHelper.class, field_scope.class, args); &#125; public Object run() &#123; CallSite[] arrayOfCallSite = $getCallSiteArray(); String hello = \"hello\"; Object world = \"world\"; String str1 = \"hello world\"; ScriptBytecodeAdapter.setGroovyObjectProperty(str1, field_scope.class, this, (String)\"helloworld\"); null; if ((__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) &#123; return arrayOfCallSite[1].callCurrent(this); &#125; else &#123; check(); return null; &#125; return null; &#125; public void check() &#123; CallSite[] arrayOfCallSite = $getCallSiteArray(); arrayOfCallSite[2].callCurrent(this, arrayOfCallSite[3].callGroovyObjectGetProperty(this)); arrayOfCallSite[4].callCurrent(this, arrayOfCallSite[5].callGroovyObjectGetProperty(this)); ValueRecorder localValueRecorder1 = new ValueRecorder(); try &#123; Object tmp64_59 = arrayOfCallSite[6].callGroovyObjectGetProperty(this); localValueRecorder1.record(tmp64_59, 8); Object tmp73_64 = tmp64_59; localValueRecorder1.record(tmp73_64, 8); boolean tmp87_84 = ScriptBytecodeAdapter.compareEqual(tmp73_64, \"hello world\"); localValueRecorder1.record(Boolean.valueOf(tmp87_84), 19); if (tmp87_84) localValueRecorder1.clear(); else ScriptBytecodeAdapter.assertFailed(AssertionRenderer.render(\"assert helloworld == \\\"hello world\\\" //3\", localValueRecorder1), null); &#125; finally &#123; localValueRecorder1.clear(); throw finally; &#125; ValueRecorder localValueRecorder2 = new ValueRecorder(); try &#123; Object tmp139_136 = this.a; localValueRecorder2.record(tmp139_136, 8); Object tmp148_139 = tmp139_136; localValueRecorder2.record(tmp148_139, 8); boolean tmp162_159 = ScriptBytecodeAdapter.compareEqual(tmp148_139, \"I am A\"); localValueRecorder2.record(Boolean.valueOf(tmp162_159), 10); if (tmp162_159) localValueRecorder2.clear(); else ScriptBytecodeAdapter.assertFailed(AssertionRenderer.render(\"assert a == \\\"I am A\\\" //4\", localValueRecorder2), null); &#125; finally &#123; localValueRecorder2.clear(); throw finally;&#125; &#125;&#125; 类上面说到Groovy其实是可以不用定义类的，这也符合脚本语言的特性。不过如果是比较复杂的工程，为了能够系统的管理代码，我们还是需要为其定义类。定义类的方法与JAVA类似，但是不需要使用public关键字，因为在Groovy中默认就是public，不仅仅是类，方法与变量也是这样的。我们先用下面的代码来看看Groovy语言的特点。12345678910111213class Language&#123; def name def difficulty String toString()&#123; \"$name,$difficulty\" &#125;&#125;def java_lan =new Language()java_lan.setName \"JAVA\"java_lan.difficulty = 5println java_lan 上面的代码相信大家现在是可以看得懂的啦，下面我们再讲一下关于Groovy中的类其他需要注意的事项： 类中无须定义构造方法 在Groovy的类中，其实有两个默认的构造方法，一个是无参的，一个是带有map参数的构造函数，所以实际上我们有什么函数只需要通过这个带有map参数的函数传递即可，请看下面的实例： 12345def java_lan =new Language()java_lan.setName \"JAVA\"java_lan.difficulty = 5def groovy_lan = new Language([\"name\":\"Groovy\",\"difficulty\":5]) import的用法 import语句与JAVA很相似，但是也增加了一些新的特点1234567891011121314//包声明package com.bob.groovy.test//import语句1import groovy.json.JsonBuilderdef json1 = new JsonBuilder()//import语句2import groovy.json.*def json2 = new JsonBuilder()//import语句3，使用as关键字取别名import static Calendar.getInstance as nowassert now().class == Calendar.getInstance().class 不过要特别注意，Groovy与Java类似，已经帮我们默认导入了一些常用的包，所以在我们使用这些包的类时就不用再像上面那样导入了，如下是自动导入的包列表：12345678import java.lang.*import java.util.*import java.io.*import java.net.*import groovy.lang.*import groovy.util.*import java.math.BigIntegerimport java.math.BigDecimal","categories":[{"name":"一口一口吃掉Gradle","slug":"一口一口吃掉Gradle","permalink":"http://www.wensibo.top/categories/一口一口吃掉Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://www.wensibo.top/tags/Gradle/"}]},{"title":"一口一口吃掉Gradle（一）：初识Gradle","slug":"gradle1","date":"2018-02-07T04:07:25.000Z","updated":"2018-10-21T08:26:20.748Z","comments":true,"path":"2018/02/07/gradle1/","link":"","permalink":"http://www.wensibo.top/2018/02/07/gradle1/","excerpt":"2018年的第一篇文章将会给大家介绍Gradle，这会是一个系列的文章，名字依旧是一口一口吃掉。相信很多朋友都和我一样从eclipse转到Android Studio时是又爱又恨，爱是因为Android Studio功能强大，UI也很炫酷，当然还有Google爸爸支持；恨是因为从比较熟悉的eclipse一下子转到了Android Studio，本以为速度会快很多，然而现实却给了自己一记大耳光，其次就是Android Studio采用了Gradle来对项目进行编译，但是Gradle是个啥鬼咯，配置文件又看不懂，首次编译还得下载，下载速度贼慢，不fq就gg。Android Studio现在已经更新到3.0.1.0，如果你对Gradle还不是很熟悉，那这个系列的文章将会帮到你。相信仔细看完整个系列之后你将会对如何在Android开发中使用Gradle得心应手。祝你好运，我们出发吧！","text":"2018年的第一篇文章将会给大家介绍Gradle，这会是一个系列的文章，名字依旧是一口一口吃掉。相信很多朋友都和我一样从eclipse转到Android Studio时是又爱又恨，爱是因为Android Studio功能强大，UI也很炫酷，当然还有Google爸爸支持；恨是因为从比较熟悉的eclipse一下子转到了Android Studio，本以为速度会快很多，然而现实却给了自己一记大耳光，其次就是Android Studio采用了Gradle来对项目进行编译，但是Gradle是个啥鬼咯，配置文件又看不懂，首次编译还得下载，下载速度贼慢，不fq就gg。Android Studio现在已经更新到3.0.1.0，如果你对Gradle还不是很熟悉，那这个系列的文章将会帮到你。相信仔细看完整个系列之后你将会对如何在Android开发中使用Gradle得心应手。祝你好运，我们出发吧！ 何为Gradle在了解Gradle之前，我们来讲讲在Gradle之前我们构建Android程序的时候使用的最多的是Ant以及Maven，我们简单看看三者有什么区别。 AntAnt是在2000年的时候发布的，因其简单易学的特点很快就成为了十分流行的Java项目的构建工具。Ant的优点就是： 简单、易学，不需要什么特殊准备就能上手 基于过程式编程思想使得构建非常灵活 不足之处就是使用XML作为脚本配置格式，如果项目比较大的话，XML文件将会很难管理。 MavenMaven是在2004年的时候发布的，他的出现在一定程度上解决了Ant的一些缺点。但是Maven同样沿用了Ant的做法：即把XML作为构建配置的文件格式，不过文件结构却有了巨大的变化： Ant需要开发者将执行task所需的全部命令都列出来 而Maven依靠约定并提供现成的可调用的目标 不仅如此，Maven更重要的一个进步是具备从网络上自动下载依赖的能力（当然Ant后来通过Ivy 也具备了这个功能）。 Maven的缺点就是： 依赖管理不能很好地处理相同库文件不同版本之间的冲突（Ivy在这方面更好一些） XML作为配置文件的格式有严格的结构层次和标准，定制化目标很困难 GradleGradle则是在2012年发布的，它吸收了前两者的优点并极大的改进了他们的缺点，使其成为了Google官方推荐的构建语言。Gradle最大的改进就是摒弃了XML而是使用了一门基于java的Groovy语言作为构建脚本的书写语言，使得原本采用XML、冗杂得难以维护的配置文件变得清爽强大许多。 如果你还想对三者的对比有一个更直观的印象，可以查看这篇文章了解更详细的内容。这篇文章介绍了完成同一任务，三个构建工具的代码如下：Ant的ivy.xml文件1234567&lt;ivy-module version=\"2.0\"&gt; &lt;info organisation=\"org.apache\" module=\"java-build-tools\"/&gt; &lt;dependencies&gt; &lt;dependency org=\"junit\" name=\"junit\" rev=\"4.11\"/&gt; &lt;dependency org=\"org.hamcrest\" name=\"hamcrest-all\" rev=\"1.3\"/&gt; &lt;/dependencies&gt; &lt;/ivy-module&gt; Ant的build.xml文件1234567891011121314151617181920212223242526272829&lt;project xmlns:ivy=\"antlib:org.apache.ivy.ant\" name=\"java-build-tools\" default=\"jar\"&gt; &lt;property name=\"src.dir\" value=\"src\"/&gt; &lt;property name=\"build.dir\" value=\"build\"/&gt; &lt;property name=\"classes.dir\" value=\"$&#123;build.dir&#125;/classes\"/&gt; &lt;property name=\"jar.dir\" value=\"$&#123;build.dir&#125;/jar\"/&gt; &lt;property name=\"lib.dir\" value=\"lib\" /&gt; &lt;path id=\"lib.path.id\"&gt; &lt;fileset dir=\"$&#123;lib.dir&#125;\" /&gt; &lt;/path&gt; &lt;target name=\"resolve\"&gt; &lt;ivy:retrieve /&gt; &lt;/target&gt; &lt;target name=\"clean\"&gt; &lt;delete dir=\"$&#123;build.dir&#125;\"/&gt; &lt;/target&gt; &lt;target name=\"compile\" depends=\"resolve\"&gt; &lt;mkdir dir=\"$&#123;classes.dir&#125;\"/&gt; &lt;javac srcdir=\"$&#123;src.dir&#125;\" destdir=\"$&#123;classes.dir&#125;\" classpathref=\"lib.path.id\"/&gt; &lt;/target&gt; &lt;target name=\"jar\" depends=\"compile\"&gt; &lt;mkdir dir=\"$&#123;jar.dir&#125;\"/&gt; &lt;jar destfile=\"$&#123;jar.dir&#125;/$&#123;ant.project.name&#125;.jar\" basedir=\"$&#123;classes.dir&#125;\"/&gt; &lt;/target&gt; &lt;/project&gt; Maven的pom.xml文件12345678910111213141516171819202122232425262728293031323334&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.technologyconversations&lt;/groupId&gt; &lt;artifactId&gt;java-build-tools&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-all&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; Gradle的build.gradle文件则只需要如下代码即可123456789101112131415apply plugin: 'java' apply plugin: 'checkstyle' apply plugin: 'findbugs' apply plugin: 'pmd' version = '1.0' repositories &#123; mavenCentral() &#125; dependencies &#123; testCompile group: 'junit', name: 'junit', version: '4.11' testCompile group: 'org.hamcrest', name: 'hamcrest-all', version: '1.3' &#125; 单单从代码量上做一个选择的话，相信大家都会选择Gradle吧！ Gradle有啥作用我们一直在说Gradle是一个构建工具，可是构建(build)究竟是个啥意思呢？我们以Android平台为例，构建就是将我们的代码，资源文件进行打包，编译最后形成一个可以安装运行的apk文件的过程。如果你还不是很了解，那么我们来瞧瞧Google官方给出的Android应用程序构建的完整流程图吧！ 典型 Android 应用模块的构建流程 上述的流程主要包含以下几个过程：1234将程序中的以及引用的第三方库中的资源文件、代码文件、和aidl文件通过java编译器编译成.class文件，再通过dex工具将.class文件转换为.dex文件。使用apkbuilder工具将所有未编译的资源（如图片），已编译的资源和.dex文件打包到.apk文件中。jarsigner工具使用调试密钥或正式发行版本的秘钥将.apk文件签名。使用zipalign工具对齐.apk包中的文件，以减少其在设备上运行时的内存占用。 以上的每个步骤就是构建工具需要完成的，也就是说这其中的许多事情都是由Gradle来干的。所以说没有Gradle那就需要我们手动一个步骤一个步骤做，有了构建工具，程序员只需要动动手指就可以啦！ 搭建Gradle开发环境工欲善其事,必先利其器，想要了解并且使用Gradle，我们得先把开发环境搭建起来。 下载下载的方法有很多种，这里介绍的是适用于各个平台的，首先需要到Gradle官网，然后找到你想要的版本下载即可。需要注意的是Gradle官网的服务器在国外，所以下载速度贼慢，最好是能够自备梯子，否则你需要耐心等待一段时间。在这个页面中你会看到同一个版本号也有几个版本，如：-src对应的是Gradle源代码，这个不是我们需要下载的；-bin对应的是二进制版本，但不包含源代码，文档等，体积相对较小；-all版本是完全版，既包含了编译需要的二进制文件，也包含了源代码和开发文档等。推荐大家一开始可以下载一个-all版本作为你主要使用的版本，如果你需要使用到其他版本号的，再去下载其他版本号对应的-bin版本，这样可以节省磁盘空间。当然如果你只安装了-bin版本，你可以到这里查看在线的官方文档，在这里查看Gradle的源代码。 解压&amp;配置环境变量下载完成之后需要解压，以-all版本为例，解压之后的目录结构如下图所示： gradle-4.1-all目录结构图 接着就是配置环境变量Linux系统下12345vim /etc/profile## 将\"/usr/local/gradle-4.3\"替换为你解压好的gradle的根目录export GRADLE_HOME=/usr/local/gradle-4.3PATH=$PATH:$GRADLE_HOME/binsource /etc/profile Windows系统下在环境变量配置页面新增一个系统变量GRADLE_HOME，值为你解压好的gradle的根目录；接着修改Path变量，在最后追加%GRADLE_HOME%\\bin;，之后点击应用，确定即可。 配置好之后需要测试一下Gradle的开发环境是否搭建成功，在linux下打开终端，在Windows下则是打开命令行，输入gradle -v然后回车，如果输出的信息与下面类似那就说明Gradle的开发环境已经搭建成功啦！ 123456789101112bob@bob-PC:~$ gradle -v------------------------------------------------------------Gradle 4.3------------------------------------------------------------Build time: 2017-10-30 15:43:29 UTCRevision: c684c202534c4138b51033b52d871939b8d38d72Groovy: 2.4.12Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_131 (Oracle Corporation 25.131-b11)OS: Linux 4.9.0-deepin4-amd64 amd64 写一个Hello World的小demo前面我们说到Gradle是基于Groovy的，所以我们还得再学Groovy，下面的这个例子我们就先来领略一下Groovy，具体的语法我们将在下一篇文章继续学习。首先我们新建一个目录，然后在目录下新建一个build.gradle文件，接着用记事本或者sublime打开，写入如下代码：123task hello&#123; println 'Hello World'&#125; 之后保存，之后打开终端(Windows使用命令行)进入当前目录(Windows可以直接在当前目录下同时按住Shift键和鼠标右键选择命令行或者Powershell打开则可以直接进入当前目录)，输入如下代码：1gradle -q hello 不出意外的话屏幕上会打印Hello World。 我们再来回顾一下整个过程，首先是新建一个build.gradle文件，有没有很熟悉呢？在Android项目中，也经常会出现build.gradle文件，在工程中他扮演着十分重要的角色，现在只需要知道它是整个项目的入口即可，具体的我们后续再讲。接着我们再来看看在build.gradle文件中插入的代码是什么意思:123task hello&#123; println 'Hello World'&#125; 首先声明了一个task(任务)，这个任务的名称叫做hello，接着使用{}将该任务的内容包围起来，即花括号里面的内容就是这个hello任务的内容，我们看到他的输出语句与java十分相似，但是也有不同点： java中方法的声明和调用需要使用()，但是groovy则可以不用，这样可以更加简洁。 java使用双引号来表示字符串，但是在groovy中则直接使用了单引号，这是因为在groovy的语法中，字符串的表达方式比较多种，有的需要单引号&#39;&#39;，有的需要双引号&quot;&quot;，还有的需要三引号&#39;&#39;&#39;&#39;&#39;&#39;，每种符号都有他使用的场景与作用，这个我们也是放到后面再讲。 java需要使用分号来表示一行语句的结束，而groovy与kotlin一样不需要使用分号来作为语句的结束标志，只需要换行即可。最后我们使用命令行输入的gradle -q hello又是代表什么意思呢？首先gradle则是命令，它会去查找当前所在目录下的build.gradle文件，因为这个文件就是整个命令的入口，而hello就是我们刚才命名的任务的名称，那么-q又是什么呢？其实这里的-q代表quiet模式，它不会生成 Gradle的日志信息(log messages)，所以用户只能看到tasks的输出，这样可以让输出信息更加清晰。 通过上面的说明大家应该都能够理解。 Gradle Wrapper相信大家在运行github上的项目时经常会出现导入失败的问题，例如我们将一个项目导入了Android studio，但是由于项目使用的gradle版本与我们本机安装的不一致，尽管我们可以手动更改配置文件使得该项目使用我们本机的gradle，不过不同的gradle版本对应用程序的编译支持又不一样，所以最好就是还得自行下载gradle然后再运行，这就是为什么我们在Android studio倒入一个项目有的时候需要很久的原因。为了应对着一些列复杂的操作，Google推出了gradle wrapper(即gradle包装器)。接下来我们来看看gradle wrapper是如何解决的。 首先程序的开发者需要为工程提供gradle wrapper的支持我们使用者想要使用gradle wrapper来构建项目，得需要项目的开发者为该工程添加gradle wrapper的支持，这样我们要使用的时候才知道需要哪个版本的gradle来构建项目。为工程添加gradle wrapper其实很简单，一般来说有两种方法。 使用终端(或命令行)添加gradle wrapper在项目的根目录下打开终端或者命令行并进入到该目录，接着使用如下的命令即可：12345## 将下方4.0换成你需要的gradle版本号，将all换成你需要的版本类型，例如binbob@bob-PC:~/workspace/gradle_workspace/how_to_use_gradleWrapper$ gradle wrapper --gradle-version 4.0 --distribution-type allBUILD SUCCESSFUL in 9s1 actionable task: 1 executed 如果出现了上方的构建成功的信息则代表已经成功为工程添加了gradle wrapper。 编写文件添加gradle wrapper我们还可以通过编辑项目根目录的build.gradle文件，为该文件添加如下代码：1234task wrapper(type: Wrapper) &#123; gradleVersion '4.0' distributionType 'all'&#125; 我们可以看到其实就是添加了一个名为wrapper的任务，该任务还接受一个Wrapper类型的参数，然后在任务内部可以定义gradle的版本号，以及版本类型，根据我们的需要自行修改即可。添加完该任务之后还是打开终端或者命令行进入项目的根目录执行wrapper任务：1234bob@bob-PC:~/workspace/gradle_workspace/how_to_use_gradleWrapper$ gradle wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 通过这种方式我们也是可以为项目添加gradle wrapper的。 添加了gradle wrapper之后项目的根目录下添加了如下几个文件：12345678.├── build.gradle├── gradle│ └── wrapper│ ├── gradle-wrapper.jar│ └── gradle-wrapper.properties├── gradlew└── gradlew.bat 新增加的四个文件各有含义： gradlew：linux下执行gradle wrapper的脚本 gradlew.bat：windows下执行gradle wrapper的脚本 gradle-wrapper.jar：gradle wrapper微类库，包含下载和解包gradle运行时的逻辑 gradle-wrapper.properties：gradle wrapper元信息，包含已下载gradle运行时的存储位置和原始URL 使用gradle wrapper构建项目现在我们使用者已经拿到了支持gradle wrapper的项目，我们只需要打开终端或者命令行并导航到项目的根目录然后执行：1234## linux系统下./gradlew build## Windows系统下gradlew build 即可编译项目。这里的gradlew就是gradle wrapper的缩写了。当我们使用gradlew运行gradle时，他会首先检查wrapper对应的gradle是否可用，如果可用，他会将gradlew的所有参数委托给gradle，然后执行构建，如果gradle包不可用，它就会首先下载对应版本的gradle，然后再构建。 下载很慢怎么办？如果执行了上述的命令之后发现gradle的下载很慢，那我们可以手动修改gradle-wrapper.properties文件，将其中的distributionUrl更改成下面这样，这样他就会复用我们本地的gradle而不是去服务器下载。1234## linux系统下：distributionUrl='file:/home/bob/gradle/gradle-4.0-all.zip'## Windows系统下：distributionUrl='file:///D:/grale/gradle-4.0-all.zip' Gradle该如何学习通过上面的学习想必大家对gradle应该有了初步的认识了，但是gradle的知识还有很多，那我们要怎么学呢？ 首先gradle是基于groovy语言的，所以我们需要对groovy的语法有所了解，我们将在下一节与大家一起学习。 接着就是深入到Android项目中，来看看gradle的文件结构。 随后需要了解的就是gradle的插件，这些插件有的是专门用于Android项目的构建的，所以我们需要结合文档一起来理解。 再后面的话我们还得了解如何构建变体，例如我们需要为一个项目编译多个不同应用市场的渠道包。当然还有很多，这里只是先给大家一个思路，之后的文章我们一起继续学习。","categories":[{"name":"一口一口吃掉Gradle","slug":"一口一口吃掉Gradle","permalink":"http://www.wensibo.top/categories/一口一口吃掉Gradle/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://www.wensibo.top/tags/Gradle/"}]},{"title":"2017年终总结","slug":"2017summary","date":"2017-12-31T08:07:25.000Z","updated":"2018-10-21T08:26:20.472Z","comments":true,"path":"2017/12/31/2017summary/","link":"","permalink":"http://www.wensibo.top/2017/12/31/2017summary/","excerpt":"大家好，不知不觉已经有两个月的时间没有更新文章了，时间真是过得好快啊，转眼间2017也已经来到了最后一天，这篇文章就来记录和总结一下过去的这个2017年吧！过去的两个月时间里状态不是很好，加上学校大四了还一大堆课，一大堆作业要做。本以为拿了offer就可以轻松看书学习了，想不到这段时间过得比找工作还累。本来计划的文章都没有写，拖延症太重了，不过最主要的原因还是自己的惰性太严重了，希望在接下来的新的一年里能有所改善吧！2017年对我来说注定是不简单的一个年份，有收获有遗憾，收获的是有了人生中第一份工作、在开源世界上有了自己更多的贡献、阅读了许多经典的书籍让自己的知识的深度和广度上了一个台阶、当然也结识了许多志同道合优秀的朋友、同时趁着自己大学时光的最后一年也出去走走看看；当然遗憾也不少，总感觉时间不够用，也总感觉自己浪费了许多宝贵的年华，每每想到这些心头总是唏嘘不已。","text":"大家好，不知不觉已经有两个月的时间没有更新文章了，时间真是过得好快啊，转眼间2017也已经来到了最后一天，这篇文章就来记录和总结一下过去的这个2017年吧！过去的两个月时间里状态不是很好，加上学校大四了还一大堆课，一大堆作业要做。本以为拿了offer就可以轻松看书学习了，想不到这段时间过得比找工作还累。本来计划的文章都没有写，拖延症太重了，不过最主要的原因还是自己的惰性太严重了，希望在接下来的新的一年里能有所改善吧！2017年对我来说注定是不简单的一个年份，有收获有遗憾，收获的是有了人生中第一份工作、在开源世界上有了自己更多的贡献、阅读了许多经典的书籍让自己的知识的深度和广度上了一个台阶、当然也结识了许多志同道合优秀的朋友、同时趁着自己大学时光的最后一年也出去走走看看；当然遗憾也不少，总感觉时间不够用，也总感觉自己浪费了许多宝贵的年华，每每想到这些心头总是唏嘘不已。 关于实习和工作今年一共有两次实习的经历，一个较长一个较短，较长的是在博雅，较短的是在CVTE，两家公司的同事和导师们都十分的nice，在这两段实习的时间里真的能够体会到商业项目与个人项目巨大的区别。前一段实习经历我记录在了这篇文章中，后一段实习则因为自己的拖延症迟迟没有写成文章，不过在这短短的一个星期的考核实习中我的导师以及领导对我的帮助确实是巨大的，尤其是在对工程框架、编码规范、设计模式以及性能优化方面，很感谢他们给我提出的意见。当然我觉得在实习中也有一个比较好的建议想与大家一起分享的，其实这对正式工作也是有很大帮助的，那就是在每天早上工作前先列一个任务清单，确定自己一天需要完成的任务，这能够让你对一天的工作量有所准备，同时也让你更有计划性；接着是一天工作完之后最好能花点时间总结一下今天的任务完成的如何，同时记录自己工作过程中的收货以及遇到的困难等等，我觉得这个方法对我这个菜鸟确实帮助挺大的。关于工作，我之前也写过一篇文章：一个三非渣本的安卓秋招之路 ，不过当初在写文章的时候还没有确定正式签约的公司，最后我选择了珍爱网，希望在这里能够遇见美好。 关于开源这一年我开始逐步的拥抱开源，在开源世界上吸收了许多前辈们贡献的成果和经验，当然在此基础上我也向开源世界开始贡献我的绵薄之力。 Github 贡献图 上面这张图是我2017年总共的贡献图，实在惭愧，上半年完成的还是可以，但是到了下半年因为要实习还有找工作再加之拖延症一片惨不忍睹的白啊。 repositories 这一年一共写了9个项目，但是真正意义上的只有4个，其中start数量比较多的是GankClient这个项目,我也把这个APP上架到了酷安酷市场了，目前的下载量是1992，下面两张图展示了干货集中营的下载量和评论情况。 gank gank 当然干货集中营这个APP还是需要感谢代码家的支持，以及许多写过干货集中营客户端的前辈们，我也是在向你们借鉴学习的过程中完成的。 关于博客2017年1月份开始搭建的独立个人博客，在这一年的时间里网站总访客数：22725，网站总访问量：59067 网站访问量 在这一年里时间里，真的很感谢大家的支持，同时博客文章的内容质量不断的提升，博客内容应用层逐步转向系统层面，今后要与大家分享的则会是关于底层方面的知识。全年一共写了23篇文章，加上这篇就是24篇，但是从9月份开始更新频率就下了许多，原本是计划每个月2-3篇文章的，来年加油啦！ 博客内容归档 当然除了在自己的博客上写之外，我还同步在掘金，简书，博客园这三个第三方网站上，当然我会更喜欢掘金一些，因为在掘金上分享技术更为纯粹，并且它也只分享技术，今天偶然查看自己的主页，原来已经有188人关注我啦，获得的start数量也有761个，文章的阅读数量为17459。 掘金 看书今年看的书不少，下面这张图是我认真看并且觉得不错的书。 books 还有几本书有的借人了，有的放在图书馆没有拿回来没有拍照，列在下面供大家参考。 Android进阶之光 Android开发艺术探索 高性能Android应用开发 网络是怎样连接的 算法（第4版） 程序员的算法趣题 Java编程思想（第四版） Gradle for Android (PDF)其中《鸟哥的私房菜》、《Java编程思想》没有全部看完，只看了其中的一部分。讲真今年买书花了还挺多钱的，但是如果对自己有所帮助还是很愿意投资的，并且也知道作者出书不容易，应该支持正版啦！ 朋友写博客确实认识了许多志同道合的朋友，这里不能一一举例实在抱歉，向大家推荐两个我比较熟悉的大神，两位都还是学生，@Carson_Ho是研究生，@Tonny则跟我一样也是大四，两位大神比我厉害多了，我也经常看他们的博客和开源项目，@Carson_Ho博客的更新频率真的很赞，一个月都有几篇，这一点真的很棒啊，希望以后我也能向他这样。 世界那么大我想去走走大学最后一年，也想利用着最后的一点时间出去走走看看，于是就去了成都和重庆，讲真我可能是假的广东人，并不觉得四川和重庆的很辣，难道是我吃了假的辣椒？ 成都 重庆 遗憾2017年遗憾的事情还是挺多的，究其原因还是自己有的时候太懒惰了，没有一直坚持下去，无论是写博客还是开源项目，到了下半年都有所松懈。再加之我也很容易被琐碎的事情打扰，也因为如此很多事情都中途而费了，希望来年自己能够在这方面有所改进。 2018年展望2018年自己将迎来工作的第一个年头，希望自己能够尽快适应新的工作环境，在工作上能够有所建树。当然在技术学习的道路上也应用永无止境，自己也已经开始准备学习人工智能和深度学习方面的内容，技术人唯有不断学习才不会太快被淘汰。2018年博客将会继续更新，接下来将会写一个有关Gradle的系列文章，到后面还会与大家一起分享更多流行的技术；文章的更新频率方面会比今年做的更好，在工作学习之余会抽出更多的时间来更新文章。最后祝大家2018年新年快乐，新的一年大家都能心想事成！","categories":[{"name":"年终总结","slug":"年终总结","permalink":"http://www.wensibo.top/categories/年终总结/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://www.wensibo.top/tags/总结/"}]},{"title":"一个三非渣本的安卓秋招之路","slug":"interview","date":"2017-10-29T08:23:20.000Z","updated":"2018-10-21T08:26:20.816Z","comments":true,"path":"2017/10/29/interview/","link":"","permalink":"http://www.wensibo.top/2017/10/29/interview/","excerpt":"距离上次更新文章已经过去一个多月了，实在是很抱歉没有按照进度更新博客。最近主要是在忙秋招，前几天也刚刚结束，所以这篇文章就来和大家一起分享我的秋招之路。或许大部分朋友都是从这篇文章————2017腾讯实习生Android客户端开发面试总结开始认识我的吧，在那篇文章中我也讲到自己是非科班出身，同时学校也是非985非211的普通一本学校，这也就是标题中讲到的“三非”，这篇文章主要是记录一下我的秋招历程，在文章中我也会分享自己准备秋招的一些经验，希望对大家有所帮助。话不多说让我们开始吧！","text":"距离上次更新文章已经过去一个多月了，实在是很抱歉没有按照进度更新博客。最近主要是在忙秋招，前几天也刚刚结束，所以这篇文章就来和大家一起分享我的秋招之路。或许大部分朋友都是从这篇文章————2017腾讯实习生Android客户端开发面试总结开始认识我的吧，在那篇文章中我也讲到自己是非科班出身，同时学校也是非985非211的普通一本学校，这也就是标题中讲到的“三非”，这篇文章主要是记录一下我的秋招历程，在文章中我也会分享自己准备秋招的一些经验，希望对大家有所帮助。话不多说让我们开始吧！ 前言先来说一下我目前的情况吧，截止到这篇文章发布的时候，我手上是拿到了4个offer，分别是实习的公司，珍爱网，久邦数码，租租车，在等待最终结果的是还有1个。像我这种实力是拿不到大厂offer的啦，请大神们轻喷。回顾整个秋招，从8月底开始，先后总共投了11份简历，8份过了笔试来到了面试，在这8个中有2个一面挂分别是腾讯和4399，剩下6个都到了终面，最后有1个终面挂，剩下5个就是上面说到的5个。很多朋友会问为什么只投了11份呢？因为个人的关系，我选择在广东省内工作，其实主要就是广州和深圳，再加上本身投递的岗位是Android开发，所以选择的公司就少了很多了，其实我也很羡慕那些能够到外省工作的同学，当然这个是个人自己的选择啦！下面我就来细讲一下这些面试的过程。 面试总结体验最好的面试————CVTECVTE是我第一个去面试的公司，三轮面试下来总共是两天，不过两天不连续，这两天的面试都是到地铁站附近等候公司的班车过来，然后坐班车前往公司面试，一面二面安排在同一天，从等待面试的人数就可以看出CVTE很受欢迎。当天我是早上11点到的公司，然后工作人员安排我们到电影院稍作休息，等候面试通知，从公司的基础设施以及环境就可以看出CVTE还是挺有钱的，工作人员也十分的热情，整个面试流程也是尽然有序。 CVTE一面一面的时候是两个面试官同时面试我，一个问问题的时候另一个做记录，另外一个问问题再由另一个做记录，这轮面试总共40分钟，面完之后感觉快要虚脱，因为面试节奏很快，如果脑袋不够用就可能当场gg，不过问的问题都是很基础的知识，只要基础够扎实基本没问题。下面是我被问到的一些问题：1234567891011121314151617181920212223242526从ActivityA跳转到ActivityB的生命周期调用顺序？Activity的四种启动方式？Android多线程的通信方式有什么？做简要介绍。Android中的消息机制？HandlerThread的原理？Window的工作原理和作用？自定义View的流程以及需要注意哪些地方？自定义View的时候如何实现wrap_content属性？View事件分发机制？滑动冲突的解决方法有哪些？子View如何通知父View去拦截某事件？Volley原理？retrofit原理？JAVA的四种元注解是什么？主要作用有哪些？okhttp原理？老年代与新生代的区别？JVM中的复制算法是什么？java加锁机制有哪些方法？原理分别是什么？wait()和sleep()的区别是什么？synchronized关键字的四种用法和区别？onCopyWriteArrayList的原理？Hashmap实现原理？concurrentHashmap原理？反射机制原理？动态代理原理？单例模式有哪些实现方法？手写算法题————字符串反转的有哪些方法？ 一面大概历时40分钟，时间也来到12点多，结束之后就等待二面，因为怕面试官通知面试所以就没去吃午饭，话说CVTE的零食和饭堂都是挺不错的，可惜没有去尝一下。差不多一点多的时候就是二面。 CVTE二面二面应该是总监面，问题主要偏向项目，有一些问题已经忘记了，只能列出一些还记得的：123456789101112做了哪些项目？详细说一下项目。讲一下RXJava原理；subscribeOn()与observeOn()哪一个方法多次切换线程只有第一次有效？为什么？Volley原理？Retrofit原理？Volley与Retrofit缓存机制有哪些区别？简单工厂，工厂方法，抽象工厂三种设计模式的优缺点？什么是内存泄露，什么是内存溢出？平常使用什么分析工具来优化APP的性能？手写算法题————实现一个栈Java的集合类包括哪些？各自有什么特点？为什么写博客？今后想要往哪些方面发展？ 二面其实发挥得不好，尤其是讲到RxJava的时候，因为没有仔细看RxJava源码，后续会写关于这个开源库源码解析的文章。过了几天之后面试状态变成了终面，然后就前往CVTE的第二产业园进行HR面，一般是两个面试官同时面三个同学，不过因为我面的那一批人数不够，所以只是2对2。不得不说CVTE的HR真的很专业，把我从小到大的事情都扒出来了，问的问题大体如下：1234567891011121314对自己两轮面试打一下分都面试了哪些公司，拿到哪些offer？小时候印象最深刻的一件？说说自己的家庭情况？说说对自己影响最大的人？父母的性格都是怎么样的？从小什么事情对自己的影响最大？期望的工作地点，每天期望的工作时间？一周期望工作多久？有什么理由会让你拒绝CVTE的offer？说说你对薪资的要求？觉得什么是自己不喜欢的？说一下自己的优点和缺点？梦想是什么？有什么问题想问我？ 全程还是挺严肃的，大概30分钟，不过因为之前对一些问题做了准备，所以没有遇到太大的难题。HR面之后过了几天官网显示已经通过终面，不过终面过了并不表示能够顺利拿到offer啦，按照CVTE的惯例，顺利通过终面的学生一般是需要经历一周的考核，考核的项目完成之后会进行再一轮的HR面，最后才会给结果。也就在前两天我刚刚结束了为期一周的实习，实习期间我的导师，同事，老大都很nice，有什么问题都可以向这些同事们请教，他们都会很耐心的帮忙解答，更重要的是CVTE给实习生的待遇很好，除了很好吃的一日三餐以及宵夜之外还会安排公司的公寓式酒店给实习生入住，相信去实习的同学对这点应该都很清楚。说了这么多好的那也该说一下不是特别好的地方，首先就是工作强度会稍微有点大，不过因为我是短期实习生，同时也要这3~4天内完成一个项目，所以压力相对大，每天几乎都是8点半左右上班工作到晚上9点多，中午12点多吃午饭，下午两点上班，如果你觉得这样的工作强度适应的了的话那来CVTE肯定是很好的选择，最后再说一下项目考核之后的HR面吧：123456789101112131415161718192021实习的这一周有什么不适的吗？对公司的安排有什么意见吗？觉得哪方面还没有达到你的预期？跟家里人说了来实习的情况了吗？家里人都说了些什么？父母对你未来的期望是什么？未来对父母有什么打算？家里情况怎么样？父母对你的影响是什么？从小到大对你造成的负面影响最大的事情是什么？哪一段时间是自己压力最大的时候？给自己的实习考核打个分？觉得自己能不能够通过此次的考核？为什么？期望的薪资是多少？最低的薪资要求是多少？如果考核评估觉得你无法达到这样的薪资水平你该怎么办？如果没有通过CVTE的考核你该怎么办？手里都拿到哪些Offer了？薪资水平都怎么样？都拿到这么多offer了为什么还来实习？为什么会选择CVTE？有什么理由让你拒绝CVTE的offer？什么情况下你会从CVTE离职？还想对我们说什么？用一句话表达。 讲真，经历了这么多次面试，CVTE的HR面给我的印象是最深刻的，当然这次的面试压力也是最大的，跟我一起面试的另一个小伙伴也顶着很大的压力，我们两个面试结束之后都大口的舒了口气，这次的HR是相对比较高层的，经验可以说相当丰富啊，对每个问题都会挖得很深直击要害，如果没有提前做好充分的准备可能会被问哭。总之这个星期的实习确实是个非常不错的经历。 体验最糟的面试————4399其实这样黑4399也不是很好，那就当成是我个人的片面之见吧，写出来只是与大家分享而已，完全没有恶意。4399的面试是在华工中心酒店，去之前就听说今年的面试有点水，一面似乎都是20分钟草草而过，听去面试的同学讲起问的技术问题不多，主要聊人生。本来也不是很想去的，因为同时间也赶着去另外一家公司面试，不过为了给自己多一次机会，所以也来到现场。话说4399的人气不是盖的，会议室里坐满了人，到了现场不到3分钟就被叫去一面。 4399一面123456789自我介绍问了一下项目说说ListView与RecyclerView的区别说说以后的发展方向为什么写博客用过什么设计模式？问说需不需要详细说一下面试官说不用。有优点和缺点？觉得自己什么情况下会离职？怎么学习Android的？ 大概就这些问题了，面完之后面试官叫我出去等一下，然后前台的工作人员过了一阵子叫我先回去等消息，接着另一个工作人员叫我稍等一下，然后在电脑上处理了3分钟左右，接着另外一个工作人员又叫我去面二面，不过刚才那个工作人员说他在处理我的，又过了2分钟他叫我回去等消息了。听到这个回复就知道gg了。总体评价一下这次的面试，感觉4399确实很多人想去，不过不知道今年是不是不怎么招人，感觉面试都很水，也有可能面试官觉得我很渣，然后随便问问过一下流程吧！不过我一直觉得面试是一个互相了解的过程，双方都应该尊重彼此，不然怎么体现这个公司的形象呢？ 最轻松幽默的面试————珍爱网珍爱网简历是在8月份就投了，10月13号的时候在华工进行了现场笔试，最后HR面的时候面试官跟我说其实我的笔试成绩有点低(尴尬脸)，当初做的时候觉得除了算法题之外都答得挺好的呀，可能有些题目考虑的不是很全面吧。现在想想觉得自己还是挺幸运的。当天就收到一面的短信，一面面试官给我留下的印象十分深刻，无论是开口的第一句话：“我们不用搞得那么严肃，轻松点就行(哈哈)”，还是面试过程中对我回答的不好的问题耐心的纠正，到最后离开的时候站起来跟我握手。整体给面试者的印象都十分深刻，相信有面过珍爱网Android的同学都会倍感亲切和轻松吧！ 珍爱网一面123456789101112131415161718介绍一下做过的项目，面试官问我手机上有没有安装做过的APP，自己的APP当然得装在手机上啦，于是面试过程基本都是围绕着这个项目展开的。介绍一下RecyclerView的原理以及优点。为什么会选用Material Design？Android 5.0之后的版本和之前的版本有什么区别？DVM与ART的区别？(回答得不好)为什么要写博客？怎么学习Android的？项目中遇到过哪些困难？如何去解决的？MVP与MVC有什么区别？Custom-Tabs-Client是什么？(因为在项目中用到这个开源库)作用是什么？Handler机制？Looper原理？如果在主线程中同时创建10个Handler，会发生什么事？(回答得不好)HandlerThread实现原理？Activity的启动流程？ActivityThread的main方法主要做了哪些操作？对团队有什么要求吗？有哪些问题要问他的？(去面试之前使用了珍爱网的APP，发现有一个页面有点卡顿，然后使用AS的dump View Hierarchy for UI automator观察了这个Activity的实现组件是webview，但不是传统的webview，而是基于腾讯的X5内核，同时注意到这个页面需要连接网络，如果没有网络连接的话就无法显示内容，后来通过使用分析知道这个页面的卡顿有一部分原因是网络连接造成的。基于这个问题与面试官进行了一番讨论。)还有什么问题要问他的吗？(请教了一下面试官在珍爱网工作最大的收获是什么) 面试结束之后面试官主动站起来跟我握手，我都有点受宠若惊了。分析了一下这次面试，觉得自己的技术问题上大部分答得都还行，不过有两个问题基本属于知识盲区，所以回答的不好。能过一面我觉得除了运气好之外，可能是我问的两个问题也加了不少分，第一个问题主要是我有去使用他们的产品，并且对其中的问题有自己的思考和深入的了解，这可能是面试官更加看中的吧；第二个问题能够体现出我很想去珍爱网的热情。 珍爱网二面二面应该是总监面或者总裁面吧，面试官懂技术，会问一些技术问题，估计是CTO之类的高管。主要的问题记录如下：123456789101112131415介绍一下项目，面试官同样也拿着我的手机看项目。项目中有没有做一下性能的优化？优化工具有哪些？了解过哪些设计模式？分别详细说一下优缺点？什么情况下使用单例模式？java中的加锁有哪些方法？说一下网络连接的状态码的含义？说一下长连接的优点和缺点？如何看待Android未来的发展？为什么会选择学习Android？如何学习Android？自己有什么优势？为什么写博客？项目中遇到过哪些困难？如何去解决的？遇到过最大的坎是什么？有什么问题要问他的？(面试前看了一下珍爱网的官网，注意到对应届生有一个培养计划————纯珍计划，于是就向面试官提问) 二面感觉发挥还可以，个人还是觉得问的问题还是比较重要的，要让面试官觉得你是一个有心的人，觉得你很想来公司工作，所以从官网了解公司是最直接的啦！二面紧接着就是HR面了，HR小姐姐很有趣，这一轮问的问题就是对一些基本问题的了解了，如实回答即可。过几天之后就收到offer通知了。 最真诚的面试————租租车这里说的最真诚当然不是说我自己啦，我对待每次面试都是十分真诚的啦，这里的真诚就是指租租车的面试官们，因为公司已经经过了B+融资，今年应该是首次校招，不过从规模上来看招聘会办的十分好，招的人数也不少。一面的面试官挺负责任的，在面试之前先浏览了我的博客，以下是面试的一些问题。 租租车一面123456789101112131415161718192021222324252627自我介绍介绍一下项目说一下Retrofit原理说一下java中4种元注解？说一下@Retention元注解的三个取值的使用范围和场景分别是什么？说一下Volley的原理说一下Retrofit与Volley的区别和使用场景说一下Android中的多线程通信机制说一下Android中的Binder机制原理自定义View的流程MeasureSpec是什么？View事件的分发机制Android如何实现图片的高效加载java中的四种引用以及使用场景项目中有做过性能优化吗？如何优化的?JVM的内存模型？java有什么垃圾回收算法？分别是怎么实现的？java多线程的三个特性？原理分别是什么？java多线程的锁机制有什么实现方式？原理分别是什么？说说java中的集合类？写一下单例模式？为什么静态内部类不会造成内存泄漏？说一下TCP与UDP的区别？说一下网络连接的三次握手和四次挥手？为什么写博客？写博客给你带来什么成长？有什么问题想问我的吗？(面试前使用了公司的APP，发现有一个页面出现了bug，然后就基于这个问题与面试官展开了讨论。) 租租车二面租租车的二面是HR面，问的问题基本和其他的HR面相同，下面就列举一些还记得的12345678910家是哪里的啊？父母对未来的工作有什么要求啊？有什么优缺点吗？为什么想要写博客呢？觉得自己性格怎么样？对未来的团队有什么要求吗？拿到哪些Offer了吗？对薪资方面有什么要求吗？对自己未来几年的打算是什么？学校什么时候发三方啊？还有什么问题要问我吗？ 租租车的工作环境是我比较喜欢的，地点在天河大厦，办公楼虽然只是一栋三四层的写字楼但都是自己的，而且装修十分讲究，从门外往里看就能明显感受到与其他公司的差别。两次面试加上一开始的笔试体验都挺不错的，去刚刚起步的初创公司确实能够学到很多当然对自己也是一种历练，更让我喜欢的一点则是公司员工大部分都是年轻人，跟他们工作会相对的轻松些。当然最后还是很开心能够顺利拿到租租车的offer啦！ Android秋招如何准备？其实每个人都有自己特有的学习方法，我们都需要寻找到最适合自己的，在这里我只是列举出我复习的技巧，大家只需要选择适合自己的就行。 书籍和网站我觉得看书真的是十分的重要，每一本书都有自己的知识体系，但是好书确实不多，需要经历一番挑选；关于网站则是对一些体系较小的知识进行汇总，这里推荐的是设计模式。以下我列举一些个人觉得不错的一些书籍和网站： Android 相关 《Android开发艺术探索》 《深入理解Android虚拟机》 《Android源码设计模式解析与实战》 Java相关 《Java编程思想》 《深入理解Java虚拟机》 《图解Java多线程设计模式》 网络相关 《计算机网络》(谢希仁 编著) 《网络是怎么连接的》 数据结构与算法相关 《算法导论》 《算法》(第4版) 设计模式相关 图说设计模式 设计模式Java版 练习相关 牛客网在线笔试题(多练练编程题) LeetCode 知识总结看了这么多书籍和网站之后需要对这些知识做一个比较系统的整理，这里推荐使用思维导图工具，不过市面上的这类工具已经足够多了，有的收费有的免(po)费(jie)，大家可以根据自己的使用习惯自行选择，我个人使用的是mindjet，下图则是我总结的Android复习体系图，完整的版本大家可以点击这里下载。 Android面试知识体系 面试技巧123面试前需要对自己总结的知识重新回顾一遍，以便在被问及时能够快速并且全面的回答问题。面试前对该公司稍做了解，可以从官网或者从产品等方面了解，如果有产品的话还可以使用，看看有没有存在一些bug，当面试官要你提问题的时候可以跟他一起讨论。面试完之后做稍做记录，记下自己回答的不好的问题，方便查漏补缺。 关于简历我觉得简历真的十分重要，如果你的学历和能力都不是很有优势的情况下那么简历很可能就决定了你是否有面试的机会了。当然我的简历做得也不是很好，在这里只是与大家一起分享我在准备简历过程中的一些收获，下面一一与大家分享。 为每个公司准备一份简历如果你不是去一些大型招聘会，不知道都有哪些企业过来招人，那么你大可以用一份普遍适用的简历投递出去，但如果你已经明确知道今天要去哪家公司面试了，那最好能够为这个企业准备一份专属的简历。最基本的就是在简历的页眉部分加上这个公司的logo，其次简历的文字主题色与logo相呼应，例如给腾讯的简历大概长这样 人丑不露相 要不要放照片？首先需要声明的是技术岗一般不看颜值，如果你能力棒棒哒同时颜值高高哒，那基本上就稳了，但如果你跟我一样都是屌丝，那得分两种情况讨论咯。首先如果你愿意花钱的话，可以到靠谱点儿的相馆拍张好的证件照，记得跟老板要电子版哦；如果你不愿意花钱的话，那我建议你还是不要放照片吧。 简历最好要彩印其实我在简历上还是很舍得花钱的，今年学校换了打印店，彩印一面需要两块钱，每次打印心里都在流血啊，不过想到要给面试官留下一个好的印象，还是忍下心了。对了打印一定要用比较硬一点的纸，不要像普通A4纸那样软哦，这样手感才好哟！还有最好还是单面彩印，如果你的简历不止一面那就打几张用订书机钉起来！ 推荐一些实用的工具和网站这里并不是推荐大家什么简历模板，讲真我也没用过这些，对于技术岗的同学简历不需要花哨，只要条理清晰版面整洁即可，基本都是可以用我的(word)哥做。这里推荐的是一款获取图片颜色的工具，还记得刚才我说简历的文字主题色最好与logo相呼应，那就得知道logo的RGB属性值了，使用这款GetRGB工具则可以让你轻松获取图片的RGB参数。使用方式见下图哦！ 如何使用GetRGB 另外推荐的则是一个图标库网站——阿里巴巴矢量图标库，在上面几乎可以找到你所需要的图标，并且可以自定义颜色与大小，还是免费的哦！以后妈妈都不用担心我找不到图标了。 图标示例 后记作为一个Android本科渣渣，在秋招中虽然也经历过失利与彷徨，但对最终的结果还是很满意的。这段时间很感谢身边人对我的帮助，感谢我实习的领导给我的意见和帮助，感谢面试过程中遇到的所有面试官以及结识的朋友们，也感谢我的老师同学朋友一直以来对我的帮助，当然也要感谢我爸妈对我的培养，最后的感谢留给自己，感谢自己学习Android一路来的坚持和努力。希望这篇文章对你有用，同时也祝大家能够实现自己的目标找到心仪的工作！","categories":[{"name":"秋招面经","slug":"秋招面经","permalink":"http://www.wensibo.top/categories/秋招面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://www.wensibo.top/tags/面经/"}]},{"title":"Retrofit2.0源码解析","slug":"retrofit","date":"2017-09-05T02:20:20.000Z","updated":"2018-10-21T08:26:20.848Z","comments":true,"path":"2017/09/05/retrofit/","link":"","permalink":"http://www.wensibo.top/2017/09/05/retrofit/","excerpt":"今天是九月的第四天了，学校也正式开学，趁着大学最后一年的这大好时光，抓紧时间赶快学习新知识吧！今天想要与大家一起分享的是Retrofit，由于网上已经有许多讲解Retrofit使用的文章了，本篇文章只会给一个小小的示例，以这个示例作为入口分析其源码，同样也会贴上流程图，以免迷路。话不多说，我们开始吧！！！","text":"今天是九月的第四天了，学校也正式开学，趁着大学最后一年的这大好时光，抓紧时间赶快学习新知识吧！今天想要与大家一起分享的是Retrofit，由于网上已经有许多讲解Retrofit使用的文章了，本篇文章只会给一个小小的示例，以这个示例作为入口分析其源码，同样也会贴上流程图，以免迷路。话不多说，我们开始吧！！！ 关于Retrofit简介Retrofit是近来十分火热的一个网络请求开源库，Android开发者使用的网络请求开源库从最早的HttpClient与HttpURLConnection到2013年Google官方推出的Volley，接着就到了现在很火的OKHttp，最后才到了Retrofit。网络请求开源库的演变也正是移动互联网下用户对网络需求的真实写照。有哪个用户不想使用APP的时候网络加载速度更快，更省流量，更加安全呢？也就是基于用户的这些需求，才有了许多开源库的不断迭代，而Retrofit可以说正是当下最适合开发者使用的网络请求开源库之一。何出此言呢？首先它是由大名鼎鼎的square公司出品的，或许你不知道square公司，但你应该认识Jake Wharton，不过他最近已经到谷歌去了，倘若你连他都不知道，那你应该使用过他开发的这些开源库：OkHttp,picasso,butterknife,RxAndroid等等，可以说Retrofit是由一个十分厉害的公司开发和维护的，所以你大可以放心地在你的项目中使用。 什么场景下适合使用呢？尽管Retrofit十分强大，但是他却不一定适合所有场景，正所谓术业有专攻，我们也不必大材小用，如果是一些频繁但是访问量很小的网络请求，那么Volley就足以对付了，接下来我列举一下Retrofit普遍的使用场景。 服务器后台遵循RESTful API的设计风格。如果你对这种风格不熟悉，建议你看看阮一峰大神的这篇文章，或者向你的后台小伙伴请教一番。 项目中使用了RxJava。如果你的项目中使用了RxJava，那么使用Retrofit绝对会让你的开发效率翻倍。 项目中的网络数据请求量比较大。如果你的应用经常会有数据量比较大的网络请求，那么使用Retrofit也会很有效，因为Retrofit底层的实现是使用OKHttp，而OKHttp就是适用于这种场景的。 如果你符合以上三种情况，当然是选择Retrofit啦！ Retrofit绿 一个简单的栗子说了这么多，我们就通过下面这个栗子来看看他究竟好在哪里？需要说明的是：这个例子是用来获取干货集中营API上面的数据1、首先定义一个常量用来描述要访问的服务器主机的地址123public class GankConfig &#123; public static final String HOST = \"http://gank.io/api/\";&#125; 2、定义返回数据的bean类1234567891011121314151617181920212223public class GankData &#123; public List&lt;String&gt; category; public Result results; public class Result&#123; @SerializedName(\"Android\") public List&lt;Gank&gt; androidList; @SerializedName(\"休息视频\") public List&lt;Gank&gt; restVideoList; @SerializedName(\"iOS\") public List&lt;Gank&gt; iosList; @SerializedName(\"福利\") public List&lt;Gank&gt; meiZiList; @SerializedName(\"拓展资源\") public List&lt;Gank&gt; extendResourceList; @SerializedName(\"瞎推荐\") public List&lt;Gank&gt; suggestionList; @SerializedName(\"App\") public List&lt;Gank&gt; appList; @SerializedName(\"前端\") public List&lt;Gank&gt; webList; &#125;&#125; 3、定义要访问的接口1234567public interface GankRetrofit &#123; //这里以获取指定日期的内容为例子 @GET(\"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;\") GankData getDailyData(@Path(\"year\") int year, @Path(\"month\") int month, @Path(\"day\") int day);&#125; 4、用单例模式创建一个Retrofit客户端1234567891011121314151617181920212223242526public class GankRetrofitClient &#123; private volatile static GankRetrofit gankRetrofit; private static Retrofit retrofit; private GankRetrofitClient()&#123;&#125; static&#123; Gson date_gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").create(); retrofit = new Retrofit.Builder() .baseUrl(GankConfig.HOST) .addConverterFactory(GsonConverterFactory.create(date_gson))//添加一个转换器，将gson数据转换为bean类 .addCallAdapterFactory(RxJava2CallAdapterFactory.create())//添加一个适配器，与RxJava配合使用 .build(); &#125; public static GankRetrofit getGankRetrofitInstance() &#123; if (gankRetrofit==null)&#123; synchronized (GankRetrofitClient.class)&#123; if (gankRetrofit==null)&#123; gankRetrofit=retrofit.create(GankRetrofit.class); &#125; &#125; &#125; return gankRetrofit; &#125;&#125; 5、使用Retrofit进行网络请求1GankData data= GankRetrofitClient.getGankRetrofitInstance().getDailyData(2017, 9, 1); 源码解析从Builder模式创建实例开始看起首先我们先从上面的第4步开始解析源码，有下面这段代码：12345retrofit = new Retrofit.Builder() .baseUrl(GankConfig.HOST) .addConverterFactory(GsonConverterFactory.create(date_gson))//添加一个转换器，将gson数据转换为bean类 .addCallAdapterFactory(RxJava2CallAdapterFactory.create())//添加一个适配器，与RxJava配合使用 .build(); 很明显这个是使用了Builder模式，接下来我们一步一步来看里面做了什么？首先是Builder()。123456789public Builder() &#123; this(Platform.get());&#125;Builder(Platform platform) &#123; this.platform = platform; //添加转换器，请见下面关于addConverterFactory()的讲解 converterFactories.add(new BuiltInConverters()); &#125; 构造方法中的参数是Platform的静态方法get()，接下来就看看get()。 123456789101112131415161718192021private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(\"java.util.Optional\"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; 可以看到，Retrofit支持多平台，包括Android与JAVA8，它会根据不同的平台设置不同的线程池。先来看看到目前为止我们分析到哪里了 接下来看一下baseUrl()方法。12345678public Builder baseUrl(String baseUrl) &#123; checkNotNull(baseUrl, \"baseUrl == null\"); HttpUrl httpUrl = HttpUrl.parse(baseUrl); if (httpUrl == null) &#123; throw new IllegalArgumentException(\"Illegal URL: \" + baseUrl); &#125; return baseUrl(httpUrl); &#125; 很容易理解，baseUrl()是配置服务器的地址的，如果为空，那么就会抛出异常。 接着是addConverterFactory()123456private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, \"factory == null\")); return this;&#125; 大家是不是还记得刚才在Builder()方法初始化的时候，有这样一行代码：1converterFactories.add(new BuiltInConverters()); 可以看到，converterFactories在初始化的时候就已经添加了一个默认的Converter，那我们手动添加的这个GsonConverter是干什么用的呢？1234567891011121314151617181920212223242526272829303132public final class GsonConverterFactory extends Converter.Factory &#123; public static GsonConverterFactory create() &#123; return create(new Gson()); &#125; public static GsonConverterFactory create(Gson gson) &#123; return new GsonConverterFactory(gson); &#125; private final Gson gson; private GsonConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException(\"gson == null\"); this.gson = gson; &#125; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter); &#125;&#125; 其实这个Converter主要的作用就是将HTTP返回的数据解析成Java对象，我们常见的网络传输数据有Xml、Gson、protobuf等等，而GsonConverter就是将Gson数据转换为我们的Java对象，而不用我们重新去解析这些Gson数据。 接着看addCallAdapterFactory()123456private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;();public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123; adapterFactories.add(checkNotNull(factory, \"factory == null\")); return this;&#125; 可以看到，CallAdapter同样也被一个List维护，也就是说用户可以添加多个CallAdapter，那Retrofit总得有一个默认的吧，默认的是什么呢？请看接下来的build()。 最后看一下build()1234567891011121314151617181920212223242526public Retrofit build() &#123; //检验baseUrl if (baseUrl == null) &#123; throw new IllegalStateException(\"Base URL required.\"); &#125; //创建一个call，默认情况下使用okhttp作为网络请求器 okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); //添加一个默认的callAdapter adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; 首先Retrofit会新建一个call，其实质就是OKHttp，作用就是网络请求器；接着在上一点中我们困惑的callAdapter也已经能够得到解决了，首先Retrofit有一个默认的callAdapter，请看下面这段代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; return DefaultCallAdapterFactory.INSTANCE; &#125;final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; final Type responseType = Utils.getCallResponseType(returnType); return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; @Override public boolean isExecuted() &#123; return delegate.isExecuted(); &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; @Override public void cancel() &#123; delegate.cancel(); &#125; @Override public boolean isCanceled() &#123; return delegate.isCanceled(); &#125; @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone. @Override public Call&lt;T&gt; clone() &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone()); &#125; @Override public Request request() &#123; return delegate.request(); &#125; &#125;&#125; 可以看到默认的callAdapter是ExecutorCallAdapterFactory。callAdapter其实也是运用了适配器模式，其实质就是网络请求器Call的适配器，而在Retrofit中Call就是指OKHttp，那么CallAdapter就是用来将OKHttp适配给不同的平台的，在Retrofit中提供了四种CallAdapter，分别如下： ExecutorCallAdapterFactory（默认使用） GuavaCallAdapterFactory Java8CallAdapterFactory RxJavaCallAdapterFactory 为什么要提供如此多的适配器呢？首先是易于扩展，例如用户习惯使用什么适配器，只需要添加即可使用；再者RxJava如此火热，因为其切换线程十分的方便，不需要手动使用handler切换线程，而Retrofit使用了支持RxJava的适配器之后，功能也会更加强大。 综上我们已经将使用Builder模式创建出来的Retrofit实例分析完毕了，我们只需要对相关的功能进行配置即可，Retrofit负责接收我们配置的功能然后进行对象的初始化，这个也就是Builder模式屏蔽掉创建对象的复杂过程的好处。现在我们再次用流程图来梳理一下刚才的思路。 网络请求接口的创建我最初使用Retrofit的时候觉得有一个地方十分神奇，如下：12GankRetrofit gankRetrofit=retrofit.create(GankRetrofit.class);GankData data= gankRetrofit.getDailyData(2017, 9, 1); 要想解惑，首先得对动态代理有所了解，如果你对动态代理还不是很清楚，请点击这里了解动态代理的原理，之后再接着往下看。 前方高能预警 我们就以这里为切入点开始分析吧！首先是create() 12345678910111213141516171819202122232425262728293031public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //重点看这里 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //下面就会讲到哦 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); //下一小节讲到哦 OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); //下两个小节讲哦 return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 我们主要看Proxy.newProxyInstance方法，它接收三个参数，第一个是一个类加载器，其实哪个类的加载器都无所谓，这里为了方便就选择了我们所定义的借口的类加载器;第二个参数是我们定义的接口的class对象，第三个则是一个InvocationHandler匿名内部类。那大家应该会有疑问了，这个newProxyInstance到底有什么用呢？其实他就是通过动态代理生成了网络请求接口的代理类，代理类生成之后，接下来我们就可以使用ankRetrofit.getDailyData(2017, 9, 1);这样的语句去调用getDailyData方法，当我们调用这个方法的时候就会被动态代理拦截，直接进入InvocationHandler的invoke方法。下面就来讲讲它。 invoke方法它接收三个参数，第一个是动态代理，第二个是我们要调用的方法，这里就是指getDailyData，第三个是一个参数数组，同样的这里就是指2017, 9, 1，收到方法名和参数之后，紧接着会调用loadServiceMethod方法来生产过一个ServiceMethod对象，这里的一个ServiceMethod对象就对应我们在网络接口里定义的一个方法，相当于做了一层封装。接下来重点来看loadServiceMethod方法。 loadServiceMethod方法12345678910111213ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 它调用了ServiceMethod类，而ServiceMethod也使用了Builder模式，直接先看Builder方法。1234567891011121314Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; //获取接口中的方法名 this.method = method; //获取方法里的注解 this.methodAnnotations = method.getAnnotations(); //获取方法里的参数类型 this.parameterTypes = method.getGenericParameterTypes(); //获取接口方法里的注解内容 this.parameterAnnotationsArray = method.getParameterAnnotations();&#125; 再来看build方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public ServiceMethod build() &#123; callAdapter = createCallAdapter(); responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError(\"'\" + Utils.getRawType(responseType).getName() + \"' is not a valid response body type. Did you mean ResponseBody?\"); &#125; responseConverter = createResponseConverter(); for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError(\"HTTP method annotation is required (e.g., @GET, @POST, etc.).\"); &#125; if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\"); &#125; if (isFormEncoded) &#123; throw methodError(\"FormUrlEncoded can only be specified on HTTP methods with \" + \"request body (e.g., @POST).\"); &#125; &#125; int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, \"Parameter type must not include a type variable or wildcard: %s\", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, \"No Retrofit annotation found.\"); &#125; parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError(\"Missing either @%s URL or @Url parameter.\", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError(\"Non-body HTTP method cannot contain @Body.\"); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError(\"Form-encoded method must contain at least one @Field.\"); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError(\"Multipart method must contain at least one @Part.\"); &#125; return new ServiceMethod&lt;&gt;(this); &#125; 代码稍微有点长，但是思路很清晰，主要的工作有1、首先对注解的合法性进行检验，例如，HTTP的请求方法是GET还是POST，如果不是就会抛出异常；2、根据方法的返回值类型和方法注解从Retrofit对象的的callAdapter列表和Converter列表中分别获取到该方法对应的callAdapter和Converter；3、将传递进来的参数与注解封装在parameterHandlers中，为后面的网络请求做准备。 先用流程图梳理一下刚才的思路： 分析到这里，我们总算是明白了最初的两行代码原来干了这么多事情，J神真的是流弊啊！接下来我们就来看一下网络请求部分。 使用OkHttpCall进行网络请求回头看一下上一小节讲解create方法时我们有这一行代码：1OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); 他将我们刚才得到的serviceMethod与我们实际传入的参数传递给了OkHttpCall，接下来就来瞧瞧这个类做了些什么？12345678910111213141516final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final Object[] args; private volatile boolean canceled; // All guarded by this. private okhttp3.Call rawCall; private Throwable creationFailure; // Either a RuntimeException or IOException. private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125;&#125; 很可惜，我们好像没有看到比较有用的东西，只是将传进来的参数进行了赋值，那我们就接着看create方法中的最后一行吧！ callAdapter的使用create方法的最后一行是这样的：1return serviceMethod.callAdapter.adapt(okHttpCall); 最后是调用了callAdapter的adapt方法，上面我们讲到Retrofit在决定使用什么callAdapter的时候是看我们在接口中定义的方法的返回值的，而在我们的例子中使用的是RxJava2CallAdapter，因此我们就直接看该类中的adapt方法吧！123456789101112131415161718192021222324252627282930313233@Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable; &#125; 首先在adapt方法中会先判断是同步请求还是异步请求，这里我们以同步请求为例，直接看CallExecuteObservable。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final class CallExecuteObservable&lt;T&gt; extends Observable&lt;Response&lt;T&gt;&gt; &#123; private final Call&lt;T&gt; originalCall; CallExecuteObservable(Call&lt;T&gt; originalCall) &#123; this.originalCall = originalCall; &#125; @Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123; // Since Call is a one-shot type, clone it for each new observer. Call&lt;T&gt; call = originalCall.clone(); observer.onSubscribe(new CallDisposable(call)); boolean terminated = false; try &#123; //重点看这里 Response&lt;T&gt; response = call.execute(); if (!call.isCanceled()) &#123; observer.onNext(response); &#125; if (!call.isCanceled()) &#123; terminated = true; observer.onComplete(); &#125; &#125; catch (Throwable t) &#123; Exceptions.throwIfFatal(t); if (terminated) &#123; RxJavaPlugins.onError(t); &#125; else if (!call.isCanceled()) &#123; try &#123; observer.onError(t); &#125; catch (Throwable inner) &#123; Exceptions.throwIfFatal(inner); RxJavaPlugins.onError(new CompositeException(t, inner)); &#125; &#125; &#125; &#125; private static final class CallDisposable implements Disposable &#123; private final Call&lt;?&gt; call; CallDisposable(Call&lt;?&gt; call) &#123; this.call = call; &#125; @Override public void dispose() &#123; call.cancel(); &#125; @Override public boolean isDisposed() &#123; return call.isCanceled(); &#125; &#125;&#125; 在subscribeActual方法中去调用了OKHttpCall的execute方法开始进行网络请求，网络请求完毕之后，会通过RxJava的操作符对返回来的数据进行转换，并进行线程的切换，至此，Retrofit的一次使用也就结束了。最后我们再用一张完整的流程图总结上述的几个过程。 后记相信通过上面的详解，大家对Retrofit应该有了一个比较全面的认识，与其说它是一个网络请求框架不如说他做了一层封装，使得我们能够更方便的间接使用了RxJava与OkHttp。从某种意义上来讲我们从源码中更应该学习其对设计模式的正确运用，使得整个框架的耦合度大大降低，调用者也使用得更加简洁。最后希望这篇文章能够对大家的面试有所帮助！","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.wensibo.top/tags/Retrofit/"}]},{"title":"实习总结","slug":"trainee","date":"2017-08-31T02:20:20.000Z","updated":"2018-10-21T08:26:21.020Z","comments":true,"path":"2017/08/31/trainee/","link":"","permalink":"http://www.wensibo.top/2017/08/31/trainee/","excerpt":"距离上篇文章已经过去一个多月了，这段时间之所以没有更新文章不是因为偷懒，而是因为在实习。7月份的时候来到了目前的这家公司实习，当初笔试的时候自己做的不是很好，后来面试时也有些地方变现地也不尽如人意，不过最后还是很感激我老大给我来公司实习的机会。在实习的一个多月时间内自己也学到了很多，今天这篇文章就记录一下我的学习过程。","text":"距离上篇文章已经过去一个多月了，这段时间之所以没有更新文章不是因为偷懒，而是因为在实习。7月份的时候来到了目前的这家公司实习，当初笔试的时候自己做的不是很好，后来面试时也有些地方变现地也不尽如人意，不过最后还是很感激我老大给我来公司实习的机会。在实习的一个多月时间内自己也学到了很多，今天这篇文章就记录一下我的学习过程。 console.error(\"Error: [hexo-tag-aplayer] Unrecognized tag argument(2): autoplay=ture\"); 学校&amp;公司的区别来到公司实习，其实自己已然不是一个学生了，别人也不会当你是学生，所以很多事情上需要自己去跟上团队的节奏。学校里学到的东西不能说没用，但是与实际的公司其实是有许多不匹配的，我们更需要将自己学到的知识运用在实践中，而不是单纯地纸上谈兵；从另外一个角度上来讲这也是为什么企业招员工时很喜欢招那些有一定的项目经验的学生。很幸运的是自己之前有过一定的项目经验，虽然谈不上是多大的项目，但是这些经历足以培养一个人独立完成工作、独立解决问题的能力，这点也恰恰是在课本上很难学到，但是在实践中却又很有必要积累的。上面的道理大家都懂，但是没什么卵用，我举个例子向大家说明一下这个问题。我有一个工作内容是阅读之前的一个eclipse工程，并将这个工程移植到Android Studio平台上大家或许觉得这个工作内容很简单啊，Android Studio本身就很强大，完全可以解决这个问题。实不相瞒，我一开始也是这样想的，但是当我阅读这个旧的工程的时候，我觉得自己回到了”远古时代”，之所以会有这样的感叹，不是因为代码写的不好，而是整个工程缺乏一定的架构思想，导致一个Activity文件动不动就600~700行，有的甚至到了1000行，尽管逻辑不复杂，但是性能肯定是大打折扣的，并且如果工程日后是别人接手，或者日后需要扩展功能，那么将会彻底地违背了开闭原则（对扩展开放，对修改关闭）。也是基于这样的理由，我就打算将整个项目进行重构，而重构使用的方法则是我经常在项目中使用的MVP设计架构，尽管这种架构仍然有他诟病的地方（代码量不少反增，逻辑也会更加的复杂），但是这仍然不失为一个较好的选择。确定了目标，我也就开始干了，也正因为有了之前项目的积累，所以重构起来也才得心应手。 需要慢慢培养的技能和规范技能做程序开发，经验是需要慢慢积累的，而技能也不是一下子就炉火纯青的，需要经历项目的考验才能慢慢成为巨人，在这里我列举一下个人觉得比较重要的开发技能。 文档阅读能力许多大公司都有维护文档的习惯，并且文档的数量和质量也都是顶呱呱的，作为进入团队的新人，对于业务不熟悉的时候，第一时间并不是问老大问同事，而应该自己阅读文档，当然不得不承认的一点就是我一开始是比较笨的，遇到问题就问我老大问我同事，到了后来我才悟到这点，也算是积累吧！ 前面讲的是要有阅读文档的习惯，接下来讲讲要怎么去阅读文档。想必大家或多或少都会看Android官方的文档吧，但是应该不是每个人都看得下的，这里我也承认其实我对官方文档还是有些许排斥的，不仅仅是有的时候都是英文，增加了阅读的难度，当然对于本科生而言，英语阅读不应该成为开发的阻碍，再者就是尽管将英文翻译成了中文，读起来还是有些许的晦涩拗口（也许是我个人的感受），但是。。。不得不承认的就是官方文档是最权威的，并且它的很多内容是很有帮助的，毕竟文档是由项目的开发者编写的，没有人比开发者还懂项目了吧！另外文档中有的时候还会记录一些开发者遇到的坑，作为项目的接手者，如何避免跳入这些坑，看这些文档就对了。我个人的建议就是： 要静下心来阅读，并且适当的做一下阅读的笔记，将冗杂的内容提炼出真正对自己有用的东西，这里推荐一个Chrome的插件——简悦，他能让你沉浸在阅读之中，排除掉页面其他无关元素的干扰 简悦图示 再者就是不要妄想一下子就读完整个文档，毕竟这是很多开发者花了许久才编写完成的，我们要做的就是阅读与你相关的内容，或者你感兴趣的内容，这样的效率才会比较高一点。 独立解决问题的能力文章开头讲到我们在课本上学到的知识很多时候并不会派上用场，但是当真正需要的时候我们却早已遗忘，如果你在开发的过程中遇到了一些困难，首先并不应该也不推荐直接向自己的同事询问解决方式，毕竟别人也有工作要做，这里我非常感谢我的同事和老大，因为刚进公司时初出茅庐，很多事情都不是很懂，向他们请教了好多好多，但是大家都十分的nice，很耐心的为我解答，他们帮助我很快的熟悉了业务，非常感谢他们。话说回来如何独立的解决问题呢？以下列举一些我积累的方法，不过大家平常都有用到的啦！ 善于利用搜索引擎尤其是Google。搜索引擎装的东西肯定是要比人脑多的，并且互联网为全世界的网民提供了知识分享的平台，你遇到的这个问题或许别人也遇到过，并且已经有了解决方案。 利用好Stack Overflow 。这是一个编程问题问答平台，很多人遇到问题之后都会来这里提问，如果你对某些问题有了解决方法，那么就慷慨的给出你的答案吧！ 仔细分析代码。如果上述两个方法都不能解决你的问题，那接下来就得靠你自己了，有可能是你写的代码存在某些问题，这个需要你耐心地去排查，如果问题解决了，那么你应该在你的文档或者笔记中记录下这个问题，为团队提供解决方案，而对自己而言也是一种积累。 规范规范在企业中十分地重要，体现在软件开发中就是指代码的编写规范、工具的使用规范、版本控制工具的使用规范、文档的编写规范等等。这里讲讲代码的规范和版本控制工具的使用规范。其实两者的关系十分的密切，因为很多时候代码是需要提交到版本控制系统上的，在这里我就指公司使用的比较多的SVN了。举一个例子，也是我老大跟我们强调的一点，在开发过程中代码的每行的缩距虽然并不是特别的重要，很多时候每个人都有每个人不同的缩距方式，但是这在团队协同工作的时候就会存在问题，例如我将Android Studio的默认行缩距进行了调整，将代码提交到了SVN，接下来我的另外一个同事查看我的代码时，发现缩距有点奇怪，于是为了阅读的方便，他将缩距调整为自己能够接受的程度，当阅读完代码之后，SVN提示我的同事已经将代码修改了，但是实际上他并没有对代码做一些实质性的修改，只是做了缩距的修改，但这仍然被SVN识别成一次成功的提交，所以这就是问题所在了。解决问题的方法就是团队约定一个准则，使用IDE的默认缩距设置，这样就不会存在这种问题啦！ 接触和学习新知识正所谓术业有专攻，每个人都有自己擅长的方面，但是知识是不断更新的，并且也很少人能够做到对整个知识体系的每一块都了然于胸，所以如果到了新的团队，接手新的业务，而开发内容是你不熟悉的，那也没有必要慌张，这个时候你得尽快的熟悉这方面的知识，通过许多的手段去让自己融入团队，这个才是新手的最佳技能。 尾声以上就是这段实习经历中我学到的一些经验，写出来与大家一起分享，也当做是这段实习经历的总结，对以后的工作或许会有帮助。希望大家会喜欢！","categories":[{"name":"工作","slug":"工作","permalink":"http://www.wensibo.top/categories/工作/"}],"tags":[{"name":"工作","slug":"工作","permalink":"http://www.wensibo.top/tags/工作/"}]},{"title":"从源码的角度看Service是如何启动的","slug":"service","date":"2017-07-16T06:25:25.000Z","updated":"2018-10-21T08:26:20.884Z","comments":true,"path":"2017/07/16/service/","link":"","permalink":"http://www.wensibo.top/2017/07/16/service/","excerpt":"七月中旬了，大家的实习有着落了吗？秋招又准备的怎么样了呢？我依旧在准备着秋招，每当想到自己以应届生的身份找着工作而工作却不一定要你的时候，难免也会有点失落。互联网行业的大佬们求贤若渴但对贤才也十分的苛刻，看到内推正如火如荼的进行着，深怕自己被这场浪潮甩在身后，所以也不得不苦心的准备着。如果你也是2018届应届生，如果你也看到了这篇文章，请你在留言区留下你找工作，准备秋招的感受，我们一起交流交流。今天接着上篇文章一起来看看四大组件的老二——Service。话不多说我们开始吧！","text":"七月中旬了，大家的实习有着落了吗？秋招又准备的怎么样了呢？我依旧在准备着秋招，每当想到自己以应届生的身份找着工作而工作却不一定要你的时候，难免也会有点失落。互联网行业的大佬们求贤若渴但对贤才也十分的苛刻，看到内推正如火如荼的进行着，深怕自己被这场浪潮甩在身后，所以也不得不苦心的准备着。如果你也是2018届应届生，如果你也看到了这篇文章，请你在留言区留下你找工作，准备秋招的感受，我们一起交流交流。今天接着上篇文章一起来看看四大组件的老二——Service。话不多说我们开始吧！ 前言我们一般使用Service有两种方式，startService和bindService，这两种方法使用场景各有不同，本篇文章以startService为例讲解Service的启动过程，而bindService大体上与startService相近，只是一些逻辑调用上有所区别。在这里我先贴上通过本次分析得到的Service完整的启动流程图，现在不需要理解其中的过程，只需要一步步分析源码的时候回过头来看看这幅图，以免迷失方向。当然我在每一步都会贴出相对应的流程图。 总体流程图 认识ContextImpl首先先给出一张类图，我们从大局上看一下这些类的关系。 类图 从上面这张图我们可以看到Activity继承了ContextWrapper类，而在ContextWrapper类中，实现了startService方法。在ContextWrapper类中，有一个成员变量mBase，它是一个ContextImpl实例，而ContextImpl类和ContextWrapper类一样继承于Context类。为什么会给出这张图呢？这对我们接下来的分析十分有用。 启动Service的入口我们在Activity中使用startService(Intent service)来启动一个服务，其调用的方法如下：12345//ContextWrapper类@Overridepublic ComponentName startService(Intent service) &#123; return mBase.startService(service);&#125; 可以看到其调用了ContextWrapper的startService方法，而这个方法内部使用mBase的startService方法，我们再看回刚才的类图，可以看到，这里的mBase其实就是ContextImpl，从而我们可以得出ContextWrapper类的startService方法最终是通过调用ContextImpl类的startService方法来实现的。那接下来就来看看ContextImpl.startService()。1234567891011121314151617181920212223242526272829@Overridepublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, mUser);&#125;private ComponentName startServiceCommon(Intent service, UserHandle user) &#123; try &#123; validateServiceIntent(service); service.prepareToLeaveProcess(this); ComponentName cn = ActivityManagerNative.getDefault().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded( getContentResolver()), getOpPackageName(), user.getIdentifier()); if (cn != null) &#123; if (cn.getPackageName().equals(\"!\")) &#123; throw new SecurityException( \"Not allowed to start service \" + service + \" without permission \" + cn.getClassName()); &#125; else if (cn.getPackageName().equals(\"!!\")) &#123; throw new SecurityException( \"Unable to start service \" + service + \": \" + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; 我们可以看到startService方法其实是调用了startServiceCommon，而startServiceCommon做了些什么呢？我们看到了一个熟悉的家伙：ActivityManagerNative.getDefault()，在上篇文章分析Activity启动的时候我们也看过他，并且我们也知道ActivityManagerNative.getDefault()返回的就是一个ActivityManagerProxy对象，这里使用Binder机制（如果你对Binder机制不是很了解，那可以看一下我之前写的这篇文章）将代理Proxy返回给客户端，而客户端通过将参数写入Proxy类，接着Proxy就会通过Binder去远程调用服务端的具体方法，因此，我们只是借用ActivityManagerProxy来调用ActivityManagerService的方法。所以这里其实是调用了远程ActivityManagerService的startService方法。到这里我们先用流程图来看一下目前Service启动的情况 流程图1 接下来我们就看看ActivityManagerService是如何实现的。 AMS如何进一步启动Service123456789101112131415//ActivityManagerService类@Overridepublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; //... synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 可以看到这里调用了mService的startServiceLocked方法，那mService是干嘛的呢？此处的mServices是一个ActiveServices对象，从名字上也能看出该类主要是封装了一些处于活动状态的service组件的方法的调用。那接下来就看看他的startServiceLocked是如何实现的。1234567891011121314151617181920212223242526272829303132333435363738394041ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, int userId) &#123; //... final boolean callerFg; if (caller != null) &#123; //mAm 是ActivityManagerService. final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when starting service \" + service); &#125; callerFg = callerApp.setSchedGroup != Process.THREAD_GROUP_BG_NONINTERACTIVE; &#125; else &#123; callerFg = true; &#125; ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPid, callingUid, userId, true, callerFg); if (res == null) &#123; return null; &#125; if (res.record == null) &#123;//权限拒绝. return new ComponentName(\"!\", res.permission != null ? res.permission : \"private to package\"); &#125; ServiceRecord r = res.record; // r.lastActivity = SystemClock.uptimeMillis(); r.startRequested = true; r.delayedStop = false; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), service, neededGrants)); final ServiceMap smap = getServiceMap(r.userId); boolean addToStarting = false; //... return startServiceInnerLocked(smap, service, r, callerFg, addToStarting);&#125; 代码稍微有点长，但是最重要的逻辑在于最后一句的startServiceInnerLocked方法，他的内部实现是这样的。123456789101112ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; //... //真正开启service的地方。 String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); //注意此处反回值是null的时候，证明没有异常. if (error != null) &#123; return new ComponentName(\"!!\", error); &#125; //... return r.name;&#125; startServiceInnerLocked方法内部调用了bringUpServiceLocked方法来进行后续的启动。123456789101112131415private final String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting) throws TransactionTooLargeException &#123; //... if (app != null &amp;&amp; app.thread != null) &#123; try &#123; app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats); realStartServiceLocked(r, app, execInFg); return null; &#125; //... return null;&#125; 在bringUpServiceLocked方法中调用了realStartServiceLocked方法，在Activity的启动过程中我们也曾看过相似的方法，说明到了这里我们也快看到真正的Service启动了，接着来看realStartServiceLocked。123456789101112131415161718192021222324252627private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; //... boolean created = false; try &#123; //... app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; Slog.w(TAG, \"Application dead when creating service \" + r); mAm.appDiedLocked(app); throw e; &#125; //这里会调用Service的onStartCommand sendServiceArgsLocked(r, execInFg, true); //...&#125; 我们先用流程图看看Service启动的逻辑。接着在下面会着重讲解上方的realStartServiceLocked方法。 流程图2 realStartServiceLocked这里需要对上面的app.thread做一下特殊的说明。如果你已经了解了Binder的通信机制，那你应该知道一般我们的服务都是由客户端向服务端发出请求，接着服务端向客户端返回结果，这个是单向的通信，但是如果反过来服务端要向客户端发送请求的话，那么同样的，在服务端也应该持有另外一个Proxy，而在客户端也同样需要一个Manager与之对应。在这里app是要运行 Service 的进程对应的ProcessRecord对象，代表一个应用进程，而thread是一个ApplicationThreadProxy对象，它运行在AMS(现在AMS就是客户端了)，而与之对应的服务端则是在应用程序中的ApplicatonThread，还是有点绕，我们用一张图来展示他们的关系。 两对Binder 相信通过上面的图示大家应该能够明白应用程序进程与系统服务进程之间的双向通信了吧！ 还需要再唠叨一下ApplicationThread与ApplicationThreadProxy之间的关系，我们通过这两个类的定义可以更深刻的理解他们的关系 IApplicationThread 1public interface IApplicationThread extends IInterface IApplicationThread其实是一个IBinder类型的接口。并且在这个接口中声明了许多与Activity，Service生命周期相关的方法，那么它的实现类又是谁呢？答案就是ApplicationThreadNative。 ApplicationThreadNative 1public abstract class ApplicationThreadNative extends Binder implements IApplicationThread 可以看到ApplicationThreadNative是一个抽象类，我们不能直接创建其对象，应该使用其子类，而恰好ApplicationThread就是其子类 ApplicationThread 1private class ApplicationThread extends ApplicationThreadNative ApplicationThread就是真正意义上的服务端，它的父类ApplicationThreadNative就是将具体的操作将给它来执行的。 ApplicationThreadProxy 1class ApplicationThreadProxy implements IApplicationThread 说了那么多，在客户端运行的ApplicationThreadProxy在哪里呢？其实如果理解了Binder机制，那么我们应该知道他就是ApplicationThreadNative的内部类，客户端(AMS)就是通过它与service所在的进程进行通信的。因此我们接着要看的当然是ApplicationThread的scheduleCreateService了。 ApplicationThread.scheduleCreateService12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); &#125; 可以看到在scheduleCreateService方法中发送了一个message，其消息类型为CREATE_SERVICE，它是在H类中定义的一个常量，而H类其实就是继承于Handler的，它专门用来处理发送过来的请求。接下来就来看看它是如何处理创建service这个消息的。 H.handleMessage123456789101112131415public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case CREATE_SERVICE: handleCreateService((CreateServiceData)msg.obj); //【见流程15】 break; case BIND_SERVICE: handleBindService((BindServiceData)msg.obj); break; case UNBIND_SERVICE: handleUnbindService((BindServiceData)msg.obj); break; ... &#125;&#125; 可以看到handleMessage处理了很多类型的消息，包括service的创建、绑定、解绑、销毁等等，我们直接看创建的逻辑，也就是handleCreateService方法。不过有一个问题，那就是Handler创建之前必须要创建Looper，否则会报错，那么Looper是在哪里创建的呢？答案就是ActivityThread的main方法。1234567891011121314151617public static void main(String[] args) &#123; //... //在主线程创建Looper Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 我们可以看到Looper就是在这里创建的，而Handler也是在Service进程中的主线程，也就是说它处理消息也是在主线程，那么Service的创建自然也就是在主线程中。可是ActivityThread是什么鬼呢？其实刚才的ApplicationThread就是它的内部类。接下来继续看Handler如何处理消息。 123456789101112131415161718192021222324252627private void handleCreateService(CreateServiceData data) &#123; unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck(data.info.applicationInfo, data.compatInfo); java.lang.ClassLoader cl = packageInfo.getClassLoader(); //通过反射创建目标服务对象 Service service = (Service) cl.loadClass(data.info.name).newInstance(); ... try &#123; //创建ContextImpl对象 ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); //创建Application对象 Application app = packageInfo.makeApplication(false, mInstrumentation); service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); //调用服务onCreate()方法 service.onCreate(); mServices.put(data.token, service); //调用服务创建完成 ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (Exception e) &#123; ... &#125;&#125; 在这里Handler通过反射机制拿到Service对象，于是就调用了service的onCreate方法，所以Service就算是启动了。我们通过层层的寻找总算是见到了onCreate的庐山真面目。我们依旧用流程图来展示一下Service启动的全过程。 流程图3 onStartCommand可是还有另外一个重要的方法onStartCommand呢？不急，我们刚才在sendServiceArgsLocked方法中还有另外一个sendServiceArgsLocked方法没有讲到，他就是onStartCommand的入口，我们看看他是如何实现的。12345678910111213141516171819202122private final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) &#123; final int N = r.pendingStarts.size(); if (N == 0) &#123; return; &#125; while (r.pendingStarts.size() &gt; 0) &#123; try &#123; //与调用scheduleCreateService方法一样，远程调用ApplicationThread的scheduleServiceArgs方法 r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent); &#125; catch (RemoteException e) &#123; // Remote process gone... we'll let the normal cleanup take // care of this. if (DEBUG_SERVICE) Slog.v(TAG, \"Crashed while scheduling start: \" + r); break; &#125; catch (Exception e) &#123; Slog.w(TAG, \"Unexpected exception\", e); break; &#125; &#125; &#125; 我们看到这里依旧调用了远程服务端ApplicationThread的方法来执行后面的逻辑，其实通过上面分析onCreate的逻辑大家应该能够知道调用onStartCommand也是大同小异的，具体的调用逻辑就交给大家去分析啦！ 后记到这里呢，我们就把Service的启动流程完整的讲解了一遍，希望大家通过这篇文章能够对Service更加的了解，毕竟四大组件中Service的地位还是举足轻重的，并且在面试中也会经常被问到，希望大家逢问必会O(∩_∩)O哈哈~","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://www.wensibo.top/tags/Android源码解析/"},{"name":"Service","slug":"Service","permalink":"http://www.wensibo.top/tags/Service/"}]},{"title":"从源码的角度看Activity是如何启动的","slug":"Activity","date":"2017-07-05T05:24:25.000Z","updated":"2018-10-21T08:26:20.520Z","comments":true,"path":"2017/07/05/Activity/","link":"","permalink":"http://www.wensibo.top/2017/07/05/Activity/","excerpt":"大家好，今天想与大家一起分享的是Activity。我们平时接触的最多的就是Activity了，作为四大组件中最为重要的老大，Activity究竟是如何启动的呢？这篇文章将会从源码的角度为大家进行全方位的解析，为了方便大家理解整个的过程，我会用流程图的方式将整个过程串起来，希望对大家有所帮助。","text":"大家好，今天想与大家一起分享的是Activity。我们平时接触的最多的就是Activity了，作为四大组件中最为重要的老大，Activity究竟是如何启动的呢？这篇文章将会从源码的角度为大家进行全方位的解析，为了方便大家理解整个的过程，我会用流程图的方式将整个过程串起来，希望对大家有所帮助。 开始吧！一般我们启动Activity有两种方法，这里我就不再详细说这两种方法的用法了，不过他们都是调用了同样的一个逻辑startActivity。所以我们分析Activity的启动流程就从这个方法开始。1234567 public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; startActivityForResult(intent, -1); &#125;&#125; 可以看到尽管startActivity()有多种重载方式，但是最终调用的还是startActivityForResult，所以我们只需要看startActivityForResult里面的实现逻辑即可。这里需要注意的一点就是调用了startActivityForResult方法时传入的一个参数为-1，为什么是-1呢？还记得我们如果需要下一个Activity返回数据给目前这个Activity的时候都是调用startActivityForResult方法，不会去调用startActivity，因为startActivity尽管最后还是调用startActivityForResult，但是他设置了requestCode参数为-1，二在startActivityForResult方法中会判断requestCode是否大于等于0，如果小于0就不会返回结果，因此我们都会选择startActivityForResult方法以取回结果，并且设置其code参数大于等于0。下面我们来看看startActivityForResult的实现：12345678910111213141516171819202122232425262728public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) &#123; //mParent是一个Activity对象，表示该Activity是否由父Activity启动 if (mParent == null) &#123; options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; //这里就是判断requestCode的逻辑 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125;&#125; 在startActivityForResult方法中，首先会判断该Activity是否由父Activity启动，即mParent，如果他是第一个Activity，就会调用Instrumentation的execStartActivity方法，这里再看一下判断requestCode的逻辑：123if (requestCode &gt;= 0) &#123; mStartedActivity = true;&#125; 可以看到在这里确实判断了requestCode的大小,大于等于0的时候才会返回结果，否则是不会的。继续说回execStartActivity方法，这里就是正真执行Activity启动的操作，解释一下他的几个参数： this，为启动Activity的对象 mMainThread.getApplicationThread()，为Binder对象，是主进程的context对象 token，也是一个Binder对象，指向了服务端一个ActivityRecord对象 target，为启动的Activity intent，启动的Intent对象 requestCode，请求码 options，参数 这里的第一个Binder对象在我们的整个分析过程中将扮演者非常重要的作用，如果你对Binder不熟悉的话，请到这里了解有关Binder机制的内容。接下来是execStartActivity方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; ... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 这里最重要的就是调用了ActivityManagerNative.getDefault().startActivity()，但是ActivityManagerNative.getDefault()是什么东西呢？我们继续看getDefault()的源码：123456789101112131415161718static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; 可以看到其中声明了一个Singleton封装类，其类型是IActivityManager，注意到其中调用了asInterface方法，接着看他做了什么？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125;//ActivityManagerProxy：startActivitypublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; 可以看到asInterface返回了一个ActivityManagerProxy对象，也就是说ActivityManagerNative.getDefault()返回的就是一个ActivityManagerProxy对象，通过之前的BInder机制的文章我们可以知道Proxy是运行在客户端的，客户端通过将参数写入Proxy类，接着Proxy就会通过Binder去远程调用服务端的具体方法，因此，我们只是借用ActivityManagerProxy来调用ActivityManagerService的方法，他们之间的关系如下所示： 通信方式 到目前为止Activity的启动流程就是如下所示了，可以看到Activity的启动逻辑来到了AMS中。 在AMS中启动Activity123456789101112131415161718192021@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller(\"startActivity\"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, \"startActivity\", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; 在startActivity中直接调用了startActivityAsUser方法，而在startActivityAsUser中则是调用mStackSupervisor.startActivityMayWait方法：1234567891011121314151617final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; ... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); ... return err; &#125; 这个方法中主要构造了ActivityManagerService端的Activity对象:ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法，而在startActivityUncheckedLocked中则调用了startActivityUncheckedLocked方法，startActivityUncheckedLocked方法则会调用startActivityLocked方法，startActivityLocked又会调用resumeTopActivitiesLocked方法，其最后调用了resumeTopActivityLocked方法。经过一系列的调用之后，最终来到了startPausingLocked方法，它会执行Activity的onPause方法，从而结束当前的Activity。首先来看startPausingLocked方法：12345678910111213141516171819202122232425final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming,boolean dontWait) &#123; ... if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, \"Enqueueing pending pause: \" + prev); try &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125; catch (Exception e) &#123; // Ignore exception, if process died other code will cleanup. Slog.w(TAG, \"Exception thrown during pause\", e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; ...&#125; 这里有一个很重要的地方就是prev.app.thread，其实他就是一个IApplicationThread类型的对象，而ApplicationThread则是ActivityThread的一个内部类，它继承了IApplicationThread，并且都是Binder对象，所以说Appcation是一个客户端,而ActivityThread中是一个服务端，到现在为止，Activity的调用来到了ActivityThread中，如下图所示： 在ActivityThread中pause掉当前Activity在ActivityThread中则是调用了schedulePauseActivity来执行pause操作：1234567public final void schedulePauseActivity(IBinder token, boolean finished,boolean userLeaving, int configChanges, boolean dontReport) &#123; sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges);&#125; 可以看到在schedulePauseActivity中则是通过handler来发送消息，消息类型为PAUSE_ACTIVITY_FINISHING，那接下来就应该看收到消息之后如何来处理了，123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; //Slog.v(TAG, \"userLeaving=\" + userLeaving + \" handling pause of \" + r); if (userLeaving) &#123; performUserLeavingActivity(r); &#125; r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; // Tell the activity manager we have paused. if (!dontReport) &#123; try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; &#125; &#125; mSomeActivitiesChanged = true; &#125;&#125; 可以看到在方法内部通过调用performPauseActivity方法来实现对当前Activity的onPause生命周期方法的回调，具体是调用了performPause方法：1234567891011121314final void performPause() &#123; mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); &#125; mResumed = false;&#125; 可以看到最终是调用了Activity的onPause()方法，接着我们回到handlePauseActivity的第二个方法ActivityManagerNative.getDefault().activityPaused(token)，这是应用进程告诉服务进程，当前的Activity已经执行完成onPause方法了，其最后会调用completePauseLocked方法：1234567891011121314151617181920private void completePauseLocked(boolean resumeNext) &#123; ... if (resumeNext) &#123; final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) &#123; mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); &#125; else &#123; mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(null); if (top == null || (prev != null &amp;&amp; top != prev)) &#123; // If there are no more activities available to run, // do resume anyway to start something. Also if the top // activity on the stack is not the just paused activity, // we need to go ahead and resume it to ensure we complete // an in-flight app switch. mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); &#125; &#125; &#125;&#125; 可以看到经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，而在该方法中则是调用了startSpecificActivityLocked 来启动新的Activity。来看看目前的流程图： 启动新的Activity在startSpecificActivityLocked方法中，其实现细节则是和调用Activity的pause方法一样，都是通过Handler机制，发送一个启动Activity的消息，接着处理该消息最后启动Activity。其调用的是performLaunchActivity方法：1234567891011121314151617181920212223242526272829303132333435private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; ... activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; ... return activity; &#125; 可以看到最终的Activity对象终于创建出来了，可以看到其过程是使用反射机制创建的，而反射机制在Android系统中的应用也是随处可见。在接下来的过程中还会继续执行Activity的onCreate等一系列的生命周期方法。最后再来看一下整个过程最终的流程图：","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://www.wensibo.top/tags/Android源码解析/"},{"name":"Activity","slug":"Activity","permalink":"http://www.wensibo.top/tags/Activity/"}]},{"title":"从Android源码的角度分析Binder机制","slug":"Binder","date":"2017-07-03T04:01:25.000Z","updated":"2018-10-21T08:26:20.588Z","comments":true,"path":"2017/07/03/Binder/","link":"","permalink":"http://www.wensibo.top/2017/07/03/Binder/","excerpt":"大家好，好久不见，距离上篇文章已经有35天之久了，因为身体不舒服害了一场病，不过现在已经好多了；另外这个月是考试月，当然得花多点时间复习功课了；再者这段时间依旧在看书，同时也在研究Android源码，准备了不少干货想与大家一起分享。7月刚到，该放假的也都差不多放假了，该实习的也已经在实习了，而我。。。还是准备秋招吧！多看书多打码多提升自己的眼界。 Binder","text":"大家好，好久不见，距离上篇文章已经有35天之久了，因为身体不舒服害了一场病，不过现在已经好多了；另外这个月是考试月，当然得花多点时间复习功课了；再者这段时间依旧在看书，同时也在研究Android源码，准备了不少干货想与大家一起分享。7月刚到，该放假的也都差不多放假了，该实习的也已经在实习了，而我。。。还是准备秋招吧！多看书多打码多提升自己的眼界。 Binder 前言今天想要和大家一起分享的是Android中的Binder机制，讲真这绝对是Android中很深奥的一个点，如果能够彻底弄懂它，这对初级程序员来说绝对会是一件具有里程碑意义的事件，当然我也研究了许久，终于琢磨出点所以然，所以就拿出来和大家一起分享分享。另外这篇文章将会通过一个小实例来讲解Binder，大家可以点击这里，也欢迎大家fork和star。话不多说让我们开始吧！ IPC为了弄懂IPC的来龙去脉，我将从以下三个方面为大家来讲解，希望对大家理解IPC会有帮助 什么是IPCIPC是Inter Process Communication的缩写，其意思就是进程间的通信，也就是两个进程之间的通信过程。我们都知道在Android系统中，每个应用都运行在一个进程上，具有自己的DVM实例，而且进程之间是相互隔离的，也就是说各个进程之间的数据是互相独立，互不影响的，而如果一个进程崩溃了，也不会影响到另一个进程。采取这样的设计是有一定道理的，例如这样的前提下将互相不影响的系统功能分拆到不同的进程里面去，有助于提升系统的稳定性，毕竟我们都不想自己的应用进程崩溃会导致整个手机系统的崩溃。进程之间隔离是不错的选择，可是如果进程之间想要互相通信，进行数据交互的时候那该怎么办呢？例如我们在自己的应用中想要访问手机通讯录中的联系人，很显然这是两个不同的进程，如果Android没有提供一种进程之间交流的机制，那么这种功能将无法实现。不过由于Android系统使用的是Linux内核，而在Linux系统中进程之间的交互是有一套机制的，所以Android也借鉴了其中的一些机制，从而形成了Android的IPC机制。上面只是粗略的讲解了IPC是啥，关于它的使用和原理我将一一为大家呈上。 为什么要用IPC上一点中我举了访问手机通讯录的例子。但你可能觉得我不需要用到这种功能，那么我就不用管IPC啦！其实不然，IPC在我们的应用开发过程中随处可见，下面我将举一个例子来说明他的重要性。我们在MainActivity中修改一个静态变量，接着在另一个进程的SecondActivity中去访问该变量，看看能否读取已经修改过的变量。 1、新建一个Student类，并声明一个静态变量 123public class Student &#123; public static String name=\"BOB\";&#125; 2、在MainActivity的onCreate方法中修改name的值，并打印log1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Student.name = \"JACK\"; Log.d(\"MainActivity:Sname=\", Student.name);&#125; 3、将SecondActivity设置为新进程，并在其onCreate方法中访问name12345&lt;!-- 在清单文件中通过android:process属性为SecondActivity指定特定的进程：com.bob.aidltest：second --&gt;&lt;activity android:name=\".SecondActivity\" android:process=\":second\"&gt;&lt;/activity&gt; 12345678public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second_activity); Log.d(\"SecondActivity:Sname=\" , Student.name); &#125;&#125; 4、通过log，可以看到在MainActivity中修改了name的值，但是在SecondActivity中却无法读取修改后的值 Log图 通过以上的实验，大家应该明白了一点：在不同的进程之间访问同一个静态变量是行不通的。其原因是：每一个进程都分配有一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机上访问同一个对象会产生多个副本。例如我们在MainActivity中访问的name的值只会影响当前进程，而对其他进程不会造成影响，所以在SecondActivity中访问name时依旧只能访问自己进程中的副本。 Android中解决IPC的方法上面也讲到，为了解决这些跨进程的问题，Android沿用了一些Linux的进程管理机制，使得进程之间能够进行交互，下面我将列出一些常见的IPC方式，需要指出的是本文主要讲解Binder机制，所以会注重讲解AIDL，其他方式请读者自行查阅相关资料。 名称 特点 使用场景 Bundle 只能传输实现了Serializable或者Parcelable接口或者一些Android支持的特殊对象 适合用于四大组件之间的进程交互 文件 不能做到进程间的即时通信，并且不适合用于高并发的场景 适合用于SharedPreference以及IO操作 ContentProvider 可以访问较多的数据，支持一对多的高并发访问，因为ContentProvider已经自动做好了关于并发的机制 适合用于一对多的数据共享并且需要对数据进行频繁的CRUD操作 Socket 通过网络传输字节流，支持一对多的实时通信，但是实现起来比较复杂 适合用于网络数据共享 Messenger 底层原理是AIDL，只是对其做了封装，但是不能很好的处理高并发的场景，并且传输的数据只能支持Bundle类型 低并发的一对多的即时通信 AIDL 功能强大，使用Binder机制(接下来会讲解),支持一对多的高并发实时通信，但是需要处理好线程同步 一对多并且有远程进程通信的场景 Binder终于来到这篇文章的重头戏了，上面讲到Android解决IPC的方法中有一种是AIDL，它使用的原理就是Binder，只有理解了Binder，我们才算是理解了Android跨进程通信的原理。在这里我会带大家看看Android中有哪一些重要的地方使用到了Binder，接着我们会通过一个实例来了解如何使用Binder，最后我们会分析Binder的源码来理解他的工作流程。 Binder在Android中的运用说起Binder在Android的使用场景，可以说是无处不在，我列出一些最常见的场景： 四大组件的生命周期都是使用Binder机制进行管理的 View的工作原理也使用了Binder WindowManager的工作机制同样使用了Binder 以上三个方面只是最常见的场景，但是却几乎包括了我们开发的整个流程。我们开发的应用都离不开四大组件，而四大组件也正是依靠Binder机制运行的；对于我们最常见的View，他是如何显示的，View又是如何响应我们的动作的，这其中也用到了Binder(关于这些内容我会在后续的文章中为大家分析)。可以说了解Binder对于我们的开发是很有帮助的，那接下来我们就来看看我们该如何使用Binder进行进程间的通信吧！ 如何使用Binder现在我们需要实现这样的功能：客户端与服务端位于不同的进程，客户端需要向服务端添加学生，同时客户端还可以向服务端发起查询学生列表的请求。 1、创建Student.java，Student.aidl，IStudentManager.aidl Student.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.bob.aidltest.aidl;import android.os.Parcel;import android.os.Parcelable;/** * Created by bob on 17-7-3. * 所有需要在Binder传递的数据类型都需要实现Parcelable接口 */public class Student implements Parcelable&#123; public static String name=\"BOB\"; public int s_id; public String s_name; public String s_gender; public Student(Parcel in) &#123; s_id = in.readInt(); s_name = in.readString(); s_gender = in.readString(); &#125; public Student(int s_id, String s_name, String s_gender) &#123; this.s_id = s_id; this.s_name = s_name; this.s_gender = s_gender; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(s_id); dest.writeString(s_name); dest.writeString(s_gender); &#125; public static final Creator&lt;Student&gt; CREATOR = new Creator&lt;Student&gt;() &#123; @Override public Student createFromParcel(Parcel in) &#123; return new Student(in); &#125; @Override public Student[] newArray(int size) &#123; return new Student[size]; &#125; &#125;; @Override public String toString() &#123; return String.format(\"[StudentID: %s , StudentName: %s , StudentGender: %s]\", s_id, s_name, s_gender); &#125;&#125; Student.aidl 1234// Student1.aidlpackage com.bob.aidltest.aidl;parcelable Student; IStudentManager.aidl 123456789// IStudentManager.aidlpackage com.bob.aidltest.aidl;import com.bob.aidltest.aidl.Student;interface IStudentManager &#123; List&lt;Student&gt; getStudentList(); void addStudent(in Student student);&#125; 创建完毕之后手动编译项目(Build--&gt;ReBuild Project)，接着就会在app/build/generated/source/aidl/debug/com/bob/aidltest/aidl/IStudentManager.java中看到自动生成的IStudentManager接口，如下图： IStudentManager 2、分析IStudentManager.java先来看看自动生成的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public interface IStudentManager extends android.os.IInterface&#123; /** 内部类Stub，继承自Binder并且实现了IStudentManager接口，因此他也是一个Binder对象，这个内部类是需要在服务端手动实现的，并且会通过onBind方法返回给客户端 */ public static abstract class Stub extends android.os.Binder implements com.bob.aidltest.aidl.IStudentManager &#123; private static final java.lang.String DESCRIPTOR = \"com.bob.aidltest.aidl.IStudentManager\"; /** 构造方法 */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * 将服务端的Binder对象转换为客户端的所需的AIDL接口类型的对象，客户端拿到这个对象就可以通过这个对象远程访问服务端的方法 */ public static com.bob.aidltest.aidl.IStudentManager asInterface(android.os.IBinder obj) &#123; if ((obj==null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.bob.aidltest.aidl.IStudentManager))) &#123; return ((com.bob.aidltest.aidl.IStudentManager)iin); &#125; return new com.bob.aidltest.aidl.IStudentManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; /** * 运行在服务端进程的Binder线程池中；当客户端进程发起远程请求时，远程请求会要求系统底层执行回调该方法 * @param code 客户端进程请求方法标识符。服务端进程会根据该标识确定所请求的目标方法 * @param data 目标方法的参数，他是客户端进程传进来的，当我们调用addStudent(Student student)方法时，参数就是Student对象 * @param reply 目标方法执行后的结果，将会返回给客户端，例如当我们调用getStudentList，返回的就是一个Student的列表 */ @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getStudentList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.bob.aidltest.aidl.Student&gt; _result = this.getStudentList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addStudent: &#123; data.enforceInterface(DESCRIPTOR); com.bob.aidltest.aidl.Student _arg0; if ((0!=data.readInt())) &#123; _arg0 = com.bob.aidltest.aidl.Student.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addStudent(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; /** * 代理的内部类，他实现了IStudentManager接口，这个代理类就是服务端返回给客户端的AIDL接口对象，客户端可以通过这个代理类访问服务端的方法 */ private static class Proxy implements com.bob.aidltest.aidl.IStudentManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.util.List&lt;com.bob.aidltest.aidl.Student&gt; getStudentList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.bob.aidltest.aidl.Student&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getStudentList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.bob.aidltest.aidl.Student.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addStudent(com.bob.aidltest.aidl.Student student) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((student!=null)) &#123; _data.writeInt(1); student.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addStudent, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getStudentList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_addStudent = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.bob.aidltest.aidl.Student&gt; getStudentList() throws android.os.RemoteException; public void addStudent(com.bob.aidltest.aidl.Student student) throws android.os.RemoteException;&#125; 可能看了上面的注释大家还是一头雾水，那就先看看这个类的结构图吧： IStudentManager结构图 有关这个类的细节我们待会讲，现在只需要知道我们需要在服务端手动实现Proxy类并实现其中的方法。 创建StudentManagerService.java，并为其指定进程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Created by bob on 17-7-3. * 服务端代码 */public class StudentManagerService extends Service &#123; private static final String TAG = \"StudentManagerService\"; //判断Service是否销毁 private AtomicBoolean mIsServiceDestroyed = new AtomicBoolean(false); //适合用于进程间传输的列表类 private CopyOnWriteArrayList&lt;Student&gt; mStudentList = new CopyOnWriteArrayList&lt;Student&gt;(); @Override public void onCreate() &#123; super.onCreate(); //在服务端手动添加两位默认的学生 mStudentList.add(new Student(1, \"BOB\", \"man\")); mStudentList.add(new Student(2, \"MAY\", \"woman\")); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125; @Override public void onDestroy() &#123; mIsServiceDestroyed.set(false); super.onDestroy(); &#125; private Binder mBinder = new IStudentManager.Stub() &#123; @Override public List&lt;Student&gt; getStudentList() throws RemoteException &#123; SystemClock.sleep(5000);//休眠5s模拟耗时操作 return mStudentList; &#125; @Override public void addStudent(Student student) throws RemoteException &#123; mStudentList.add(student); &#125; &#125;; &#125; 在清单文件中指定服务的进程 1234&lt;service android:name=\".StudentManagerService\" android:process=\":remote\"&gt;&lt;/service&gt; 可以看到这个服务类跟普通的服务类相差并不大，唯一的区别在于它创建了一个IStudentManager.Stub的匿名内部类并且实现了其中的方法，在onBind方法中将这个IBinder对象返回给客户端。这里需要说明一下：Binder是实现了IBinder接口的，所以他同时也是一个IBinder对象。 在客户端愉快的绑定Service吧！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity_Client\"; private static final int MESSAGE_QUERY_STUDENTLIST=1; private int student_size = 3; private IStudentManager mRemoteStudentManager; private ServiceConnection mConnection=new ServiceConnection() &#123; //onServiceConnected与onServiceDisconnected都是在主线程中的，所以如果里面如果涉及到服务端的耗时操作那么需要在子线程中进行 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //获取到IStudentManager对象 final IStudentManager studentManager =IStudentManager.Stub.asInterface(service); mRemoteStudentManager = studentManager; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mRemoteStudentManager = null; Log.d(TAG, \"onServiceDisconnected.threadname:\" + Thread.currentThread().getName()); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, StudentManagerService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; unbindService(mConnection); super.onDestroy(); &#125; //将服务端返回的数据显示在界面上 private Handler mHandler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_QUERY_STUDENTLIST: Toast.makeText(MainActivity.this, msg.obj.toString(),Toast.LENGTH_SHORT).show(); default: super.handleMessage(msg); &#125; &#125; &#125;; /** * 在客户端向服务端添加一名学生 * @param view */ public void addStudent(View view) &#123; if (mRemoteStudentManager != null) &#123; try&#123; int student_id = student_size+ 1; Student newStudent; if (student_id % 2 == 0) &#123; newStudent= new Student(student_id, \"新学生\" + student_id, \"man\"); &#125; else &#123; newStudent= new Student(student_id, \"新学生\" + student_id, \"woman\"); &#125; mRemoteStudentManager.addStudent(newStudent); Log.d(TAG, \"添加一位学生：\" + newStudent.toString()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 在客户端向服务端发起查询学生的请求 * @param view */ public void get_student_list(View view) &#123; Toast.makeText(this, \"正在获取学生列表\", Toast.LENGTH_SHORT).show(); //由于服务端的查询操作是耗时操作，所以客户端需要开启子线程进行工作 new Thread(new Runnable() &#123; @Override public void run() &#123; if (mRemoteStudentManager != null) &#123; try&#123; final List&lt;Student&gt; students = mRemoteStudentManager.getStudentList(); student_size = students.size(); Log.d(TAG, \"从服务器成功获取到学生列表:\" + students.toString()); mHandler.obtainMessage(MESSAGE_QUERY_STUDENTLIST, students).sendToTarget(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 可以看到我们在客户端只需要绑定远程的服务端，服务端就会返回一个IBinder对象，接着我们需要调用IStudentManager.Stub.asInterface()方法，将这个IBinder对象转换为我们客户端可用的AIDL接口对象，拿到这个对象之后我们就可以远程调用服务端的方法了。是不是很容易？但是需要注意的一点是为了模拟耗时操作，我们在服务端的getStudentList的方法中使用休眠以模拟耗时操作，所以客户端在调用该方法时不能直接在主线程中调用，而是应该开启一个子线程，在子线程中调用这个耗时的操作。 看看效果首先我们获取学生列表，接着连续添加4个学生，再次查看学生列表，最终的结果如下图，可以看到我们已经实现了两个进程之间的交互，接下来我们将分析Binder的原理。 结果图 Binder的原理进程的机制首先我们需要了解进程之间为什么不能直接进行通信，以下是两个进程的示意图： 进程间通信示意图 从上面的图我们可以得到以下几点： 一个进程空间分为：用户态和内核态，即把进程内用户和内核隔离开来 进程之间，由于Android系统为每个进程分配了一个独立的虚拟机，用户空间和内核空间的数据不可交互 Binder作为进程间的介质，充当了中介，使得进程间的内核态可以通过Binder进行数据交互 IPC交互示意图 IPC交互示意图 图中总共有四个元素，分别是充当客户端的Activity，服务端的StudentManagerService，充当服务管理者的IStudentManager以及充当访问介质的Binder驱动。他们的职责如下： StudentManagerService: 服务提供者，这里面会有许多我们常用的服务，在本例中提供的服务就是添加学生以及获取学生列表。而在系统中则包括有ActivityService 、 WindowMananger等服务，这些系统服务提供的功能，对四大组件以及Window的工作提供的保障。 Activity: 服务调用者，一般就是我们的应用，在这里我们通过调用StudentManagerService的服务来完成工作。 IStudentManager: 他是负责管理服务的，在其内部通过map集合来存储Service与Binder的映射关系，这样客户端在向其请求服务的时候就能够返回特定的Binder。 Binder驱动: 他是IStudentManager连接各种Service的桥梁，同时也是客户端与服务端交流的桥梁。 总结起来说，应用程序(Activity)首先向IStudentManager发送请求StudentManagerService的服务，IStudentManager查看已经注册在里面的服务的列表，找到相应的服务后，通过Binder驱动将其中的Binder对象返回给客户端，从而完成对服务的请求。 源码分析我们主要分析的就是IStudentManager这个类，从上面得到讲解我们已经知道它包含了两个类：Stub和Proxy。先来看看Proxy类1234567891011121314151617181920212223242526272829303132333435363738394041//Proxy.javapublic java.util.List&lt;com.bob.aidltest.aidl.Student&gt; getStudentList() throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.bob.aidltest.aidl.Student&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getStudentList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.bob.aidltest.aidl.Student.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125;public void addStudent(com.bob.aidltest.aidl.Student student) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((student!=null)) &#123; _data.writeInt(1); student.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addStudent, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125;&#125; 上面截取了Proxy的两个方法，其中Proxy是运行在客户端的，他是用服务端返回来的Binder对象调用了public static IStudentManager asInterface(IBinder obj)方法返回来的。既然Proxy运行在客户端，那么客户端也是通过Proxy来调用远程服务端的方法的，也就是说我们将调用方法需要用到的参数传递给Proxy，接着由Proxy来访问服务端，所以我们能够看到，Proxy将我们的参数写进了_data，而_reply则代表从服务端返回来的结果。从代码中我们还看到客户端在将数据传递给服务端之后就处于阻塞状态，直到服务端返回结果，所以如果调用的服务端方法是一个耗时方法，那么我们就需要在子线程中进行工作了。数据准备好之后当然是需要传递了，可以看到Proxy通过transact方法讲数据传递出去了，接下来就来看transact方法： 123456789101112131415//Binder#transactpublic final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; if (false) Log.v(\"Binder\", \"Transact: \" + code + \" to \" + this); if (data != null) &#123; data.setDataPosition(0); &#125; //调用了Binder的onTransact boolean r = onTransact(code, data, reply, flags); if (reply != null) &#123; reply.setDataPosition(0); &#125; return r; &#125; 可以看到transact方法实际上调用了Binder的onTransact，而这里的Binder就是指Stub了，我们看一下Stub的定义：1public static abstract class Stub extends android.os.Binder implements com.bob.aidltest.aidl.IStudentManager 可以看到Stub确实继承了Binder并且也实现了IStudentManager接口，接下来我们继续看Stub中的onTransact方法：12345678910111213141516171819202122232425262728293031323334public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getStudentList: &#123; data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.bob.aidltest.aidl.Student&gt; _result = this.getStudentList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addStudent: &#123; data.enforceInterface(DESCRIPTOR); com.bob.aidltest.aidl.Student _arg0; if ((0!=data.readInt())) &#123; _arg0 = com.bob.aidltest.aidl.Student.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addStudent(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; 可以看到，服务端通过客户端传递过来的code常量来判断客户端需要调用的是哪个方法，接着就执行该方法，执行完之后如果有数据返回则将结果写入reply，接着Proxy就可以收到结果了。而整个通信过程也就结束了。最后我借用Carson_Ho的一张流程图来描述这个完整的流程： Binder机制流程图 后记Binder机制在Android中的作用举足轻重，本文只是通过Java代码分析其工作流程，由于博主不擅长C/C++，所以无法研究native，不过本文依旧完整的阐述了Binder的整个运行机制，希望通过本文大家能够对Binder机制有更深刻的理解，关于Binder在Android系统中的更多运用我会在后续的文章中为大家奉上，希望大家多多支持。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Android源码解析","slug":"Android源码解析","permalink":"http://www.wensibo.top/tags/Android源码解析/"},{"name":"Binder机制","slug":"Binder机制","permalink":"http://www.wensibo.top/tags/Binder机制/"},{"name":"IPC","slug":"IPC","permalink":"http://www.wensibo.top/tags/IPC/"}]},{"title":"What kind of PPT makes you an excellent speaker——什么样的PPT能助你成为一个优秀的演讲者","slug":"speaker","date":"2017-05-28T08:07:25.000Z","updated":"2018-10-21T08:26:20.996Z","comments":true,"path":"2017/05/28/speaker/","link":"","permalink":"http://www.wensibo.top/2017/05/28/speaker/","excerpt":"今天是端午节假期的第一天，在这里祝大家假期快乐，不过像我这种渣渣就不休息了，撸起袖子继续学习啦😜 上篇文章已经向大家承诺会写一些技术以外的文章，所以这次我也履行诺言跟大家一起来分享一下我在最近的演讲过程的一些心得，当然这里最主要的还是讲如何用PPT(因为我穷得只能吃土所以就无法为大家讲解Keynote啦，但是大体的思想是差不多的)为你的演讲增色，毕竟作为程序员，在工作的时候不仅仅是只面对代码，有的时候如果具备一定的演讲才能，那么你的老板同事对你也会刮目相看。这篇文章纯粹只是我个人的经验总结，请大神轻喷😂","text":"今天是端午节假期的第一天，在这里祝大家假期快乐，不过像我这种渣渣就不休息了，撸起袖子继续学习啦😜 上篇文章已经向大家承诺会写一些技术以外的文章，所以这次我也履行诺言跟大家一起来分享一下我在最近的演讲过程的一些心得，当然这里最主要的还是讲如何用PPT(因为我穷得只能吃土所以就无法为大家讲解Keynote啦，但是大体的思想是差不多的)为你的演讲增色，毕竟作为程序员，在工作的时候不仅仅是只面对代码，有的时候如果具备一定的演讲才能，那么你的老板同事对你也会刮目相看。这篇文章纯粹只是我个人的经验总结，请大神轻喷😂 console.error(\"Error: [hexo-tag-aplayer] Unrecognized tag argument(2): autoplay=ture\"); 前言其实这篇文章我很久以前就想写了，但是碍于自己在演讲方面还不是特别成熟所以一直不敢动笔，直到今天，我觉得自己似乎已经有一定的能力可以跟大家一起来分享PPT与演讲的故事了。诚然这篇文章并不是入门的教你如何做PPT，而是与大家一起探讨分享如何将PPT做的引人入胜，为你的演讲助力增色，我也将围绕这个话题与大家一起讲述演讲的前后以及演讲过程中的注意事项，力争将我学习到的经验技巧“和盘托出”😊 老铁别废话了 演讲前在封面中大家已经看到了伟大的乔帮主，他的确是一个演讲天才，当然这也与他的人格魅力密切相关。不过一场好的演讲还是得需要做足充分准备的，以下我就一一道来。 提前到演讲场地勘测或许大家觉得这个似乎没有必要，但实际上如果你将要准备一个大型的演讲或者你觉得这个演讲对你十分重要的话，那我奉劝你还是照做，为了你的观众你就辛苦一点吧！大家可以来看一下以下两张图： 水平式礼堂 阶梯式礼堂 很明显如果演讲的场地是像第一张图中的水平式礼堂那样的话，那么坐在后面的观众看屏幕就会比较吃力，尤其当内容处于屏幕的下方时，这里有两种解决方式，第一是与主办方协商将屏幕高度提高一些，第二个就是我们在做PPT的时候适当将内容放到中上部分，避免在PPT下方放置过多的内容。对于第二种演讲场地的话，就可以省去这种担忧了，但是因为我还在学校，除非是大的演讲教室，一般都是水平式的演讲场地。这一点对观众来说是至关重要的，虽然观众可能觉得这应当是理所当然的，但是又有多少演讲者考虑到这一点呢？ 考虑PPT的尺寸PPT的尺寸是演讲者必须要十分注意的，往往我们在16:9的电脑屏幕上做的PPT可以完全覆盖整个屏幕，但是到了演讲场地时由于演讲的电脑是4:3或者投影仪同样也是4:3的时候，你辛辛苦苦做好的PPT就会变形，出现意想不到的情况。因此这一点也是你提前到演讲场地勘测时需要询问的一个重要事宜，但是最稳妥的方式依旧是带上自己的电脑，毕竟由于office的版本兼容性存在差异，许多意想不到的状况都有可能随时发生。 找准你的观众演讲分为很多种，有商业性的有娱乐性的，所以演讲的观众也有很多类型，有你的同事同学，有你的老师老板合作伙伴等等，对待不同的场合与观众我们做PPT也应当采取不同的style。例如对待年轻人我们可以用很装逼的PPT来展示我们的演讲，那对于很严肃的场合或者年纪比较大的观众我们就应该更加踏实稳重一点，或许只有尽可能地去“取悦”观众你才会慢慢的成功。 一次搞砸的演讲 在这里我举个例子，前一次我在班级中演讲，上面是我演讲中的一页幻灯片，演讲的观众是年纪比较大的一个老师以及我的同学们，由于之前我一直坚持我的风格，并且也得到了老师和同学们的认可，但是到了这一次情况就变得有些不一样了，对于年纪比较大的观众，他们或许对我的这种风格很不感冒，这个老师对我的评价就是：“对着两个字说了3分钟”，诚然我没有做足充分的准备，也万万没有想到会遇到众口难调的情况，所以也就有了这次尴尬的经历，不过这也给了我宝贵的经验。 你的特色首先我先向大家展示一下我之前为一个演讲做的一个PPT动画视频的开场，这个开场也获得了在场观众的热烈反响。(function(){var player = new DPlayer({\"container\":document.getElementById(\"dplayer0\"),\"theme\":\"#FADFA3\",\"video\":{\"url\":\"http://wensibo.top/file/img/2017-5-28speaker/quick.mp4\",\"pic\":\"http://wensibo.top/file/img/2017-5-28speaker/quick.png\"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()其实想跟大家说的是我们做的PPT是展示给观众的，那么我们就要千方百计的“取悦”观众，而最好的方式就是用你的PPT不断地去吸引他们的眼球。在开场前的这种效果绝对是物超所值的，不仅可以装装逼让大家对你刮目相看而且还起到了为演讲暖场的作用，但是切记要分清楚场合，也要分清楚的你的观众是否能够接受这种新奇的事物，不然就不仅仅是画蛇添足而已了。如果你想下载源文件，请戳这里，记得给我个star哦⭐ 越用心越糟糕 越用心越糟糕 这是我找到的别人做的一页幻灯片，可以看到作者很用心，生怕观众看不懂把每个字都写上来了，但是我们想想效果，观众会去看完这些字吗？看完之后会记住吗？就算记住了能够记住重点吗？显然是不能的，如果换成下面的这页幻灯片呢？ 换种方式 第二页幻灯片整个的逼格就不一样了，他给观众的震撼力更强，更加简明扼要的抓住内容的重点，而一些次要的则交给演讲者口头表达出来就行了。当然这张图片除了数字之外还有图片的渲染，这也是接下来要讲的。 你知道你的图片很丑吗？上面的这页幻灯片中背景图片很好看，与我们在度娘中找到的那些简直就是大巫见小巫，当然除了找到了好的图片之外，我们还需要对图片进行修饰。我一直很反感直接将文字贴在一张美美的图片上，要么让观众好好欣赏图片要么就好好看字，千万不要糟蹋图片，那么如何将这两种元素很好的结合呢？上面这页幻灯片用了一个比较普遍的手法，就是为图片加上一个有透明度的文本框，具体的做法就是插入一个文本框，用适当的颜色填充整个文本框并将文本框覆盖住整张图片，接下来调整文本框填充色的透明度就可以达到上面的效果，相信聪明的你应该很容易做到😎 如何找到好的图片？好的图片可以为演讲增色不少，那么问题来了，如何找到更好的图片呢？ 为大家提供一些有用的图片素材网站： 免费图片-Pixabay 最出色的摄影社区-500px Free stock photos-Pexels 设计师的汇集地-Dribbble 必应图片-绝对比百度图片强100倍 Google图片-自备梯子 还有图标素材网站： 阿里巴巴矢量图标库 Material Design图标库 EasyIcon 好好记住PPT的内容优秀的演讲者应该能够做到脱稿演讲，但是这并无捷径，需要我们按照制作PPT的思路去记忆其中的内容，并且在演讲的时候能够做到行动自如而不是站在电脑旁边看着幻灯片的内容，否则观众就会对你失去兴趣了。我个人的一个小技巧就是在做PPT之前列一个提纲，接着按照这个提纲制作幻灯片(幻灯片内容的逻辑性必须要强)，等到你需要背诵的时候只需要回忆你列的提纲，大部分的内容就会呈现在你的脑海中了。 演讲时带上一只翻页笔如果你是一个职业的演讲者，你对翻页笔应该不陌生，它们长这样👇 如果你没有翻页笔，那么无线鼠标也是不错的选择，总之有了这些工具你就可以脱离电脑，随心所欲的操纵幻灯片，但是这一切的前提是你已经能够驾驭幻灯片了哦！ 真诚地向观众展示你精心准备了许久的礼物在我做PPT的这些日子里，我总是怀着这样的心情去演讲，有的时候我做20页的幻灯片需要花费半天的时间(或许是效率问题😂)，不夸张地说这绝对是一件脑力活。正是因为准备了这么久所以才更希望展现在观众面前的时候按照自己的预期走，不要出一丁点差错，而你的观众就是其中最大的因素，所以必须对你的观众真诚，让他们眼前一亮，让他们的注意力只停留在你的演讲上，这便成功了一大半。 请保持幽默当我们看乔布斯的演讲或者老罗的相声时总会感叹这些演讲的天才是如何做到保持幽默的，有的时候一个眼神、一个动作、一句话、一张图片、一个视频都可以调节现场的气氛，我们在这里不讲如何做到幽默因为我也没有资格讲，这种能力的培养因人而异，但是作为演讲者我们在平时可以有意识的培养自己这方面的能力。相信当掌握了这种能力之后你的演讲将会事半功倍！ 演讲后总结其实演讲跟平时的考试一样，考完试之后需要总结经验，但也不一样，因为当你把它当成一场考试的时候就失去它原本的乐趣，尽管享受其中的乐趣就行了。如果说总结，那么我们又需要从哪些方面进行总结呢？首先询问你的观众，让他告诉你观看完整场演讲之后最真实的想法，观众的意见是最宝贵的，去其糟粕，选择其中对你有用的，改之；第二就是重新回顾你的PPT，同时边回忆你演讲时的场景，看看是否哪一页你讲得不好或者是幻灯片还可以做得更好。我就是经常这样的，现在来看以前做的幻灯片就觉得当初的自己太稚嫩了，有时甚至觉得一些动画一点道理都没有。所以我也一直认为好的幻灯片不是做出来的而是改出来的。 学习知己知彼才能百战不殆，上一点是自身的总结，那么这一点就是我们需要向别人来学习啦😉 我个人对科技界的发布会十分的热衷，观看这些发布会的时候不仅可以了解科技界的前沿，更重要的就是观看他们的演讲，而我关注比较多的是如下的发布会👇 一加手机的发布会 老罗的单口相声 Google的IO大会 苹果每年的新品发布会 从这些高质量的演讲中，我们能够学习到优秀的演讲者身上的优点，可以学习他们的幻灯片，当然这都是基于兴趣，如果没有兴趣那么看整场发布会是很枯燥的，如果这样我更建议去模仿他们的幻灯片，基本每次大型的发布会之后，网上都会流出发布会的幻灯片，我们都可以拿来借鉴。 后记本篇文章主要是和大家一起分享我在制作PPT以及演讲中的一些心得，当然由于我个人能力有限，其中难免有一些讲的不是很透彻也有可能不够好，希望大家多多见谅。作为一名大三的学生我要进步和学习的还有很多，不过依旧希望这篇文章在一定程度上能够帮助到你，再次祝大家端午节快乐☺","categories":[{"name":"演讲","slug":"演讲","permalink":"http://www.wensibo.top/categories/演讲/"}],"tags":[{"name":"PPT","slug":"PPT","permalink":"http://www.wensibo.top/tags/PPT/"},{"name":"演讲","slug":"演讲","permalink":"http://www.wensibo.top/tags/演讲/"}]},{"title":"又是一个MVP+RxJava+Retrofit的干货集中营","slug":"GankClient","date":"2017-05-15T14:51:25.000Z","updated":"2018-10-21T08:26:20.664Z","comments":true,"path":"2017/05/15/GankClient/","link":"","permalink":"http://www.wensibo.top/2017/05/15/GankClient/","excerpt":"今天想要与大家一起分享的是近一个星期内开发的一个新app——干货集中营客户端，其实网上已经有许多类似的项目，代码家也在他的干货集中营中推荐了几款优秀的作品，我也借鉴了其中的一些，自己开发出一款干货集中营客户端，目前项目已经发布到github，如果你想了解整个工程的具体内容，那么你可以fork或者clone，如果你觉得我做得还可以，那么请你赐给我一个star呗！你的支持会是我努力的动力。 Google_I/O_2017","text":"今天想要与大家一起分享的是近一个星期内开发的一个新app——干货集中营客户端，其实网上已经有许多类似的项目，代码家也在他的干货集中营中推荐了几款优秀的作品，我也借鉴了其中的一些，自己开发出一款干货集中营客户端，目前项目已经发布到github，如果你想了解整个工程的具体内容，那么你可以fork或者clone，如果你觉得我做得还可以，那么请你赐给我一个star呗！你的支持会是我努力的动力。 Google_I/O_2017 console.error(\"Error: [hexo-tag-aplayer] Unrecognized tag argument(2): autoplay=ture\"); 前言慢慢的已经养成了每篇文章都会来一个前言，也慢慢地将写文章潜移默化的转变成写故事，所以每个故事都会有前言，也都会有结果，这次也不例外。距离上篇引起热烈反响的文章发布已经过去一个月了，承蒙广大网友对我的支持以及建议，当然作为一个90后，我也很虚心的接受来自各方的吐槽，毕竟我并不优秀，只是一直在优秀的路上努力的奔跑着。下面我想跟大家一起分享一下这一个月里我做了些什么事，以及接下来一段时间的计划和打算。 Have Done List持续22天在github上出现，看看下面这棵贡献树博客浏览量突破35000看了1本好书——《网络是怎样连接的》研究Retrofit与RxJava的源码（待我葡萄成熟时再把文章放出来吧，现在太嫩了，不好意思让大家看到）2次担任演讲的主讲人(之后会写一篇文章讲述我的演讲技巧)看了锤子科技新品发布会(我是罗粉但也是加油，心疼老罗一秒)努力寻找实习(投了许多简历，但是无一幸免:sob: ,有同学可以推荐一波吗？没有的话我待会再问问)1个全新的干货集中营客户端app(也是写这篇文章的缘由) Todo ListGoogle I/O 2017开发者大会xposed插件开发(这个闪念是有一天夜里惊醒过来的想法)继续写好的文章与大家一起分享，不仅仅是技术方面的，还有许多我觉得有用的文章，都会为大家奉上，感谢老铁们的支持继续看书继续找实习(呜呜呜~~(&gt;_&lt;)~~,体会到工作难找了，尤其是互联网寒冬) 好啦，上面讲了一大堆废话终于可以进入正题了，我也很基动，开车咯！ 项目介绍GankClient(又称干货集中营客户端)是一个全新的干货集中营客户端，它获取的是来自干货集中营API的数据，利用全新的Material Design的设计语言展示数据内容。整个项目采用MVP的设计架构，并且大量使用RxJava2，网络框架使用的是Retrofit。我用下面几个装逼的句子来形容一下这个APP： 更快速的加载速度 更流畅的页面体验 更有趣的刷新效果 更精美的网页浏览 更美观的视觉享受 这个只是我的个人感受，大神请轻喷:joy: ，不过还是希望大家能够喜欢这个项目，并且积极的向我pull request以及反馈bug，希望大家多多支持。如果可以的话给个star咯。 预览 谁说不给图的 全部效果图来一发 没有gif图都不好意思说话了 gif 下载如果你想测试这个项目，那么请手动clone，如果你想尝试一下APP，那么你可以使劲戳这里 ,或者扫下面的二维码。后期我会发布到应用市场，希望大家可以多多支持！ 功能&amp;特色 √表示已经实现的功能，没有√的是还没实现或者需要完善的功能。 实时获取服务器的最新数据，采用CardView的布局以更好的展现数据。刷新效果很好玩，真的很精致，感谢Phoenix。如果你装有Chrome浏览器，并将其设置为默认浏览器，那么你的网页浏览效果就会十分酷炫。感谢Custom-Tabs-Client ! 墙裂推荐Chrome，如果你没有安装Chrome，那也没关系，那就用传统的WebView吧！更加统一的过渡动画，相信你会爱上它。保存、分享图片与链接，也可以直接使用浏览器打开链接。更好看的Material Design设计风格。妹子很漂亮哟！优化webview的视频播放。增加使用系统浏览器的选项。修复在主界面中加载数据到2016/4/20左右时数据显示错乱的问题。增强分享功能。 分解终于到了这个纯干货步骤了，别说话先看东西！ 如何使用MVP的设计架构我先展示以下这个项目的结构图，让大家心里有个底 http GankRetrofit.java GankRetrofitClient.java mvp model BaseModel.java presenter BasePresenter.java view IBaseView.java ui activity adapter base chromeviews fragment widget 可以看到，整个项目的结构还算比较清晰，整体的架构都是在mvp目录中定下来的，mvp架构分三层，model模型层，用于定义一些数据的类型；presenter呈现者层，用于处理view层的逻辑；view显示层，这里定义的都是接口，真正实现他们的是activity，这些activity只要实现相应的接口，就能够自己复写其中的方法。当然我这么说你肯定还是一脸懵逼，而且我还必须跟你说，我这个不算最纯粹的MVP模式，最纯粹的写法应该都是面向接口编程的，就是在model，presenter，以及view下都是定义接口，而到了具体的运用场景，就定义出具体的类去实现这些接口。当然了，为了让大家能够更清楚MVP是怎么实现的，下面我会用代码的形式为大家展示，例如我要编写MainActivity的代码，首先已经知道在这个Activity中需要做如下这些事： 初始化组件 加载Fragment FloatingActionButton的点击事件——去到DailyActivity drawer menu的点击事件——去到AboutActivity 为了让Activity专注于界面的工作，而不用去考虑逻辑处理的操作，这个就是所谓的解耦，那么我们可以将逻辑的操作放到presenter中去，而与界面有关的操作就放在view下，于是我们就可以这样写(为了便于大家理解，我将项目中的代码做了适当的修改，如果你想了解更加具体的逻辑，可以仔细看看代码)： IBaseView 1234public interface IBaseView &#123; //界面初始化操作 void init();&#125; BasePresenter&amp;MainPresenter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** 将presenter的公共操作集成为BasePresenter*/public abstract class BasePresenter &lt;T extends IBaseView&gt;&#123; protected Disposable disposable; protected Context context; protected T iView; //获取到view的对象 public BasePresenter(Context context, T iView) &#123; this.context = context; this.iView = iView; &#125; public void init() &#123; iView.init(); &#125; public abstract void release(); public abstract void initPresenter();&#125;/*** 每一个界面都可以编写自己的Presenter，并指定View的泛型*/public class MainPresenter extends BasePresenter&lt;IBaseView&gt; &#123; public MainPresenter(Context context, IBaseView iView) &#123; super(context, iView); &#125; @Override public void release() &#123; &#125; public void toDailyActivity() &#123; Intent intent = new Intent(context, DailyActivity.class); context.startActivity(intent); &#125; public void toAboutActivity() &#123; Intent intent = new Intent(context, AboutActivity.class); context.startActivity(intent); &#125; public void toSettingActivity() &#123; Intent intent = new Intent(context, SettingActivity.class); context.startActivity(intent); &#125; MainActivity 1234567891011121314151617181920212223242526272829303132public class MainActivity &lt;MainPresenter&gt; extends AppCompatActivity implements IBaseView&#123; @OnClick(R.id.fab_main) void fabClick() &#123; presenter.toDailyActivity(); &#125; @Override public void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void initPresenter() &#123; presenter = new MainPresenter(this, this); presenter.init(); &#125; @Override public void init() &#123; //所有的初始化操作 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); presenter.release(); &#125;&#125; 大概就是这样一个套路，讲真我这样讲你肯定迷糊，我当初在学这个的时候也是十分凌乱，后来才发现只有自己动手亲自敲代码才能了解整个思路，另外大家在学习MVP的过程中应该擅于画图，不管是在纸上画还是使用思维导图都行，这样可以让你更加宏观的了解整个调用的顺序以及各个类之间的关系，这绝不是你看了一篇文章就能懂的。 你真的用好RxJava了吗当我问这个问题的时候，其实我想说的是RxJava的用处很广，我们想当然的认为只要RxJava与Retrofit相配合就算是完成任务了，但实际上只要涉及到耗时操作、线程切换：网络请求、图片解析、数据库读取等等需要用多个线程一起完成的工作时，你都可以用到RxJava，并且如果你还一直用RxJava1的话，那么你也OUT啦，当你认识RxJava2.x的时候你会发现他更强大了。关于RxJava，我后续会写相关的文章与大家一起分享，这里我举项目中遇到的一个例子，看看RxJava的用武之地是多么的广： 12345678910111213141516171819202122232425262728293031/*** 将图片保存在本地*/public void openWebView(final Gank gank) &#123; disposable=Observable.create(new ObservableOnSubscribe() &#123; @Override public void subscribe(@NonNull ObservableEmitter e) throws Exception &#123; e.onNext(android.R.drawable.ic_menu_share); &#125; &#125;).subscribeOn(Schedulers.newThread())//开启一个新线程来进行耗时操作 .map(new Function&lt;Integer, Bitmap&gt;() &#123; @Override public Bitmap apply(@NonNull Integer integer) throws Exception &#123; //将资源id解析为bitmap是一个耗时操作 return BitmapFactory.decodeResource(activity.getResources(), integer); &#125; &#125;).observeOn(AndroidSchedulers.mainThread())//回到主线程操作bitmap .subscribe(new Consumer&lt;Bitmap&gt;() &#123; @Override public void accept(@NonNull Bitmap bitmap) throws Exception &#123; //拿到bitmap之后做的界面更新 &#125; &#125;);&#125; //释放资源public void release() &#123; if (disposable != null&amp;&amp;!disposable.isDisposed()) &#123; disposable.dispose(); &#125; &#125; 爽快的Retrofit还记得之前我写过Volley的一系列文章，虽然觉得这个开源框架已经不错了，但毕竟长江后浪推前浪，在Retrofit的面前，Volley简直就是小巫见大巫，看看我们应该如何在项目中使用： 1、新建一个接口，用注解的形式在里面定义网络请求的方法： 12345678910111213141516171819public interface GankRetrofit &#123; //获取MainActivity界面的数据，具体的请求路径应该详细看官方的API说明， // Retrofit与RxJava配合之后才能显示出更强的威力 @GET(\"data/&#123;type&#125;/40/&#123;page&#125;\") Observable&lt;MainData&gt; getMainData(@Path(\"type\") String type, @Path(\"page\") int page);&#125;``` * 2、获得实例：```javaGson date_gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").create();Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://gank.io/api/\") //指定服务器地址 .addConverterFactory(GsonConverterFactory.create(date_gson)) //添加一个gson的解析器 .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // 如果想使用RxJava那就需要添加这个适配器 .build();GankRetrofit gankRetrofit;gankRetrofit = retrofit.create(GankRetrofit.class); //获取GankRetrofit的对象 3、获取数据： 12//返回的Observable&lt;MainData&gt;对象就可以使用RxJava进行解析了gankRetrofit.getMainData(\"Android\",40); 更好的网页浏览体验——Custom-Tabs-Client如果你使用过Chrome浏览器，那么你应该会喜欢上它，当我们在使用webview开发的时候，会发现webview存在许多的限制，并且开发者对webview不能完全控制，于是Chrome团队为了解决开发者的这些问题，就设计出这个开源库，只要用户手机上安装Chrome并且设置为默认浏览器，那么打开网页链接的时候就会看到如下的画面：是的！如此酷炫的画面是用到了Chrome浏览器的内核，并且读取Chrome的cookie，例如如果你在Chrome已经登录过github了，那么通过这个库打开的github链接同样也显示你已经登录了github。当然除了页面效果十分好之外，我们还可以自定义许多东西，例如过渡动画、ToolBar上方的ActionButton等等，我的项目中也已经实现了这两个功能。接下来我带大家一起看看最简单的实例应该怎么编写： CustomTabsIntent.Builder customTabsIntent; customTabsIntent = new CustomTabsIntent.Builder(); //获取到CustomTabsIntent实例 //一系列的设置 customTabsIntent.setToolbarColor(activity.getResources().getColor(R.color.colorPrimaryDark)); //设置ToolBar的颜色 customTabsIntent.setShowTitle(true); //设置是否显示网页的标题 customTabsIntent.setStartAnimations(activity, R.anim.slide_in_right, R.anim.slide_out_left); //设置进入的动画 customTabsIntent.setExitAnimations(activity, R.anim.slide_in_left,R.anim.slide_out_right); //设置退出的动画 //开启网页 CustomTabActivityHelper.openCustomTab( activity, //当前的activity customTabsIntent.build(), view, gank, //gank带有要打开的网页的url new CustomFallback() { //如果用户没有安装Chrome并将其设置为默认浏览器的话，应该做这样的处理 @Override public void openUri(Activity activity, View view,Gank gank) { Log.d(\"Gank\", gank.toString()); super.openUri(activity, view,gank); } }); 以上就是想要跟大家一起分享的关于这个项目中一些重要的点，可能有些地方讲得并不那么清楚，但我觉得只有实践才能出真知，所以老哥还是乖乖打开AS撸撸代码啦！ 版本控制目前app的版本为V1.0.0，我会用下面的时间表记录版本的迭代，如果有更新的版本，我会及时更新这个表格。 Version Date V1.0.0 2017/5/14 致谢作为一名Android开发者，我们都应该具有像罗老师一样感激开源世界的情怀，而我们现在能做的就是同样为开源世界做贡献，无论是写文章亦或是写程序，记得都要时刻保持一颗感恩的心。非常感谢代码家以及他的干活集中营，也非常感谢许多前辈们做过的干活集中营app。 代码家 干货集中营 Gank.lu 后记最近一个月，感觉自己身体被掏空，吐槽学校对我们专业的课程安排如此不合理，每天上那些自己不感兴趣的课程确实很无趣，但是生活再难也要感激它，只有通过自己的双手去努力，将来的你才会为现在的自己喝彩骄傲。下篇文章再见！","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"MVP","slug":"MVP","permalink":"http://www.wensibo.top/tags/MVP/"},{"name":"RxJava","slug":"RxJava","permalink":"http://www.wensibo.top/tags/RxJava/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.wensibo.top/tags/Retrofit/"}]},{"title":"给21岁的自己","slug":"birthday","date":"2017-04-15T16:00:00.000Z","updated":"2018-10-21T14:42:35.314Z","comments":true,"path":"2017/04/16/birthday/","link":"","permalink":"http://www.wensibo.top/2017/04/16/birthday/","excerpt":"没有那么多的前言啦！点进去看图片吧！ 诗和远方","text":"没有那么多的前言啦！点进去看图片吧！ 诗和远方 var ap = new APlayer({ element: document.getElementById(\"aplayer-ELaSUNNH\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"安静\", author: \"周杰伦\", url: \"https://github.com/Wensibob/Wensibob.github.io/tree/master/file/img/2017-4-15birthday//quite_jay.mp3\", pic: \"https://github.com/Wensibob/Wensibob.github.io/tree/master/file/img/2017-4-15birthday/quite_jay.png\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","categories":[{"name":"生日","slug":"生日","permalink":"http://www.wensibo.top/categories/生日/"}],"tags":[]},{"title":"2017腾讯实习生Android客户端开发面试总结","slug":"2017Tencent_review","date":"2017-04-13T15:49:25.000Z","updated":"2018-10-21T08:26:20.496Z","comments":true,"path":"2017/04/13/2017Tencent_review/","link":"","permalink":"http://www.wensibo.top/2017/04/13/2017Tencent_review/","excerpt":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 或许你已经看过这篇文章，但我想告诉大家的是其实我并没有大家说的那么厉害，本人学到的还只是皮毛中的皮毛，相比起很多大神我自己只有负责仰望的权利，所以如果可以的话请在本篇文章的最后留下你对我的建议，记住是建议！ 先做个自我介绍，本人大三狗一枚，就读的是广州一个普通的一本大学(非985、211)，专业是比较尴尬的电子商务(非计算机学院，连C的课程都没有就只有Java)，但是一切的尴尬并没有阻挡我对Android开发的热爱，自学一年多了，基础以及开发的技术也掌握的相对成熟了。在即将要变身大四狗的关键节点看到了腾讯爸爸暑期实习生的招聘，便刻不容缓地参加笔试，很开心顺利收到面试通知，可惜最终止步二面，以下是我此次面试的整个过程，希望对大家有所帮助。 console.error(\"Error: [hexo-tag-aplayer] Unrecognized tag argument(2): autoplay=ture\");","text":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 或许你已经看过这篇文章，但我想告诉大家的是其实我并没有大家说的那么厉害，本人学到的还只是皮毛中的皮毛，相比起很多大神我自己只有负责仰望的权利，所以如果可以的话请在本篇文章的最后留下你对我的建议，记住是建议！ 先做个自我介绍，本人大三狗一枚，就读的是广州一个普通的一本大学(非985、211)，专业是比较尴尬的电子商务(非计算机学院，连C的课程都没有就只有Java)，但是一切的尴尬并没有阻挡我对Android开发的热爱，自学一年多了，基础以及开发的技术也掌握的相对成熟了。在即将要变身大四狗的关键节点看到了腾讯爸爸暑期实习生的招聘，便刻不容缓地参加笔试，很开心顺利收到面试通知，可惜最终止步二面，以下是我此次面试的整个过程，希望对大家有所帮助。 console.error(\"Error: [hexo-tag-aplayer] Unrecognized tag argument(2): autoplay=ture\"); 伏笔一面的时间是11号下午2点钟，因为对酒店的位置不熟悉，所以提前了两个小时出发，下公车过马路的时候下起了小小雨，所以撑起了雨伞，这时站在我前方的一个中年女士回头看着我的雨伞，我似乎看到了她眼神中对雨伞的渴望，所以走上前去给她撑伞，她愣了一下说她不是想要撑伞，只是想到今天自己忘记带雨伞了不知该怎么办。送她走过马路的过程中，我告知她要去参加腾讯的面试，她说面试所在酒店的老板是她朋友(蜜汁剧情😂)，后来告别的时候她说祝我好运并叫我记得跟面试官说我今天运气很好哟(尴尬连 😳)。其实面试结束之后觉得此事很蹊跷，但也被她说中我一面运气很好，所以也很感激这位陌生的中年女士吧！ 一面 手持OP3拍一面 来一面的人很多，等候的会议厅里显得有点嘈杂，不过很意外的是来面试的学生中男女比例相当，更可以说女生稍稍比男生多一丢丢，看来程序媛也很努力啊！2点过几分钟，系统发短信提醒我可以面试了，腾讯的高效可见一斑，以下是正文。我：敲门，问好，深深鞠躬并双手递上简历。一面的面试官有些许腼腆，偏瘦偏黑，坐得很直，第一感觉很Nice。面试官：你好，先做个自我介绍吧。我：将自己准备了许久的自我介绍顺利地讲了一遍，面试官很认真的听并逐点看我的简历。面试官：听完自我介绍之后，问道：你是自学Android还是学校里有相关的课程。我：苦逼的我当然是自学的啦，大一的时候学校教的是Java，老师很好，也是我在大学期间觉得唯一的一个好老师了。讲自己从一开始通过看郭霖的《第一行代码》入门，到中间走了许多弯路去看了一些补习机构的教程视频，再到后来自己总结出了一个学习路线图，并开始专注于看优秀的图书和勤打代码，并且做了一些比较拿得出手的项目和维护着一个个人博客 。面试官：频频点头，似乎很同意我的学习历程并且对我目前的状态表示满意。接着问，知道Android中的ANR吗？解释一下。我：知道，ANR就是Application Not Responding ，即应用程序未响应，之所以会造成这种异常是因为Android是在主线程即UI线程中更新界面的，但是如果在UI线程中进行过多的耗时操作就会堵塞主线程从而造成ANR，具体造成ANR的原因有三个：Activity耗时操作超过5s，Broadcast Receiver 超过10s，Service超过15s。面试官：似乎很满意，接着问道，那Android中是如何避免ANR的？我：这些问题因为都是很基础的，并且面试前复习过了，所以对答如流。我说我举一种方法吧，例如AsyncTask，具体介绍了他的doInBackground和updateProgress以及postExecute三个方法的使用以及参数的类型转换，还分析了AsyncTask的缺点，就是它所维护的线程池大小为128，同一时刻只能有5个工作线程和一个缓存线程，如果耗时操作工作量巨大就会导致线程池大小不够用，这就是它的缺点，另外我还介绍了它的解决方式，就是由一个控制线程来处理AsyncTask的调用，判断线程池是否已经满了，如果满的话就停止处理。面试官：一番回答下来面试官从看着简历到一直看着我并且频频点头，似乎对我的回答十分满意，我也暗自窃喜。接着他就问除了AsyncTask之外，有用过Handler吗？具体解释一下它的实现过程。我：这种问题可以说是每次面试必问的，并且自己也研究过源码，对Looper的实现机理十分熟悉，所以又是讲了一大堆。面试官：对我的回答十分满意，并问我是不是经常看源码？我：还好，毕竟也不是什么源码都看，如果被问到没看过的就尴尬了，还是谦虚点。面试官：Android应用程序之间是通过哪些方式共享数据的？我：File，Sqlite，Content Provider，Service，BroadCast Receiver，Intent，同个Application内部的话还可以通过静态变量共享数据。面试官：点点头，这个面试官很喜欢点头。那能不能说说Content Provider的生命周期？我：感觉有点懵逼，四大组件中似乎很少接触到Content Provider的生命周期，自己也不是很确定，就说生命周期不是很懂，但是我可以说一下它的实现机理，就说了Content Provider，Content Resolver之间的使用规则，具体到程序间的URI。后来回学校之后查了一下，发现Content Provider并没有生命周期这一说法，不知道面试官是问错了还是故意挖坑给我跳的，好在没往里面跳。面试官：开始问到简历上面的项目，先问了Volley的实现机理。我：因为之前写过四篇文章来介绍Volley，所以Volley的实现机理很清楚，便给他详细的介绍了起来，具体的可以看我的这篇Volley源码分析 。面试官：你刚才对Volley的实现机理讲的十分详细，调理也很清晰，很不错，那你知道为什么线程池里面是有5个线程在循环呢？为什么不是6个7个或者8个呢？我：哎呀，这个问题倒是没有细细去想，但是当初也很奇怪为什么会定5作为全局常量呢？会不会因为5是开发者的幸运数字呢(黑人问号)，后来想了一下对面试官说，可能是因为Volley面向的网络请求是请求量比较小但是请求比较频繁的操作，所以5应该是刚好能够处理得来的，又或许5是一个经过大量的数据实验之后得到的一个相对符合的数量吧！面试官：笑了笑，其实我也不是很清楚。(尴尬 😧 ，面试官好像想逗我一下)。接着问：说道网络请求方面，你能不能说说像QQ这种IM的通讯机理是怎么样的？我：有点紧张 😰 ，因为复习时间比较短，所以还没仔细看网络方面的知识，所以就大概说了一下4层结构还有3次握手。面试官：似乎觉得还可以，继续点头。接着问：Volley网络请求了哪些数据类型？我：String字符串，图片，XML，JSON。面试官：服务器是自己搭的吗？我：尴尬了一下，不，不是自己搭的，是用到了一些天气和全国城市的接口数据，因为当时在做调试，所以没有心思去搭建一个服务器，不过在大二的时候学过WEB开发，对Tomcat比较熟悉，并且简历上的第二个项目就是我当初做的Blog项目，所以对服务器的搭建还是有一些心得的，接着就跟他说了一些搭建的步骤。面试官：对我的回答很满意，毕竟学Android的如果能够对服务器端有比较深的认识的话在做数据测试的时候是可以省去团队的很多开支的。接着问：说说XML、JSON、GSON有什么样的联系？我：这个很简单了，有接触过的应该都知道，XML全称叫做可扩展标记语言，它的结构相对简单，可读性强，但是对于一些比较复杂的数据结构就很难存储，JSON的话刚好弥补了XML的这些缺点，至于GSON的话，是因为Google的一个开源库而得名的，这个开源库可以很方便地将JSON数组转换为对象，这在开发中简化了将JSON的字段转换为属性的步骤。面试官：看着简历问了我的便签项目是如何实现的？我：因为我做过的很多项目都是会写一些文章来介绍里面实现的机理，如果你对此感兴趣，可以看我这篇写一个小便签 。面试官：数据库的操作用到的是什么类型的数据库？我：用到的普通的Sqlite。其实我还可以多扩展点的，例如用过GreenDAO框架，所以还可以说说用了GreenDAO与用传统的Sqlite的操作的区别。面试官：说说你用Github做了些什么？我：有点不太清楚面试官问这个问题的意思 😮 ，就说经常push项目，订阅了代码家的邮箱推送，每天会推送一些Github的好项目，所以会fork一些优秀的项目，并且在Indigo项目中积极地发issue。面试官：点点头，似乎觉得还可以。学过C/C++吗？我：很尴尬，作为一个电子商务专业的学生很怕被问到这个问题，不过还是如实地向他说明情况，没学过C/C++，但是学过JAVA，数据结构、算法、计算机网络，并且我在自学操作系统。面试官：显然很惊讶没有学过C，但是考虑到是Android开发，所以也就没多为难我，并且了解到我自学操作系统露出了笑容，接着让我说一下算法。我：咳，算法准备的不是很充分，所以鸡贼的向他讲了最简单的冒泡排序，还没讲完他就频频点头。舒了一口气。面试官：经常写博客对吧！说说自己写得最好的一篇博客吧。我：很欣喜，向他讲起了写Volley源码的那四篇文章，他也听得津津有味，感觉自己坚持做的一些事情终于得到别人的认可了，很开心 😊 。面试官：有没有觉得自己做得比较自豪的事情但是我还没有问到的？我：写博客啊！向他说道一开始是用的博客园的第三方博客，但是后来很想有自己可以DIY的个人博客，并且很喜欢Material Design所以就花了很多时间来建站，从博客程序的安装，到域名购买、服务器维护、网站推广，自己都用了很多的时间和心思，还说了自己很喜欢MarkDown，真心觉得Word可以仍掉了。他边听边笑。面试官：听到我写博客的这个过程很是满意，对我露出了笑容。看了看时间，说道：面试快结束了，有什么问题想要问我的吗？我：面试前就准备好问题了，所以像个小孩子一样问他我可以问您两个问题吗？右手比起了剪刀手。面试官：当然可以。我：第一个问题是让他对我的此次面试做一个评价，第二个的话是想问一下面试官的邮箱，以便在往后的学习工作中请教。面试官：“HR团队有规定，面试官不能与学生们私下交流，所以这个请求我可能无法实现，如果接下来的面试有机会的话我再跟你联系，希望你见谅。至于第一个问题的话，我觉得你挺优秀的，作为一个不是计算机专业的学生能够在大一的时候就清楚自己未来在Android开发的方向，并且为此而努力着，你说到你写博客的时候我也很喜欢。” 他讲起他与他的同事们在工作中也累计了很多的经验与知识，但是分享的群体也就局限于他们团队，他说像我这样把我学到的知识分享给更多的人，这种也是开源精神的一种体现，希望我继续葆有这样的热情，另外就是我对源码的研究十分的仔细，回答问题的时候逻辑十分清晰，看来对源码的理解是十分的到位的，希望我能够继续保持这个习惯，这样我才能够学到更多的知识。 不出意料，当天晚上接到了二面的通知，第二天早上10点20的面试，似乎觉得自己运气挺不错的，也好像应了那位女士说的。 二面 手持OP3拍二面 二面前天晚上，因为想到二面可能是总监面，所以抓紧时间复习数据结构、算法还有网络方面的知识，因为就差这两块没有复习了，记得那天晚上躺在床上看到了一点多😖 ，第二天早早起床也是提前两个多小时出发，因为适逢上班高峰期，所以过了好多辆公车还是挤不上，好不容易来了一辆，挤上去又被挤下来了😒 ，好在最后终于上了公车，在公车上看到一个好消息，我的上一篇文章被郭霖的公众号收录啦！心里是十分的开心啊，因为与郭霖大神也交流了一段时间，并且一直将其视为自己学习的目标，所以自己写的文章能够通过他的审核也是十分的开心。也在期待着今天的二面能有好结果。短信通知进入房间面试，二面的面试官有点胖胖，跟一面的瘦瘦面试官一看就不是同种类型的，似乎更难对付，暗自捏了一把汗。我：敲门，问好，深深鞠躬并双手呈上简历。面试官：你好请坐，先做个自我介绍吧！我：跟一面一样，把自我介绍顺利的说了一遍，当然相比一面也适当加了一些内容，因为涉及隐私，所以就不方便写出来啦。面试官：绩点很高哦(本人专业课学霸)，Android是自学的对吧？学习多久了？我：跟一面一样，如是回答。面试官：印象似乎很深刻，觉得我自学能力不错，并且学习成绩好，应该还是个比较有追求的少年。电子商务专业有哪些课程？(又是这个问题，已经麻痹了😒)我：像上面的一面回答那样，我很真诚的回答面试官的问题，面试官边听边点点头，听到自己在自学操作系统，就抬起头向我微微笑(有点开心😊)。面试官：说一下你这个Volley项目吧！讲讲你学到了什么？面试官：像一面一样，我详细地讲解了Volley的实现机理，并且加上一面面试官问到的为什么是5个线程的问题，阐述了自己对这个问题的看法，面试官从看着简历到双眼凝视我。我：感觉很有戏，不过也预感总监会问一些比较难的问题，所以还是心有余悸。面试官：在自己做项目的时候是怎么优化代码的？我：感觉总监面问的就不是一般的问题，因为过了一面所以底子怎么样他应该是心里有数了，所以就问一些宏观上面的问题，考察我开发的一些习惯，这点对于团队合作开发是至关重要的，没有哪个头想招一些编程习惯不好的孩子吧！所以我就向他介绍了Lint，以及日常经常使用的DDMS里面的traceview，heap，allocation tracker，并且分别介绍他们的功能是怎么样的。说完一大堆之后自己舒了一口气，也没有一开始的怯场了。面试官：应该觉得我的回答不错，我介绍每个工具的用途的时候他就点点头。接着问，如果你来腾讯实习，是想做UI，业务逻辑，还是网络方面的？我：很开心能够被问到这种问题，因为我对UI很感兴趣，所以我向面试官说到我对UI的敏锐性比较强，并且向他介绍了Google的Material Design设计规范，因为考虑到腾讯旗下的许多产品并没有遵循这个设计规范，所以我也就没有展开比较腾讯的产品(要是说的产品是面试官负责的，不就GG了)，而是将MD设计扯到了我的博客网站，向他说我的网站使用的是Indigo的主题，这个主题充分利用了MD的设计规范，所以我一开始见到它的时候就喜欢上了，并且花了几天几夜的时间开始搭建并且从博客园迁移到Hexo。后来因为过于激动，向面试官说起今天郭霖收录了我的文章。(这个细节处理的不是很好，直接向面试官说起了这件事，感觉十分突兀，可能面试官会觉得我有些许轻狂😴)面试官：礼貌性的笑了笑并且点点头，并且用MBP打开了我的网站，应该有看到吧！问我怎么看Android的UI中的动画？我：有点懵逼，不知道面试官想问哪方面？就说了Android的三种动画：Tween，Frame，Property(3.0之后推出的)，还说了Activity的进入退出的动画的实现方式，例如使用style定义Activity的淡出淡入效果，还有可以复写Activity的overridePendingTransition方法实现这个效果。面试官：似乎觉得我说得不错，让我说说我的博客。我：很开心的向他介绍起整个搭建的过程，并且积极地为Indigo的主题发Issue，解决Bug。面试官：使用的是Android Studio对吧(因为简历上写了擅长使用Android Studio)，以前用过Eclipse吗？我：对这方面有很深的体会，因为一开始使用Eclipse很成熟的时候，发现现在很多开发者都是使用AS，但是自己电脑配置又跟不上，并且因为天朝的关系，编译速度巨慢，Gradle的下载就是隔靴搔痒,但是为了解决这一系列的问题，自己读了很多文章，并且看了一本十分不错的书《Android Studio实战 快速、高效地构建Android应用》，向其介绍起书上的内容。面试官：很满意的看着我，问我平常逛什么网站。我：平时喜欢逛Github，并且喜欢网络红人代码家，订阅了邮箱推送，每天会推送一些Github的优秀项目，所以会Fork别人的好项目，另外的话喜欢看Android的中文开发者网站，还向面试官表达了Google推出中文开发者网站的时候自己激动的心情，他很理解的点点头表示赞同。面试官：绩点很高哦(6/175)，有没有想过要考研啊？我：跟面试官聊到后来，感觉他都不想问我技术问题了，于是就有点开始得瑟起来，也有点High，这点可能是二面被刷的一个原因吧。于是就说自己对考研兴趣不大，自己更想在兴趣方面(Android开发)有所发展，想早点有立足之地。面试官：习惯性的还是点点头，可能心里觉得我这个人不太靠谱吧！接着问，如果公司给你提供实习机会，同时学校给你提供保研机会，那你会怎么选择？我：当然会选择来腾讯实习，因为对考研兴趣不大，想尽快抱住腾讯爸爸的大腿，结交更多的良师益友，让自己更加强大。(现在想起来，觉得回答的有点单薄，也有点让人觉得自己势力心很强，唉😴)面试官：什么时候可以来实习呢？可以实习多久？我：我在官网的招聘信息中看到，官方要求是6月~8月，我说6月已经学期结束了，我可以随时到公司实习，实习时间2~3个月都是可以的，听从公司的安排。面试官：点点头，似乎没什么问题想问了，就问我有什么问题想问我的吗？我：跟一面一样，我想请面试官评价一下我此次的面试。谢谢！面试官：说了我的一些好话，什么学习成绩优秀，有项目经验，经常写博客，说要我继续保持下去，如果有下一轮的话，会安排领导的面试和一轮HR的面试，说了很多。我：心想面试官觉得我还是不错的，不过实际上是不是这样觉得的我就不得而知了，有可能面试官只是不想打击我而已😂。面试官：还有什么问题吗？我：愣了一下，心想为什么面试官为什么一直要问我问题？也就没想太多，随便说，我想请问一下面试官在腾讯工作了这么多年了有什么感受吗？面试官：很慷慨的向我描述他在腾讯的一些经历和感悟，具体的就不方便写出来了。最后还继续问我，还有什么问题想问我的吗？我：很尴尬的笑了笑，觉得面试官很想我问他问题欸，不过自己实在没有准备其他问题，就说大概就是这两个问题了，谢谢面试官。(现在想想，面试官是在试探我吧，看看我有没有胆量问他问题，因为大部分学生都是处于比较怯场的状态，只会问一些比较平常的问题，既然面试官这么坚要我问他问题，那就是想考验我与其他人有没有不同的地方啊，唉，怪自己太年轻！) 最后面试官说：“那我把你的简历留下咯！” 我很开心的说好的，非常感谢面试官对我的面试，深深鞠躬然后离开。回到学校之后一直在等待三面的通知，以为会像一面一样晚上8点多发短信通知，但是直到第二天中午还是没有消息，自己还是很着急的。第二天下午上课的时候查了一下简历的状态，显示自己的此次面试已经结束了。 总结得知自己错过三面的时候突然间觉得有点懵和失望，不过也还是接受了这个结果。可能是二面的时候自己有一些表达上面需要更加斟酌，并且在向面试官提问上面需要更加大胆一点吧！主要有下面几点吧： 更加深厚的底子，同等实力看学校，同等水平看颜值(微笑脸，自己两者都沾不到边)。 就我个人而言，我对比较新的开源框架接触较少，不过这段时间有在认真刻苦学习了，过些日子会写一些文章总结；另外本人项目经验几乎为0，唉！好学校好专业还是重要的，不过我最近也在做一个稍微复杂的项目，希望下次面试的时候能派上用场。 面试过程中需要更加沉稳，好好回答每个问题，不能够轻浮。越简单的问题越应该引起注意，而不是自我感觉良好，整个人要飘起来了。 多发挥自己的优势（我的话是博客可能写的好一点，当然说自己的优势时不要太得瑟！切忌！)。 面试官想你问他问题的时候，应该表现得跟其他面试者不一样，记住每个问题都是展现自己与众不同的机会，好好把握。 不要因为一次的失败就停滞不前，可以不开心一阵，但是要重整旗鼓，对下次面试发起挑战！ 推荐我想向大家推荐一下一个非计算机专业的学生是如何自学Android的，不过这仅仅代表我个人的学习方式，绝不是最好的。 书籍 《第一行代码》(第二版) 《Android编程权威指南》（第2版） 《App研发录》 《深入理解Android》（卷1） 《Android开发艺术探索》 《Android Studio实战 快速、高效地构建Android应用》 《设计模式：可复用面向对象软件的基础》 《Effective Java》 《GitHub入门与实践》 网站 Android开发者中文网站 郭霖的专栏 鸿洋博客 GitHub 其他 勤奋打码 勤奋打码 勤奋打码 重要的事情说三遍 后记这篇文章是我第一次面试后记录的，这只能是我个人的经验总结，并不一定全部对，也不一定适合所有人，所以如果大家觉得我有哪些讲得不好的请给我留言，希望我们能够继续交流。也祝大家在面试工作中好运！","categories":[{"name":"腾讯面经","slug":"腾讯面经","permalink":"http://www.wensibo.top/categories/腾讯面经/"}],"tags":[{"name":"面经","slug":"面经","permalink":"http://www.wensibo.top/tags/面经/"}]},{"title":"或许是介绍Android Studio使用Git最详细的文章","slug":"GitOnAS","date":"2017-03-12T06:18:25.000Z","updated":"2018-10-21T08:26:20.712Z","comments":true,"path":"2017/03/12/GitOnAS/","link":"","permalink":"http://www.wensibo.top/2017/03/12/GitOnAS/","excerpt":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布本文较长，图片很多很多，流量党慎入使用Git已经有一段时间了，但是之前都是使用Git Bash，在Android Studio上使用Git一开始不是很习惯，就像用惯了SVN来使用Git一样，琢磨了一段时间的Android Studio，也看了我觉得为数不多但是很有质量的介绍AS的书籍 《Android Studio实战 快速、高效地构建Android应用》，强烈安利大家哦！所以就写了这篇文章跟大家一起学习如何在Android Studio高效地使用Git。另外如果大家想要拿来学习的话可以直接fork我的项目 。另外一点需要说明的就是本文中大量使用Android Studio的快捷键，如果你不熟悉，可以看看我的另外一篇文章 。","text":"本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布本文较长，图片很多很多，流量党慎入使用Git已经有一段时间了，但是之前都是使用Git Bash，在Android Studio上使用Git一开始不是很习惯，就像用惯了SVN来使用Git一样，琢磨了一段时间的Android Studio，也看了我觉得为数不多但是很有质量的介绍AS的书籍 《Android Studio实战 快速、高效地构建Android应用》，强烈安利大家哦！所以就写了这篇文章跟大家一起学习如何在Android Studio高效地使用Git。另外如果大家想要拿来学习的话可以直接fork我的项目 。另外一点需要说明的就是本文中大量使用Android Studio的快捷键，如果你不熟悉，可以看看我的另外一篇文章 。 安装Git我使用的是Windows，所以我这里只能介绍Windows下安装Git的过程了。点这里选择符合你的版本，直接安装就行了。安装完成之后，在开始菜单中找到Git--&gt;Git Bash，如果出现类似下面的对话框的话就证明安装成功了。 Git界面 安装成功之后，需要配置一下你的信息，直接在上面的命令行中输入以下命令：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意：1.将上方的Your Name换成你自己的名字，随意起都行。2.将上方的`email@example.com换成你自己的邮箱。 3.讲一下git config命令的–global`参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 Android Studio配置Git使用快捷键Ctrl+Alt+S打开Settings，接着点击Version Control --&gt; Git在Path To Git Executable上输入Git的存放位置，如下图： Git Path 之后点击旁边的Test按钮，如果出现如下的成功提示，说明Git配置成功。 Git Success 接着按照下图配置你的Github账号密码，输入完成之后点击Test按钮，如果账号密码都正确的话就会提示成功，那么就可以继续往下走了： Github Account 创建本地仓库不管你是刚刚新建的项目，亦或是已经写好的项目，进行的操作都是一样的。这里我以新建一个名为MyGit的项目为例子，如果你想练习，也可以到这里fork一下。对于一个已经新建好的项目，找到菜单栏上的VCS，按照下图进行操作： 创建本地仓库 选择项目的根目录为git初始化的目录： 初始化目录 初始化之后你会发现原本文件的文件名都是白色的，现在变成了棕色，这表示文件已经被git跟踪了，但是并没有添加到仓库中： 棕色目录 忽略文件我们知道，在git初始化一个仓库的时候会自动生成一个.gitignore文件，这个文件用来忽略那些不用加入到仓库的文件，在我们这个工程中总共生成了两个.gitignore文件，分别是在项目根目录下，以及在app文件夹下。我们可以对这些文件进行编辑，表示我们需要忽略哪些文件，但是一般情况下，我们选择默认就好，除非你有需要就进行适当的修改： .gitignore 添加文件添加文件就如git命令中的git add，在Android Studio中add的方式有四种，但是都是大同小异，让我来一一举例： 1.选中项目的根目录，右键选中Git，再选中Add，如下图： 第一种add方式 2.选中项目根目录，点击菜单栏中的VCS菜单，选中Git–&gt;Add，如下图： 第二种add方式 3.使用快捷键Alt+9，或者点击屏幕下方的Version Control工具按钮打开版本控制的窗口，可以看到应该是如下图的样子，该窗口有两个下拉栏，一个是Default，用来记录已经添加的文件，另一个是Unversioned files，用来记录已经被跟踪但是未添加的文件。 Version Control 右键Unversioned files，选中Git–&gt;Add，如下图： 第三种add方式 4.使用快捷键Ctrl+Alt+A add之后文件名变成了绿色，这是代表已经添加进仓库为文件，接下来就可以commit文件了，使用快捷键Ctrl+K或者选中工程根目录右键Git--&gt;Commit Directory可以调出commit窗口，如下所示，在其中选择你想要提交的文件，填写提交的信息，在Author文本框中可以填写提交此次提交的操作者名字，如果不填写的话，就会默认是之前配置Github账号的用户名。可以看到，提交之后文件名重新变回了熟悉的白色。 首次提交 提交成功之后，你可以使用快捷键Alt+9，或者点击屏幕下方的Version Control工具按钮，切换到Log菜单查看Log日志，如下图所示： 首次提交Log日志 如何clone项目使用Git clone项目到本地中是很简单的，在Android Studio中也是如此，首先找到你喜欢的项目，fork到你自己的仓库之后，点击Clone or Download按钮，复制地址，如下图所示： github 复制地址 接下来回到Android Studio，按照下图的操作可以打开clone的对话框，在地址栏中粘贴刚才复制的地址，点击Test按钮，测试是否可以通过，如果成功，那么久可以点击Clone导入项目了。 clone项目 Clone Test 回到我们最开始讲的MyGit项目，首先我们需要模仿一下在日常开发中使用Git的情形，例如我们经常会在分支上进行工作，所以熟练地掌握分支工作的流程以及技巧是十分重要的，接下来我会使用具体的例子跟大家一起了解如何在Android Studio上使用分支进行开发。以下举得例子将会围绕Git的一种工作模式，即：Git Flow，如果你对此不是很了解，那么推荐你阮一峰老师的文章 。 Git flowGit flow是广泛采用的一种工作流程 Git_flow工作流程图 他的主要特点有两个： 1.首先，项目存在两个长期分支 主分支master 开发分支dev 前者用于存放对外发布的版本，任何时候在这个分支拿到的，都是稳定的分布版；后者用于日常开发，存放最新的开发版。 2.其次，项目存在三种短期分支 功能分支（feature branch） 补丁分支（hotfix branch） 预发分支（release branch） 新增功能1——显示Hello World正如我们在介绍Git flow介绍的，master分支只是用于产品的发布，在平时的开发中是不会使用它的，而只会使用dev分支，但是如果我们有了新的功能，一般是会在dev分支中在创建一条该功能的分支，所以我们应该这样做。 创建dev、feature-1分支，并且我们需要转到feature-1分支上在Android Studio中，我们可以很方便的管理分支，在主界面的右下角，点击Git可以出现当前的分支，默认为master，我们选中New Branch，如下图所示： add_branch_feature-1 在弹出的对话框中我们输入feature-1，点击OK，这样我们不仅新建了feature-1分支，并且正处于该分支中，接下来按照同样的方法创建dev分支，如果不出意外的话，我们现在应该是处于dev分支上，但是因为我们现在要开发功能1，所以必须转换到feature-1分支上，按照下图的操作，我们能够回到feature-1分支上。 come back to feature-1 接下来打开Log，我们应该能够看到如下的情景： log for add two branches 可以看到我们现在有三个分支：master、dev、feature-1，但是AS提示我们应该有四条分支，其实HEAD就是当前活跃分支的游标。形象的记忆就是：你现在在哪儿，HEAD 就指向哪儿，所以 Git 才知道你在那儿！不过 HEAD 并非只能指向分支的最顶端，实际上它可以指向任何一个节点，它就是 Git 内部用来追踪当前位置的标记。我们可以使用下面的图来演示当前分支的情况： branch_picture_1 完成功能1123456789101112/** * feature-1 * display HelloWorld * @param view */ public void feature1(View view) &#123; if (btn_feature_1.getText().toString().equals(\"功能1\")) &#123; btn_feature_1.setText(R.string.feature_1_dis); &#125; else &#123; btn_feature_1.setText(R.string.feature_1); &#125; &#125; 好了，功能1编写完成，那么就提交吧！老方法：Ctrl+K进行提交，按照下图填写提交信息，每一次的提交信息最好能够详细并且格式规范，这样以后再查看Log的时候就会比较方便。 add feature-1 on feature-1 点击Commit按钮提交完毕之后，可以看到现在的log图变成了下图： log after add feature-1 我们可以打开Log图的右侧，他列出了目前正在被Git跟踪的所有文件，我们选中MainActivity.java，点击上边的第二个按钮Show Diff(显示差异)： show diff 在弹出的界面中可以显示该文件的当前版本和master分支中的该文件的差异，我们可以使用Esc快捷键退出该界面，如下图所示： diff1 on MainActivity.java 将feature-1分支合并到dev分支上如下图所示，选中dev分支并选择checkout： chose dev 你会发现现在代码回到了最开始的状态，现在选中feature-1分支并选中merge，准备将feature-1分支合并到dev分支上： merge feature-1 to dev 再来重新看一下Log图，他长下面这样，可以看到现在feature-1分支已经与dev分支合并，并且现在他们是处于同一状态的： log after merge to dev 最后的最后，我们需要删除已经完成任务的feature-1分支，以免分支过多管理混乱。 delete branch feature-1 新增功能2——显示Hello Android同样的道理，我们可以按照如下的步骤这样做： 1.迁出dev分支，并且新建分支feature-2之后迁出feature-2分支，具体的步骤我就不再演示了，跟上面的是一样的。 2.开始撸代码。123456789101112/** * feature-2 * display HelloAndroid * @param view */ public void feature2(View view) &#123; if (btn_feature_2.getText().toString().equals(\"功能2\")) &#123; btn_feature_2.setText(R.string.feature_2_dis); &#125; else &#123; btn_feature_2.setText(R.string.feature_2); &#125; &#125; 3.使用快捷键Ctrl+K提交feature-2的修改，并填写提交信息。 add feature-2 on branch feature-2 4.切换回dev分支并且合并feature-2分支之后删除feature-2分支。如果不出错的话，你的Log应该是下面这样的： log after delete feature-2 在dev分支上增加功能3——Hello Java同样的道理，这里我就不再一一演示，如果按照上面的步骤做的话，最后的Log应该是这样的： log after add feature-3 on dev 重点来了，老板说了，新开发的功能3不喜欢，需要删除了功能3，咋办呢？这里就需要讲到Git的回退了，在Android Studio中提供了两种回退的方式：Git revert以及Git reset。 Git revertGit revert可以将版本回退到上一步，但是会新增一个提交，他的流程就像下面这幅图一样： git_revert_picture_2 1.首先打开Log，找到功能3的提交，右键选择复制哈希码(Copy Revision Number)，如下图所示： Copy Revision Number 2.打开Android Studio的终端Terminal，他就在Version Control的旁边，之后输入以下命令按回车键：1git revert 9c834d8c66598fb132a0cc8e4c1f8c341d058f3e 那一段很复杂的数字字母就是我们刚才复制的哈希码 如下图所示： git revert on terminal 3.之后终端会列出此次提交的具体信息，如果确认要回退，请输入:q保存此次操作并且退出会话现在你可以看到，他确实增加了一次提交，并且回到了上一版的内容，Log应该是这样的： log after revert Git reset相比之下，Git reset就要干脆的多，与Git revert的功能一样，它也可以将代码恢复到上一个版本，但是不会新增一次提交，他的流程如下： git_reset_picture_3 因为我们需要删除功能3，并且让Log看起来并没有revert的这一次提交，所以我们应该在dev分支上后退两步，确实是这样的对吧！ 1.点击菜单栏上的VCS--&gt;Git--&gt;Reset HEAD，打开对话框，在To Commit文本框中输入HEAD~2，就像下图这样： reset HEAD reset HEAD~2 2.点击Reset按钮之后，你可以发现Log变了，变回原来那个熟悉的画面了： log after reset master分支上被修改了突然你发现你的同事在master分支上提交了两次，分别是增加了功能1和功能4，但是其中的功能1很显然HelloWorld被写成了WorldHello，例如这样的：1234567891011121314151617/** * feature-1 * display WorldHello * @param view */ public void feature1(View view) &#123; btn_feature_1.setText(R.string.feature_1_dis); &#125; /** * feature-4 * display Hello * @param view */ public void feature4(View view) &#123; btn_feature_4.setText(R.string.feature_4_dis); &#125; 提交更改，之后Log应该是这样的： log after add feature-1&4 on master 我们依旧用演示图表示当前分支的发展情况： branch_picture_4 Rebase老板说了，master分支只要功能4不需要功能1，而dev分支上的功能1、2全部都要合并到master分支上。那么这个时候我们就可以使用rebase了。git rebase用于把一个分支的修改合并到当前分支。现在我们切换到master分支，将dev上的做修改加入到master中，所以我们选择rebase，在Android Studio中提供了功能十分强大的rebase。 1.点击菜单栏上的VCS–&gt;Git–&gt;Rebase，如下图所示： git rebase 2.在弹出的对话框中，我们在Onto的下拉栏中选中dev分支，表示我们需要将master分支rebase到该分支下。 git rebase branch 3.点击Rebase之后，你会发现Android Studio弹出对话框，显示master分支的两次提交，需要我们做出选择，如下图所示： git start rebasing 4.因为我们不需要master分支上的功能1但是需要功能4，所以在功能1的提交上我们选择skip(跳过这个提交)，在提交4上选择pick(挑选此次这个提交)，点击 Start Rebasing，我们可以看到又有对话框弹出，此次是让我们对每个文件进行挑选，如下图所示： rebase conflict 5.对于每一个文件，你可以选择接受你的那一部分，或者接受另一只分支上的内容，又或者你可以点击Merge对文件进行筛选。我们点击Merge按钮，可以看到有三个文件呈现在屏幕上。其中中间的文件是最后的结果，左边的为当前分支master分支，右边的为dev分支，你还可以发现在修改过的每一行中都存在一个X &gt;&gt;符号，点击X表示不需要这一行的修改，点击&gt;&gt;表示接受这一行的修改，我们甚至还可以像在编辑器中那样复制、粘贴、编辑内容，我们最终作出的选择如下图所示，之后可以点击Apply进行保存，如果你不想保存，那就点击Abort终止此次修改： conflict between files 6.对于剩下的两个文件也做相同的处理，之后我们可以看到master分支已经有了dev分支的功能1和功能2和自身的功能4，并且去掉了自己之前的功能1，可以看一下Log，如下所示： log after rebase 我们依旧使用演示图来表示最后的分支情况： branch_picture_5 推送到远程仓库推送很简单，你可以导航到菜单栏VCS--&gt;Import Into Version Control --&gt;Share Project on Github，如下图所示： push 在弹出的对话框中填写远程仓库的名称，点击Share： share 之后你就可以在你的Github上面看到这一次的推送了。 本地所做的修改如何同步到远程仓库现在我需要在工程中加入一些文件，例如说我新建了一个screenshots文件夹，并在其中添加了这篇文章需要用到的截图，那么如何将这些文件一起同步到远程仓库呢？其实很简单。 1.使用快捷键Alt+9或者点击工具按钮打开Version Control，右键Unversioned Files，选择Git--&gt;Add，将所有文件加入Git中，如下图： add files 2.右键Default，选择Commit所有的文件之后填写提交信息，如下图： commit files 3.使用快捷键Ctrl+Shift+K或者右键工程根目录，选择push项目，如下图所示： push project 4.在弹出的对话框中点击Push按钮，就可以将所做的修改同步到远程仓库了，如下图： push! 5.对于修改过的文件想要同步到远程仓库，按照同样的步骤就行了，这里不再赘述了。 后记这篇文章有点长，图也很多，我也写了很久，有的时候思路不清晰也混了(尴尬脸)，所以难免会有错误，还请大家批评指正，大家互相学习，希望你能够学到更多Android Studio的知识。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://www.wensibo.top/tags/Android-Studio/"},{"name":"Git","slug":"Git","permalink":"http://www.wensibo.top/tags/Git/"}]},{"title":"Android Studio快捷键总结","slug":"Android Studio快捷键总结","date":"2017-03-09T05:30:25.000Z","updated":"2018-10-21T08:26:20.548Z","comments":true,"path":"2017/03/09/Android Studio快捷键总结/","link":"","permalink":"http://www.wensibo.top/2017/03/09/Android Studio快捷键总结/","excerpt":"Android Studio2014年已经正式发布了，但是前几天才更新到2.3的版本，据说很多人升级了之后出现很多不可预见的bug，我还是乖乖守好我的2.2.3，之篇文章我和大家一起分享在使用Android Studio过程中经常会用到的以及许多能够提高效率但是我个人不经常用的快捷键，需要注意的是我只介绍Windows操作环境下的快捷键，理论上来说Windows与Linux用户在快捷键上是相同的，但是Mac用户就会比较特殊，毕竟有钱人都比较特殊对吧😜，我一个穷屌丝就暂时下不了微软大哥的船了。对了，我还会用粗体的形式标出经常会使用到的快捷键，很多时候你会觉得背这些快捷键确实是一件很烦人的事情，但是最好是实践出真知，不要硬性背，或许能够有更好的效果。","text":"Android Studio2014年已经正式发布了，但是前几天才更新到2.3的版本，据说很多人升级了之后出现很多不可预见的bug，我还是乖乖守好我的2.2.3，之篇文章我和大家一起分享在使用Android Studio过程中经常会用到的以及许多能够提高效率但是我个人不经常用的快捷键，需要注意的是我只介绍Windows操作环境下的快捷键，理论上来说Windows与Linux用户在快捷键上是相同的，但是Mac用户就会比较特殊，毕竟有钱人都比较特殊对吧😜，我一个穷屌丝就暂时下不了微软大哥的船了。对了，我还会用粗体的形式标出经常会使用到的快捷键，很多时候你会觉得背这些快捷键确实是一件很烦人的事情，但是最好是实践出真知，不要硬性背，或许能够有更好的效果。 Windows系统下Android Studio快捷键总结 快捷键,加粗的是经常会使用的 描述 Ctrl+E 打开最近操作的文件 Ctrl+Z 撤销 Ctrl+Shift+Z 重做(在Eclipse中使用的是Ctrl+Y) Ctr+Y 删除该行(Eclipse中的删除该行是Ctrl+D) Ctrl+D 向下复制该行 F11 将鼠标停留的所在行加入书签Bookmarks中，可以使用快捷键Alt+2查看所有的书签以及Favorites和断点BreakPoints Ctrl+Alt+向左/右箭头 遍历你的导航操作(如光标移动、选项卡切换和文件打开) Alt+左右箭头 可以在所有已经打开的文件中左右切换 Alt+数字1、2、3、4、5、6··· 可以打开相对应的工具按钮(分布在Android Studio的左、下、右边边，并且其中一些按钮还有一个对应的小数字)，使用Alt+对应的数字就能打开或者关闭这些按钮了 Ctrl+Shift+V 复制历史记录 Ctrl+Alt+Shift+C 复制方法、变量、或类的逻辑引用，当把此引用粘贴到另一个源文件中时能够自动导入所需的限定符和导入语句 Ctrl+Shift+A 弹出的搜索框中输入你想搜索的内容(Android Studio的具备的特性、功能)，系统会给出结果，这货很有用😊 Alt+F1 出现Select In 对话框，可以进行一些便捷的操作，虽然好用但是还不如用鼠标 Ctrl+N 在弹出的对话框中输入类的名字可以直接打开该类，超赞😊 Ctrl+Shift+N 在弹出的对话框中输入文件的名字可以直接打开该文件，比起上一个能打开的文件更多 Ctrl+G 可以输入想要到达的行数或者行数:列数，文件很长的时候很有用 Ctrl+Alt+Home 可以打开与当前文件相关联的文件，例如打开的MainActivity.java，那么他的相关文件就会是activity_main.xml ,你的同事绝对不知道这一点😜 Ctrl+H 可以查看当前类(只有在java文件中有效)的继承关系，你会发现不出意外的话Alt+8 与其效果是同样的 Ctrl+数字加号 展开光标所在处已折叠的代码块 Ctrl+数字减号 折叠光标所在处已展开的代码块 Ctrl+Shift+数字加号 展开所有已折叠的代码块 Ctrl+Shift+数字减号 折叠所有已展开的代码块 Ctrl+空格 代码提示，但是Windows系统下好像是输入法的切换，如果你还是想使用这个快捷键，要么将其改为Ctrl+3，要么就修改注册表咯。方法1，方法2 Alt+Enter 绝对是用的最多的，可以自动补全当行并且将光标跳到下一行，当新引入一个类但是还没有导入的时候，只需要对着类的名字使用该快捷键就可以自动导入了 Shift+Enter 直接从当前行跳转到下一行，不用将光标置于当前行末尾然后再按回车，十分方便 Alt+/ 同样也是代码提示，不过这个提示只是提供在文件中使用过的单词，向上循环 Alt+Shift+/ 还是代码提示，提示只提供在文件中使用过的单词，向下循环 Ctrl+/ 代码注释，适用于单行，也可以选择多行，用得最多的了，不用我强调的啦 Ctrl+Shift+/ 块注释 Alt+Insert 呼出Generate命令，强烈安利😎 Ctrl+J 插入代码模板，或者如果你记得代码模板的名称，例如fbc，接着是用Ctrl+J，则可以直接插入() findViewById(R.id.) Ctrl+Alt+J 当选择一个单词之后使用该快捷键可以直接呼出模板，选择其中你需要的就行了 Ctrl+Shift+向上箭头/向下箭头 在作用域的范围内上/下移一条或多条语句，如果移动的是代码块，则整个代码块将会一起移动到下一个语法正确的位置 Alt+Shift+向上箭头/向下箭头 将一条或多条语句向上/下移动而不考虑作用范围以及语法是否正确 Ctrl+Alt+I 根据Code Style 中设置的方案，对当前鼠标所在的行或选中的多行进行缩进，保持代码美观很有效 Ctrl+Alt+O 组织导入语句 Ctrl+Alt+L 对文件的代码格式进行重新的整理 Ctrl+Alt+T 选中需要包裹的语句，使用该快捷键可以快速的将其被try catch，if/else，for或者for each 等包裹，用熟了会很方便 Ctrl+Shift+Delete 选中不想被包裹的语句，使用改快捷键可以删除try catch，if/else，for或者for each等代码块 Ctrl+Alt+Shift+T 呼出Refactor This对话框，可以做很多有关重构的事情，四个快捷键可以记住成CAST Shift+F6 重命名该文件 Ctrl+F6 修改方法名以及参数 Ctrl+Shift+F6 类型迁移 F6 移动文件或者移动变量到另一个文件 F5 复制文件或者复制变量到另一个文件 Home 将光标置于当前行的首个字母前 End 将光标置于当前行的末尾 Ctrl+Alt+V 抽取变量(variable) Ctrl+Alt+C 抽取常量(constant) Ctrl+Alt+F 抽取字段(filed) Ctrl+Alt+P 抽取参数(parameter) Ctrl+Alt+M 抽取方法(Method) Ctrl+K Git提交修改 Shift+F10 运行项目 Ctrl+Alt+S 设置 Ctrl+Alt+Shift+S 项目结构设置 如果你有其他经常使用的快捷键而我并没有介绍到的，欢迎你留言补充，大家一起共同进步！","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://www.wensibo.top/tags/Android-Studio/"}]},{"title":"写一个小便签","slug":"写一个小便签","date":"2017-03-08T05:07:25.000Z","updated":"2018-10-21T08:26:21.188Z","comments":true,"path":"2017/03/08/写一个小便签/","link":"","permalink":"http://www.wensibo.top/2017/03/08/写一个小便签/","excerpt":"欢迎访问我的个人博客转发请注明出处：http://www.wensibo.top/2017/03/08/写一个小便签/ 一直想要写一个便签应用，因为我一直在用的是锤子便签和一加便签，觉得体验还是可以的，但是始终觉得自己也是可以做的，这段时间因为有些事情耽误了，项目前几天做好了，一直没有时间上传到github (各位大爷路过给个star呗😉) ，今天趁着有时间顺便写了这篇文章，介绍一下写这个便签时遇到的一些问题，当作是跟大家一起分享吧！","text":"欢迎访问我的个人博客转发请注明出处：http://www.wensibo.top/2017/03/08/写一个小便签/ 一直想要写一个便签应用，因为我一直在用的是锤子便签和一加便签，觉得体验还是可以的，但是始终觉得自己也是可以做的，这段时间因为有些事情耽误了，项目前几天做好了，一直没有时间上传到github (各位大爷路过给个star呗😉) ，今天趁着有时间顺便写了这篇文章，介绍一下写这个便签时遇到的一些问题，当作是跟大家一起分享吧！ 功能 实现最基本的增加、删除、修改便签 便签能够保存到本地 主界面采用Material Design设计风格，相对美观(勿喷) RecyclerView上下滑动可以自动隐藏Toolbar,以及Floating Action Button RecyclerView的Item可以实现如QQ的侧滑效果，可以通过点击删除、置顶进行编辑 可以设置便签为星✨，那么将会在便签界面左边增加一个红色的标志，以提醒用户此便签为重要便签 变迁主界面标有时间，并且按照编辑时间从新到旧进行排列 效果 效果图 Talk is cheap,show me your code 如何在RecyclerView中使用本地Sqlite数据库数据RecyclerView是google在推出Material Design时着重介绍的一个组件，它对传统的ListView已经可以说是完全代替了，功能强大是他的一个最大优点，但是有一点局限的就是我们自定义的RecyclerView必须继承重写 RecyclerView.Adapter 和 RecyclerView.ViewHolder，虽然在里面我们可以随意重写方法，但是可以发现如果我们使用数据库作为数据源，RecyclerView.Adapter是无法支持读取Cursor的，但是开源的力量又再次显现了，直接给上github地址，但是我们这里只需要复用其中的两个文件就行了，容我娓娓道来。 1、添加下面的RecyclerViewCursorAdapter 和 CursorFilter到工程中由于代码太长影响排版，我就直接附上下载链接RecyclerViewCursorAdapterCursorFilter 2、新建自定义的Adapter并且继承RecyclerViewCursorAdapter NoteAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class NoteAdapter extends RecyclerViewCursorAdapter&lt;NoteAdapter.MyNoteViewHolder&gt; &#123; private Context mContext; private RecyclerViewOnItemClickListener mOnItemClickListener; private onSwipeListener mOnSwipeListener; public NoteAdapter(Context context,Cursor cursor,int flags) &#123; super(context,cursor,flags); this.mContext = context; &#125; @Override public MyNoteViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View root = LayoutInflater.from(parent.getContext()).inflate(R.layout.note_row, parent, false); MyNoteViewHolder holder = new MyNoteViewHolder(root); return holder; &#125; @Override public void onBindViewHolder(final MyNoteViewHolder holder, Cursor cursor) &#123; int position = cursor.getPosition(); holder.tv.setText(cursor.getString(cursor.getColumnIndex(NoteDbAdapter.COL_CONTENT))); holder.tv_dateTime.setText(cursor.getString(cursor.getColumnIndex(NoteDbAdapter.COL_DATETIME))); holder.mRowtab.setBackgroundColor(cursor.getInt(cursor.getColumnIndex(NoteDbAdapter.COL_IMPORTANT)) == 1? mContext.getResources().getColor(R.color.colorAccent):mContext.getResources().getColor(android.R.color.white) ); holder.root.setTag(position); holder.tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mOnItemClickListener != null) &#123; mOnItemClickListener.onItemClickListener(view, holder.getAdapterPosition()); &#125; &#125; &#125;); &#125; @Override protected void onContentChanged() &#123; &#125; /** 设置点击事件 */ public void setRecyclerViewOnItemClickListener(RecyclerViewOnItemClickListener onItemClickListener) &#123; this.mOnItemClickListener = onItemClickListener; &#125; public RecyclerViewOnItemClickListener getOnItemClickListener() &#123; return mOnItemClickListener; &#125; /** 点击事件接口 */ public interface RecyclerViewOnItemClickListener &#123; void onItemClickListener(View view, int position); &#125; /** * 内部类Holder */ class MyNoteViewHolder extends RecyclerView.ViewHolder &#123; private TextView tv; private TextView tv_dateTime; private View mRowtab; private Button btnTop; private Button btnDelete; private View root; public MyNoteViewHolder(View root) &#123; super(root); this.root = root; tv = (TextView) root.findViewById(R.id.row_text); tv_dateTime = (TextView) root.findViewById(R.id.tv_note_time); mRowtab = root.findViewById(R.id.row_tab); btnTop = (Button) root.findViewById(R.id.btnTop); btnDelete = (Button) root.findViewById(R.id.btnDelete); &#125; &#125;&#125; 3、在Activity中这样用1234567891011121314151617181920212223242526272829303132333435363738mRecyclerView = (RecyclerView) findViewById(R.id.recycle_notes); mRecyclerView.setLayoutManager(new LinearLayoutManager(this)); mCursor = mNoteDbAdapter.fetchAllNotes(); mNoteAdapter = new NoteAdapter(this, mCursor, 0); Log.d(TAG, \"mCursor的大小为：\" + mCursor.getCount()); //设置点击事件 mNoteAdapter.setRecyclerViewOnItemClickListener(new NoteAdapter.RecyclerViewOnItemClickListener() &#123; @Override public void onItemClickListener(View view, int position) &#123; if (mCursor == null || mCursor.isClosed()) &#123; if (mCursor == null) &#123; Log.d(\"NoteActivity\", \"newCursor is null\"); Toast.makeText(NoteActivity.this, \"newCursor is null\", Toast.LENGTH_SHORT).show(); &#125; else if (mCursor.isClosed())&#123; Log.d(\"NoteActivity\", \"newCursor is closed\"); Toast.makeText(NoteActivity.this, \"newCursor is null\", Toast.LENGTH_SHORT).show(); &#125; &#125; else &#123; mCursor.moveToPosition(position); String content = mCursor.getString(mCursor.getColumnIndex(NoteDbAdapter.COL_CONTENT)); int importtant = mCursor.getInt(mCursor.getColumnIndex(NoteDbAdapter.COL_IMPORTANT)); int id = mCursor.getInt(mCursor.getColumnIndex(NoteDbAdapter.COL_ID)); Log.d(\"NoteActivity\", content + importtant); Note clickNote = new Note(id, content, importtant); Intent intent = new Intent(); intent.setClass(NoteActivity.this, NoteContentActivity.class); Bundle bundle = new Bundle(); bundle.putSerializable(\"note\", clickNote); intent.putExtras(bundle); startActivity(intent); &#125; &#125; &#125;); //设置适配器 mRecyclerView.setAdapter(mNoteAdapter); 如何在RecyclerView上下滑动时隐藏Toolbar和FAB按钮思路很简单，只需要记录RecyclerView向下滑动(手指向上滑动)时移动的距离，超过一定范围时就会调用Toolbar以及Floating Action Button的animate().translationY方法，令其在Y轴方向上移动，当RecyclerView向上滑动(手指向下滑动)时又会反过来回到初始状态，并且当滑动到RecyclerView底部时会强制Toolbar和FAB回到初始状态，上代码。 HidingScrollListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class HidingScrollListener extends RecyclerView.OnScrollListener &#123; private static final int HIDE_THRESHOLD = 20; private int scrolledDistance = 0; private boolean controlsVisible = true; private int mItemSize=0; public HidingScrollListener(int itemSize) &#123; this.mItemSize = itemSize - 1; &#125; /** * * @param recyclerView * @param dx 横向的滚动距离 * @param dy 纵向的滚动距离 * 记录的是两个滚动事件之间的偏移量，而不是总的滚动距离。 */ @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisibleItem = ((LinearLayoutManager) recyclerView.getLayoutManager()).findFirstVisibleItemPosition(); int lastVisibleItem = ((LinearLayoutManager) recyclerView.getLayoutManager()).findLastVisibleItemPosition(); if (firstVisibleItem == 0||lastVisibleItem==mItemSize) &#123; if (!controlsVisible) &#123; onShow(); controlsVisible = true; &#125; &#125;else&#123; //如果总的滚动距离超多了一定值 // （这个值取决于你自己的设定，越大，需要滑动的距离越长才能显示或者隐藏）， // 我们就根据其方向显示或者隐藏Toolbar（dy&gt;0意味着下滚，dy&lt;0意味着上滚）。 if (scrolledDistance &gt; HIDE_THRESHOLD &amp;&amp; controlsVisible) &#123; onHide(); controlsVisible = false; scrolledDistance = 0; &#125; else if (scrolledDistance &lt; -HIDE_THRESHOLD &amp;&amp; !controlsVisible) &#123; onShow(); scrolledDistance = 0; controlsVisible = true; &#125; &#125; //计算出滚动的总距离（deltas相加）， // 但是只在Toolbar隐藏且上滚或者Toolbar未隐藏且下滚的时候 if ((controlsVisible &amp;&amp; dy &gt; 0) || (!controlsVisible &amp;&amp; dy &lt; 0)) &#123; scrolledDistance += dy; &#125; &#125; public abstract void onHide(); public abstract void onShow();&#125; 在Avtivity中使用回掉方法1234567891011121314151617181920212223242526//为recycleview设置滚动监听器 mRecyclerView.setOnScrollListener(new HidingScrollListener(mCursor.getCount()) &#123; @Override public void onHide() &#123; hideView(); &#125; @Override public void onShow() &#123; showView(); &#125; &#125;); private void hideView() &#123; mToolbar.animate().translationY( -mToolbar.getHeight()).setInterpolator(new AccelerateInterpolator(2)); FrameLayout.LayoutParams ip = (FrameLayout.LayoutParams) mFloatingActionButton.getLayoutParams(); int fabButtonMargin = ip.bottomMargin; mFloatingActionButton.animate().translationY( mFloatingActionButton.getHeight() + fabButtonMargin).setInterpolator(new AccelerateInterpolator(2)).start(); &#125; private void showView() &#123; mToolbar.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)); mFloatingActionButton.animate().translationY(0).setInterpolator(new DecelerateInterpolator(2)).start(); &#125; 特别注意布局文件如果你发现你运行的效果像下面的截图一样的话，那你肯定是因为布局文件上少写了这两句12android:clipToPadding=&quot;false&quot;android:paddingTop=&quot;?attr/actionBarSize&quot; bug截图 完整的布局代码如下： main_activity.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycle_notes\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clipToPadding=\"false\" android:paddingTop=\"?attr/actionBarSize\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:clipToPadding=\"false\" app:titleTextColor=\"@android:color/white\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/button_add_note\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|right\" android:layout_marginBottom=\"16dp\" android:layout_marginRight=\"16dp\" android:src=\"@drawable/ic_action_new\" android:elevation=\"15dp\" app:fabSize=\"normal\" app:pressedTranslationZ=\"8dp\" app:rippleColor=\"#ff87eb\" /&gt;&lt;/FrameLayout&gt; 最后来讲讲如何实现仿QQ的侧滑出现删除、指定操作首先得谢谢张旭童 ,他的一个库帮我解决了这个问题，点击这里可以访问他的项目。1、在布局文件中使用com.mcxtzhang.swipemenulib.SwipeMenuLayout布局，在ItemView后添加button表示删除置顶按钮。2、在Adapter中设置打开侧滑菜单，并且可以设置菜单在左还是在右1((SwipeMenuLayout) holder.root.findViewById(R.id.swipeMenuLayout)).setIos(false).setLeftSwipe(false).setSwipeEnable(true); 3、在Activity中设置动作事件1234567891011121314151617181920212223mNoteAdapter.setOnSwipeListener(new NoteAdapter.onSwipeListener() &#123; @Override public void onDel(int pos) &#123; Toast.makeText(NoteActivity.this, \"点击了第\" + (pos+1) + \"条item的删除按钮\", Toast.LENGTH_SHORT).show(); mCursor.moveToPosition(pos); int id = mCursor.getInt(mCursor.getColumnIndex(NoteDbAdapter.COL_ID)); mNoteDbAdapter.deleteNoteById(id); mCursor = mNoteDbAdapter.fetchAllNotes(); mNoteAdapter.changeCursor(mCursor); &#125; @Override public void onTop(int pos) &#123; Toast.makeText(NoteActivity.this, \"点击了第\" + (pos+1) + \"条item的Top按钮\", Toast.LENGTH_SHORT).show(); mCursor.moveToPosition(pos); int id = mCursor.getInt(mCursor.getColumnIndex(NoteDbAdapter.COL_ID)); Note editNote = mNoteDbAdapter.fetchNoteById(id); editNote.setDateTime(DateUtil.formatDateTime()); mNoteDbAdapter.updateNote(editNote); mCursor = mNoteDbAdapter.fetchAllNotes(); mNoteAdapter.changeCursor(mCursor); &#125; &#125;); 大功告成，如果想要看详细代码，或者有什么建议可以到Github上给我发Issue或者直接在站内给我留言哦，记得star哦","categories":[{"name":"项目开发","slug":"项目开发","permalink":"http://www.wensibo.top/categories/项目开发/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/tags/Android/"}]},{"title":"一口一口吃掉Volley（四）","slug":"一口一口吃掉Volley（四）","date":"2017-02-17T11:29:25.000Z","updated":"2018-10-21T08:26:21.492Z","comments":true,"path":"2017/02/17/一口一口吃掉Volley（四）/","link":"","permalink":"http://www.wensibo.top/2017/02/17/一口一口吃掉Volley（四）/","excerpt":"非常感谢你能够坚持看到第四篇，同时这也是这个Volley系列教程的最后一篇了。经过前三节的学习，相信你也已经懂得如何运用Volley提供的Request以及自定义Request了，这一节我将从源码的角度带领大家理解Volley的工作流程。","text":"非常感谢你能够坚持看到第四篇，同时这也是这个Volley系列教程的最后一篇了。经过前三节的学习，相信你也已经懂得如何运用Volley提供的Request以及自定义Request了，这一节我将从源码的角度带领大家理解Volley的工作流程。 从newRequestQueue()看起我们都知道，使用Volley最开始要做的就是使用newRequestQueue()获取一个RequestQueue对象，仔细看一下这个方法 newRequestQueue() 123456789101112131415161718192021222324252627282930313233343536373839public static RequestQueue newRequestQueue(Context context, HttpStack stack, int maxDiskCacheBytes) &#123; File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); String userAgent = \"volley/0\"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0); userAgent = packageName + \"/\" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; stack = new HurlStack(); &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent)); &#125; &#125; Network network = new BasicNetwork(stack); RequestQueue queue; if (maxDiskCacheBytes &lt;= -1) &#123; // No maximum size specified queue = new RequestQueue(new DiskBasedCache(cacheDir), network); &#125; else &#123; // Disk cache size specified queue = new RequestQueue(new DiskBasedCache(cacheDir, maxDiskCacheBytes), network); &#125; queue.start(); return queue; &#125; 在方法内部我们可以看到在api等级大于9的时候，使用HurlStack实例来进行主要的网络请求工作，到这里已经很明显了，Volley底层是使用HttpUrlConnection进行的；而对于小于9的API则创建否则就创建一个HttpClientStack的实例，也就是对于9之前的API使用HttpClient进行网络通讯。最后被包装为一个BasicNetwork对象。接着根据得到的BasicNetwork对象和一个DiskBasedCache对象（磁盘缓存）来构造一个RequestQueue，并且调用了它的start方法来启动这个线程。 接着看start() start() 1234567891011121314public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125; &#125; 首先先创建CacheDispatcher对象，接着进入for循环这个for循环遍历了mCacheDispatcher，这个mCacheDispatcher其实相当于一个线程池，这个线程池的大小默认是4。然后分别让这里面的线程运行起来（调用了它们的start方法）。这里为什么要有多个线程来处理呢？原因很简单，因为我们每一个请求都不一定会马上处理完毕，多个线程进行同时处理的话效率会提高。 所以最终这里会有5个线程，4个是网络线程NetworkDispatcher，1个是缓存线程CacheDispatcher。 得到了RequestQueue之后，我们只需要构建出相应的Request，然后调用RequestQueue的add()方法将Request传入就可以完成网络请求操作了，那就先来看一下add()吧！ add()方法 add() 12345678910111213141516171819202122232425262728293031323334353637383940public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request); &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber()); request.addMarker(\"add-to-queue\"); // If the request is uncacheable, skip the cache queue and go straight to the network. if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; // Insert request into stage if there's already a request with the same cache key in flight. synchronized (mWaitingRequests) &#123; String cacheKey = request.getCacheKey(); if (mWaitingRequests.containsKey(cacheKey)) &#123; // There is already a request in flight. Queue up. Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey); if (stagedRequests == null) &#123; stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;(); &#125; stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) &#123; VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey); &#125; &#125; else &#123; // Insert 'null' queue for this cacheKey, indicating there is now a request in // flight. mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); &#125; return request; &#125; &#125; 可以看到，在第13行的时候会判断当前的请求是否可以缓存，如果不能缓存则在第14行直接将这条请求加入网络请求队列，可以缓存的话则在第36行将这条请求加入缓存队列。在默认情况下，每条请求都是可以缓存的，当然我们也可以调用Request的setShouldCache(false)方法来改变这一默认行为。 那就先来看看NetworkDispatcher的run()吧! run() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Override public void run() &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); Request&lt;?&gt; request; while (true) &#123; long startTimeMs = SystemClock.elapsedRealtime(); // release previous request object to avoid leaking request object when mQueue is drained. request = null; try &#123; // Take a request from the queue. request = mQueue.take(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker(\"network-queue-take\"); // If the request was cancelled already, do not perform the // network request. if (request.isCanceled()) &#123; request.finish(\"network-discard-cancelled\"); continue; &#125; addTrafficStatsTag(request); // Perform the network request. NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(\"network-http-complete\"); // If the server returned 304 AND we delivered a response already, // we're done -- don't deliver a second identical response. if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish(\"not-modified\"); continue; &#125; // Parse the response here on the worker thread. Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(\"network-parse-complete\"); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(\"network-cache-written\"); &#125; // Post the response back. request.markDelivered(); mDelivery.postResponse(request, response); &#125; catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); &#125; catch (Exception e) &#123; VolleyLog.e(e, \"Unhandled exception %s\", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); &#125; &#125; &#125; 第4行设置了这些线程的优先级，这个优先级比较低，目的是为了尽量减少对UI线程的影响保证流畅度。 接着第12行，调用mQueue的take方法取出队列头的一个请求进行处理，这个mQueue就是我们在上面add方法中添加进去的一个请求。 直接看到第34行，如果请求没有被取消，也就是正常的情况下，我们会调用mNetwork的performRequest方法进行请求的处理。不知道你还记的这个mNetwork不，它其实就是我们上面提到的那个由HttpUrlConnection层层包装的网络请求对象。 如果请求得到了结果，我们会看到55行调用了mDelivery的postResponose方法来回传我们的请求结果。 先来看performRequest()因为Network是一个接口，这里具体的实现是BasicNetwork，所以我们可以看到其中重写的performRequest()如下： performRequest() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; Map&lt;String, String&gt; responseHeaders = Collections.emptyMap(); try &#123; // Gather headers. Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); addCacheHeaders(headers, request.getCacheEntry()); httpResponse = mHttpStack.performRequest(request, headers); StatusLine statusLine = httpResponse.getStatusLine(); int statusCode = statusLine.getStatusCode(); responseHeaders = convertHeaders(httpResponse.getAllHeaders()); // Handle cache validation. if (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, null, responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // A HTTP 304 response does not have all header fields. We // have to use the header fields from the cache entry plus // the new ones from the response. // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5 entry.responseHeaders.putAll(responseHeaders); return new NetworkResponse(HttpStatus.SC_NOT_MODIFIED, entry.data, entry.responseHeaders, true, SystemClock.elapsedRealtime() - requestStart); &#125; // Handle moved resources if (statusCode == HttpStatus.SC_MOVED_PERMANENTLY || statusCode == HttpStatus.SC_MOVED_TEMPORARILY) &#123; String newUrl = responseHeaders.get(\"Location\"); request.setRedirectUrl(newUrl); &#125; // Some responses such as 204s do not have content. We must check. if (httpResponse.getEntity() != null) &#123; responseContents = entityToBytes(httpResponse.getEntity()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusLine); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; return new NetworkResponse(statusCode, responseContents, responseHeaders, false, SystemClock.elapsedRealtime() - requestStart); &#125; catch (Exception e) &#123; ··· &#125; &#125; &#125; 这段代码中，先10和11行代码将cache的属性设置给header，接着第12行调用mHttpStack对象的performRequest方法并传入请求对象和头部来进行请求，得到一个HttpResponse对象。 接着将HttpResponse对象中的状态码取出，如果值为HttpStatus.SC_NOT_MODIFIED（也就是304），则表示请求得到的Response没有变化，直接显示缓存内容。 第45行表示请求成功并且获取到请求内容，将内容取出并作为一个NetworkResponse对象的属性并返回给NetworkDispatcher。 在NetworkDispatcher中收到了NetworkResponse这个返回值后又会调用Request的parseNetworkResponse()方法来解析NetworkResponse中的数据，以及将数据写入到缓存，这个方法的实现是交给Request的子类来完成的，因为不同种类的Request解析的方式也肯定不同，这就是为什么我们在自定义Request的时候必须要重写parseNetworkResponse()这个方法的原因了。 在解析完了NetworkResponse中的数据之后，又会调用ExecutorDelivery的postResponse()方法来回调解析出的数据。 接着是postResponse() postResponse() 123456@Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker(\"post-response\"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); &#125; 这里看到第5行调用了mResponsePoster的execute方法并传入了一个ResponseDeliveryRunnable对象，再看mResponsePoster的定义： 123456789public ExecutorDelivery(final Handler handler) &#123; // Make an Executor that just wraps the handler. mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;; &#125; 也就是我们在这里把ResponseDeliveryRunnable对象通过Handler的post方法发送出去了。这里为什么要发送到MainLooper中？因为RequestQueue是在子线程中执行的，回调到的代码也是在子线程中的，如果在回调中修改UI，就会报错。再者，为什么要使用post方法？原因也很简单，因为我们在消息发出之后再进行回调，post方法允许我们传入一个Runnable的实现类，post成功会自动执行它的run方法，这个时候在run方法中进行结果的判断并且进行回调： run() 12345678910111213141516171819202122232425262728 @Override public void run() &#123; // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish(\"canceled-at-delivery\"); return; &#125; // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we're done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker(\"intermediate-response\"); &#125; else &#123; mRequest.finish(\"done\"); &#125; // If we have been provided a post-delivery runnable, run it. if (mRunnable != null) &#123; mRunnable.run(); &#125;&#125; 可以看到，11行是调用Request的deleverResponse方法将结果回调给Request。举例看一下StringRequest中该方法是如何实现的： deliverResponse() 123456@Override protected void deliverResponse(String response) &#123; if (mListener != null) &#123; mListener.onResponse(response); &#125; &#125; 直接通过我们构造StringRequest时传进来的Listener的回调方法onResponse来将结果回调给Activity。deleverError也是同样的做法。 看完网络线程NetworkDispatcher之后再来看一下缓存线程CacheDispatcher是如何工作的 最后来看CacheDispatcher的run()方法 run() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Overridepublic void run() &#123; if (DEBUG) VolleyLog.v(\"start new dispatcher\"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. mCache.initialize(); Request&lt;?&gt; request; while (true) &#123; // release previous request object to avoid leaking request object when mQueue is drained. request = null; try &#123; // Take a request from the queue. request = mCacheQueue.take(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; return; &#125; continue; &#125; try &#123; request.addMarker(\"cache-queue-take\"); // If the request has been canceled, don't bother dispatching it. if (request.isCanceled()) &#123; request.finish(\"cache-discard-canceled\"); continue; &#125; // Attempt to retrieve this item from cache. Cache.Entry entry = mCache.get(request.getCacheKey()); if (entry == null) &#123; request.addMarker(\"cache-miss\"); // Cache miss; send off to the network dispatcher. mNetworkQueue.put(request); continue; &#125; // If it is completely expired, just send it to the network. if (entry.isExpired()) &#123; request.addMarker(\"cache-hit-expired\"); request.setCacheEntry(entry); mNetworkQueue.put(request); continue; &#125; // We have a cache hit; parse its data for delivery back to the request. request.addMarker(\"cache-hit\"); Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(\"cache-hit-parsed\"); if (!entry.refreshNeeded()) &#123; // Completely unexpired cache hit. Just deliver the response. mDelivery.postResponse(request, response); &#125; else &#123; // Soft-expired cache hit. We can deliver the cached response, // but we need to also send the request to the network for // refreshing. request.addMarker(\"cache-hit-refresh-needed\"); request.setCacheEntry(entry); // Mark the response as intermediate. response.intermediate = true; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. final Request&lt;?&gt; finalRequest = request; mDelivery.postResponse(request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(finalRequest); &#125; catch (InterruptedException e) &#123; // Not much we can do about this. &#125; &#125; &#125;); &#125; &#125; catch (Exception e) &#123; VolleyLog.e(e, \"Unhandled exception %s\", e.toString()); &#125; &#125;&#125; 首先在10行可以看到一个while(true)循环，说明缓存线程始终是在运行的，接着在第33行会尝试从缓存当中取出响应结果，如何为空的话则把这条请求加入到网络请求队列中，如果不为空的话再判断该缓存是否已过期，如果已经过期了则同样把这条请求加入到网络请求队列中，否则就认为不需要重发网络请求，直接使用缓存中的数据即可。 之后会在第39行调用Request的parseNetworkResponse()方法来对数据进行解析，再往后就是将解析出来的数据进行回调了，跟上面的回掉思路是完全一样的！ 至此，我们可以通过通过Volley官方提供的流程图重新回顾一下整个的流程 Volley流程图 其中蓝色部分代表主线程，绿色部分代表缓存线程，橙色部分代表网络线程。我们在主线程中调用RequestQueue的add()方法来添加一条网络请求，这条请求会先被加入到缓存队列当中，如果发现可以找到相应的缓存结果就直接读取缓存并解析，然后回调给主线程。如果在缓存中没有找到结果，则将这条请求加入到网络请求队列中，然后处理发送HTTP请求，解析响应结果，写入缓存，并回调主线程。 希望通过这个系列的文章你能够清晰的掌握和理解Volley，尽管他现在已经不流行了，接下来我会持续为大家讲解比较好的开源框架，TX☺","categories":[{"name":"一口一口吃掉Volley","slug":"一口一口吃掉Volley","permalink":"http://www.wensibo.top/categories/一口一口吃掉Volley/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"http://www.wensibo.top/tags/Volley/"},{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/tags/Android/"}]},{"title":"一口一口吃掉Volley（三）","slug":"一口一口吃掉Volley（三）","date":"2017-02-17T07:23:25.000Z","updated":"2018-10-21T08:26:21.448Z","comments":true,"path":"2017/02/17/一口一口吃掉Volley（三）/","link":"","permalink":"http://www.wensibo.top/2017/02/17/一口一口吃掉Volley（三）/","excerpt":"学习了一口一口吃掉Volley（二）之后，你应该已经学会了如何使用Volley自带的Request，但是有的时候我们需要解析的数据多种多样，例如XML又或者你想使用Google的gson，那么当Volley不能直接提供给我们这些功能的时候就需要我们进行自定义了，第一节我也向大家讲过Volley面向接口编程，使得其很容易扩展，那么这节课我们就一起来学习自定义的Request吧！","text":"学习了一口一口吃掉Volley（二）之后，你应该已经学会了如何使用Volley自带的Request，但是有的时候我们需要解析的数据多种多样，例如XML又或者你想使用Google的gson，那么当Volley不能直接提供给我们这些功能的时候就需要我们进行自定义了，第一节我也向大家讲过Volley面向接口编程，使得其很容易扩展，那么这节课我们就一起来学习自定义的Request吧！ 从StringRequest开始讲讲思路先上最基本的StringRequest源码1234567891011121314151617181920212223242526272829303132333435public class StringRequest extends Request&lt;String&gt;&#123; private final Response.Listener&lt;String&gt; mListener; /** 根据给定的METHOD设置对应的request. */ public StringRequest(int method, String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123; super(method, url, errorListener); mListener = listener; &#125; /** 默认为GET请求的request. */ public StringRequest(String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123; this(Method.GET, url, listener, errorListener); &#125; /** 将HTTP请求结果转换为String. */ @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); &#125; catch (UnsupportedEncodingException e) &#123; parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response)); &#125; /** 将解析的String结果传递给用户的回调接口. */ @Override protected void deliverResponse(String response) &#123; mListener.onResponse(response); &#125;&#125; 我们应该可以提炼出如下几点： StringRequest继承自Request类，并制定其泛型为String，那么当我们自定义XMLRequest时就应该指定类型为XmlPullParser。 有两个构造函数，默认使用的GET请求。 由于Request类中的deliverResponse()和parseNetworkResponse()是两个抽象方法，因此自定义Request中需要对这两个方法进行实现。 deliverResponse()方法中仅仅是调用了mListener中的onResponse()方法，并将response内容传入即可，这样就可以将服务器响应的数据进行回调。 parseNetworkResponse()方法中则是对服务器响应的数据进行解析，其中数据是以字节的形式存放在NetworkResponse的response变量中的，这里将数据取出然后组装成一个String，并传入Response的success()方法中即可。既然知道内部实现的逻辑，那就开始动手吧！ 自定义XMLRequest① 直接上代码啦！按照刚才我们解析StringRequest得到的几点结论，我们应该不难得到XMLRequest：1234567891011121314151617181920212223242526272829303132333435363738public class XMLRequest extends Request&lt;XmlPullParser&gt; &#123; private final Response.Listener&lt;XmlPullParser&gt; mListener; public XMLRequest(int method, String url, Response.Listener&lt;XmlPullParser&gt; listener, Response.ErrorListener errorListener) &#123; super(method, url, errorListener); mListener = listener; &#125; public XMLRequest( String url, Response.Listener&lt;XmlPullParser&gt; listener, Response.ErrorListener errorListener) &#123; this(Method.GET, url, listener, errorListener); &#125; @Override protected Response&lt;XmlPullParser&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; response.headers.put(\"HTTP.CONTENT_TYPE\", \"utf-8\"); String xmlString = new String(response.data,\"utf-8\"); //加上这两行可以解决乱码的问题，尤其是对于中文的xml接口，由于每个xml的编码格式不同，所以获取原编码格式之后再转换为utf-8，即可。 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xmlPullParser.setInput(new StringReader(xmlString)); Log.d(\"SUCCESS\", \"xmlString的内容为\" + xmlString); return Response.success(xmlPullParser, HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (XmlPullParserException e) &#123; return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(XmlPullParser response) &#123; mListener.onResponse(response); &#125;&#125; 这里需要注意的一点我在上一篇文章中也已经提到了，就是在解析数据的时候如果出现乱码应该转换编码为utf-8。 ② 测试接口作为测试，我使用的XML接口是：http://flash.weather.com.cn/wmaps/xml/guangdong.xml ，它返回的是广东省各个城市的天气预报，你也可以将guangdong改为你所在的省份就可以显示其他数据了：1234567891011121314151617181920212223&lt;guangdong dn=\"day\"&gt;&lt;city cityX=\"137.7\" cityY=\"385.95\" cityname=\"湛江\" centername=\"湛江\" fontColor=\"FFFFFF\" pyName=\"zhanjiang\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"23\" tem2=\"16\" temNow=\"24\" windState=\"微风\" windDir=\"东南风\" windPower=\"2级\" humidity=\"50%\" time=\"15:30\" url=\"101281001\"/&gt;&lt;city cityX=\"170.65\" cityY=\"317.55\" cityname=\"茂名\" centername=\"茂名\" fontColor=\"FFFFFF\" pyName=\"maoming\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"26\" tem2=\"14\" temNow=\"26\" windState=\"微风\" windDir=\"西南风\" windPower=\"1级\" humidity=\"47%\" time=\"15:30\" url=\"101282001\"/&gt;&lt;city cityX=\"225\" cityY=\"245\" cityname=\"云浮\" centername=\"云浮\" fontColor=\"FFFFFF\" pyName=\"yunfu\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"26\" tem2=\"13\" temNow=\"26\" windState=\"微风\" windDir=\"东风\" windPower=\"2级\" humidity=\"43%\" time=\"15:30\" url=\"101281401\"/&gt;&lt;city cityX=\"226.55\" cityY=\"304.5\" cityname=\"阳江\" centername=\"阳江\" fontColor=\"FFFFFF\" pyName=\"yangjiang\" state1=\"0\" state2=\"1\" stateDetailed=\"晴转多云\" tem1=\"24\" tem2=\"15\" temNow=\"23\" windState=\"微风\" windDir=\"东南风\" windPower=\"3级\" humidity=\"63%\" time=\"15:30\" url=\"101281801\"/&gt;&lt;city cityX=\"275.35\" cityY=\"214.65\" cityname=\"肇庆\" centername=\"肇庆\" fontColor=\"FFFFFF\" pyName=\"zhaoqing\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"26\" tem2=\"14\" temNow=\"26\" windState=\"微风\" windDir=\"西北风\" windPower=\"1级\" humidity=\"43%\" time=\"15:30\" url=\"101280901\"/&gt;&lt;city cityX=\"291\" cityY=\"285\" cityname=\"江门\" centername=\"江门\" fontColor=\"FFFFFF\" pyName=\"jiangmen\" state1=\"0\" state2=\"0\" stateDetailed=\"晴\" tem1=\"26\" tem2=\"15\" temNow=\"26\" windState=\"微风\" windDir=\"东风\" windPower=\"2级\" humidity=\"38%\" time=\"15:30\" url=\"101281101\"/&gt;&lt;city cityX=\"313.3\" cityY=\"160.45\" cityname=\"清远\" centername=\"清远\" fontColor=\"FFFFFF\" pyName=\"qingyuan\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"25\" tem2=\"15\" temNow=\"26\" windState=\"微风\" windDir=\"南风\" windPower=\"2级\" humidity=\"44%\" time=\"15:30\" url=\"101281301\"/&gt;&lt;city cityX=\"308.7\" cityY=\"225\" cityname=\"佛山\" centername=\"佛山\" fontColor=\"FFFFFF\" pyName=\"foshan\" state1=\"0\" state2=\"1\" stateDetailed=\"晴转多云\" tem1=\"26\" tem2=\"14\" temNow=\"26\" windState=\"微风\" windDir=\"北风\" windPower=\"1级\" humidity=\"42%\" time=\"15:30\" url=\"101280800\"/&gt;&lt;city cityX=\"342.7\" cityY=\"255\" cityname=\"中山\" centername=\"中山\" fontColor=\"FFFFFF\" pyName=\"zhongshan\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"25\" tem2=\"14\" temNow=\"26\" windState=\"微风\" windDir=\"西北风\" windPower=\"2级\" humidity=\"41%\" time=\"15:30\" url=\"101281701\"/&gt;&lt;city cityX=\"340.55\" cityY=\"300\" cityname=\"珠海\" centername=\"珠海\" fontColor=\"FFFFFF\" pyName=\"zhuhai\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"23\" tem2=\"17\" temNow=\"23\" windState=\"微风\" windDir=\"东风\" windPower=\"2级\" humidity=\"48%\" time=\"15:30\" url=\"101280701\"/&gt;&lt;city cityX=\"352.6\" cityY=\"80\" cityname=\"韶关\" centername=\"韶关\" fontColor=\"FFFFFF\" pyName=\"shaoguan\" state1=\"1\" state2=\"1\" stateDetailed=\"多云\" tem1=\"25\" tem2=\"14\" temNow=\"27\" windState=\"微风\" windDir=\"西风\" windPower=\"1级\" humidity=\"34%\" time=\"15:30\" url=\"101280201\"/&gt;&lt;city cityX=\"353\" cityY=\"196\" cityname=\"广州\" centername=\"广州\" fontColor=\"FFFF00\" pyName=\"guangzhou\" state1=\"0\" state2=\"0\" stateDetailed=\"晴\" tem1=\"26\" tem2=\"14\" temNow=\"26\" windState=\"微风\" windDir=\"南风\" windPower=\"1级\" humidity=\"40%\" time=\"15:20\" url=\"101280101\"/&gt;&lt;city cityX=\"377\" cityY=\"234\" cityname=\"东莞\" centername=\"东莞\" fontColor=\"FFFFFF\" pyName=\"dongguan\" state1=\"0\" state2=\"1\" stateDetailed=\"晴转多云\" tem1=\"25\" tem2=\"15\" temNow=\"26\" windState=\"微风\" windDir=\"北风\" windPower=\"1级\" humidity=\"37%\" time=\"15:30\" url=\"101281601\"/&gt;&lt;city cityX=\"409\" cityY=\"257\" cityname=\"深圳\" centername=\"深圳\" fontColor=\"FFFFFF\" pyName=\"shenzhen\" state1=\"0\" state2=\"0\" stateDetailed=\"晴\" tem1=\"24\" tem2=\"15\" temNow=\"24\" windState=\"微风\" windDir=\"南风\" windPower=\"3级\" humidity=\"49%\" time=\"15:30\" url=\"101280601\"/&gt;&lt;city cityX=\"423.85\" cityY=\"214.65\" cityname=\"惠州\" centername=\"惠州\" fontColor=\"FFFFFF\" pyName=\"huizhou\" state1=\"1\" state2=\"0\" stateDetailed=\"多云转晴\" tem1=\"26\" tem2=\"13\" temNow=\"26\" windState=\"微风\" windDir=\"南风\" windPower=\"1级\" humidity=\"38%\" time=\"15:20\" url=\"101280301\"/&gt;&lt;city cityX=\"442.55\" cityY=\"141.6\" cityname=\"河源\" centername=\"河源\" fontColor=\"FFFFFF\" pyName=\"heyuan\" state1=\"0\" state2=\"1\" stateDetailed=\"晴转多云\" tem1=\"25\" tem2=\"15\" temNow=\"27\" windState=\"微风\" windDir=\"西南风\" windPower=\"1级\" humidity=\"37%\" time=\"15:30\" url=\"101281201\"/&gt;&lt;city cityX=\"492\" cityY=\"217\" cityname=\"汕尾\" centername=\"汕尾\" fontColor=\"FFFFFF\" pyName=\"shanwei\" state1=\"1\" state2=\"0\" stateDetailed=\"多云转晴\" tem1=\"24\" tem2=\"14\" temNow=\"24\" windState=\"东南风3-4级转微风\" windDir=\"东风\" windPower=\"2级\" humidity=\"45%\" time=\"15:30\" url=\"101282101\"/&gt;&lt;city cityX=\"522.55\" cityY=\"110.45\" cityname=\"梅州\" centername=\"梅州\" fontColor=\"FFFFFF\" pyName=\"meizhou\" state1=\"1\" state2=\"0\" stateDetailed=\"多云转晴\" tem1=\"27\" tem2=\"12\" temNow=\"26\" windState=\"微风\" windDir=\"东风\" windPower=\"1级\" humidity=\"36%\" time=\"15:30\" url=\"101280401\"/&gt;&lt;city cityX=\"526.8\" cityY=\"182\" cityname=\"揭阳\" centername=\"揭阳\" fontColor=\"FFFFFF\" pyName=\"jieyang\" state1=\"0\" state2=\"0\" stateDetailed=\"晴\" tem1=\"26\" tem2=\"13\" temNow=\"26\" windState=\"微风\" windDir=\"东风\" windPower=\"2级\" humidity=\"34%\" time=\"15:30\" url=\"101281901\"/&gt;&lt;city cityX=\"579\" cityY=\"137.45\" cityname=\"潮州\" centername=\"潮州\" fontColor=\"FFFFFF\" pyName=\"chaozhou\" state1=\"0\" state2=\"0\" stateDetailed=\"晴\" tem1=\"25\" tem2=\"12\" temNow=\"26\" windState=\"微风\" windDir=\"东南风\" windPower=\"2级\" humidity=\"38%\" time=\"15:30\" url=\"101281501\"/&gt;&lt;city cityX=\"566.45\" cityY=\"179.25\" cityname=\"汕头\" centername=\"汕头\" fontColor=\"FFFFFF\" pyName=\"shantou\" state1=\"0\" state2=\"1\" stateDetailed=\"晴转多云\" tem1=\"24\" tem2=\"13\" temNow=\"24\" windState=\"东北风转东风小于3级\" windDir=\"东风\" windPower=\"2级\" humidity=\"54%\" time=\"15:30\" url=\"101280501\"/&gt;&lt;/guangdong&gt; ③ 调用XMLRequest，并加入RequestQueue代码中我将解析XML数据的城市展示在List View中：1234567891011121314151617181920212223242526272829303132333435363738394041XMLRequest xmlRequest = new XMLRequest( \"http://flash.weather.com.cn/wmaps/xml/guangdong.xml\", new Response.Listener&lt;XmlPullParser&gt;() &#123; @Override public void onResponse(XmlPullParser response) &#123; try &#123; int eventType = response.getEventType(); while (eventType != XmlPullParser.END_DOCUMENT) &#123; switch (eventType) &#123; case XmlPullParser.START_TAG: String nodeName = response.getName(); if (\"city\".equals(nodeName)) &#123; String pname = response.getAttributeValue(2); Log.d(\"CITY\", \"PName is\" + pname); citys.add(pname); &#125; break; &#125; eventType = response.next(); &#125; ArrayAdapter&lt;String&gt; arrayAdapter = new ArrayAdapter&lt;String&gt;(XMLRequestActivity.this, android.R.layout.simple_list_item_1, citys); lv_xml_request.setAdapter(arrayAdapter); &#125; catch (XmlPullParserException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; lv_xml_request.setVisibility(View.GONE); mTextView.setVisibility(View.VISIBLE); Log.d(\"ERROR\", \"返回XMLRequest失败\"); &#125; &#125; ); mQueue.add(xmlRequest); &#125; 人品爆发，看截图 XMLRequest 自定义GsonRequest虽然Volley提供了JsonRequest为我们解析Json，但是使用JSONObject还是太麻烦了，还有很多方法可以让JSON数据解析变得更加简单，比如说GSON，所以何不如自定义一个GsonRequest呢？思路也是大同小异！ ① 直接上代码啦！12345678910111213141516171819202122232425262728293031323334353637public class GsonRequest&lt;T&gt; extends Request&lt;T&gt; &#123; private final Response.Listener&lt;T&gt; mListener; private Gson mGson; private Class&lt;T&gt; mClazz; public GsonRequest(int method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener) &#123; super(method, url, errorListener); mGson = new Gson(); mClazz = clazz; mListener = listener; &#125; public GsonRequest(String url, Class&lt;T&gt; clazz, Response.Listener&lt;T&gt; listener, Response.ErrorListener errorListener) &#123; this(Method.GET, url, clazz, listener, errorListener); &#125; @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) &#123; try &#123; response.headers.put(\"HTTP.CONTENT_TYPE\", \"utf-8\"); String jsonString = new String(response.data,\"utf-8\"); //加上这两行可以解决乱码的问题，尤其是对于中文的json接口，由于每个网页的编码格式不同，所以获取原编码格式之后再转换为utf-8，即可。 return Response.success(mGson.fromJson(jsonString, mClazz), HttpHeaderParser.parseCacheHeaders(response) ); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; &#125; @Override protected void deliverResponse(T response) &#123; mListener.onResponse(response); &#125;&#125; 同样需要注意编码的问题。在parseNetworkResponse()方法中，先是将服务器响应的数据解析出来，然后通过调用Gson的fromJson方法将数据组装成对象。在deliverResponse方法中仍然是将最终的数据进行回调。 记得为工程加入gson库 1compile &apos;com.google.code.gson:gson:2.8.0&apos; ② json接口使用之前使用的json接口：http://www.weather.com.cn/data/sk/101010100.html ，它返回的数据是一个叫做weatherinfo的jsonObject：1&#123;&quot;weatherinfo&quot;:&#123;&quot;city&quot;:&quot;北京&quot;,&quot;cityid&quot;:&quot;101010100&quot;,&quot;temp&quot;:&quot;19&quot;,&quot;WD&quot;:&quot;南风&quot;,&quot;WS&quot;:&quot;2级&quot;,&quot;SD&quot;:&quot;43%&quot;,&quot;WSE&quot;:&quot;2&quot;,&quot;time&quot;:&quot;19:45&quot;,&quot;isRadar&quot;:&quot;1&quot;,&quot;Radar&quot;:&quot;JC_RADAR_AZ9010_JB&quot;&#125;&#125; ③ 新建bean类由于返回的jsonObject名字叫做weatherinfo，所以我们新建一个WeatherInfo类，定义了几个最基本的属性就行了：1234567891011121314151617181920212223242526272829public class WeatherInfo&#123; private String city; private String temp; private String time; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getTemp() &#123; return temp; &#125; public void setTemp(String temp) &#123; this.temp = temp; &#125; public String gettime() &#123; return time; &#125; public void settime(String time) &#123; this.time = time; &#125;&#125; 另外还需要再定义一个Weather类，来获取WeatherInfo对象：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Weather &#123; //此处的weatherinfo不可以修改为weatherInfo，因为从json获取的数据格式为 // &#123;\"weatherinfo\":&#123;\"city\":\"北京\",\"cityid\":\"101010100\",\"temp\":\"19\",\"WD\":\"南风\",\"WS\":\"2级\",\"SD\":\"43%\",\"WSE\":\"2\",\"time\":\"19:45\",\"isRadar\":\"1\",\"Radar\":\"JC_RADAR_AZ9010_JB\"&#125;&#125; private WeatherInfo weatherinfo; public WeatherInfo getWeatherInfo() &#123; return weatherinfo; &#125; public void setWeatherInfo(WeatherInfo weatherinfo) &#123; this.weatherinfo = weatherinfo; &#125;&#125;``` &gt;**此处的weatherinfo不可以修改为weatherInfo****④调用GsonRequest** 我们将获取的数据显示在Text View上就行了。```javaGsonRequest&lt;Weather&gt; gsonRequest=new GsonRequest&lt;Weather&gt;(\"http://www.weather.com.cn/data/sk/101010100.html\" , Weather.class, new Response.Listener&lt;Weather&gt;() &#123; @Override public void onResponse(Weather weather) &#123; WeatherInfo weatherInfo = weather.getWeatherInfo(); if (weatherInfo != null) &#123; StringBuffer str = new StringBuffer(); str.append(\"城市：\" + weatherInfo.getCity() + \"\\n\"); str.append(\"温度：\" + weatherInfo.getTemp() + \"\\n\"); str.append(\"时间：\" + weatherInfo.gettime()); tv_gson_request.setText(str); Log.d(\"SUCCESS\", \"成功返回GsonRequest \" + str.toString()); &#125; else &#123; Log.d(\"ERROR\", \"weatherinfo对象为空\"); &#125; &#125; &#125; , new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.d(\"ERROR\", \"返回GsonRequest失败\"); tv_gson_request.setText(getResources().getString(R.string.error_message)); &#125; &#125; );mQueue.add(gsonRequest); 看截图啦！ GsonRequest 这一节只是向大家介绍了如何自定义Request，其实都是大同小异的，例如你觉得Gson不能满足你，那你也可以改为FastJson或者其他的功能，但是请一定要注意编码问题！最后一节我们将一起通过阅读源码来分析Volley的工作流程！","categories":[{"name":"一口一口吃掉Volley","slug":"一口一口吃掉Volley","permalink":"http://www.wensibo.top/categories/一口一口吃掉Volley/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"http://www.wensibo.top/tags/Volley/"},{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/tags/Android/"}]},{"title":"一口一口吃掉Volley（二）","slug":"一口一口吃掉Volley（二）","date":"2017-02-17T05:37:25.000Z","updated":"2018-10-21T08:26:21.408Z","comments":true,"path":"2017/02/17/一口一口吃掉Volley（二）/","link":"","permalink":"http://www.wensibo.top/2017/02/17/一口一口吃掉Volley（二）/","excerpt":"相信看了第一篇教程之后，你应该会对Volley有一个初步的了解了吧，那接下来就继续学习如何使用Volley进行开发吧！","text":"相信看了第一篇教程之后，你应该会对Volley有一个初步的了解了吧，那接下来就继续学习如何使用Volley进行开发吧！ 配置Gradle使用如下命令导入Volley库：1compile &apos;com.mcxiaoke.volley:library:1.0.19&apos; 如果你还是使用Eclipse进行开发的话，可以下载volley的jar包导入工程。 添加联网许可在AndroidManifest.xml文件中添加联网的请求1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 使用StringRequest如果你需要通过网络访问的资源属于String字符串的资源，那么使用StringRequest就最为简单了，只需按照如下步骤就行了。 ① 获取一个RequestQueue1RequestQueue mQueue = Volley.newRequestQueue(this); ② 构造一个StringRequest对象1234567891011121314151617181920212223242526272829StringRequest stringRequest=new StringRequest(\"http://www.wensibo.top\" , new Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; //正常情况下的逻辑处理 String result=\"\"; try &#123; result= new String(response.getBytes(\"ISO_8859_1\"), \"utf-8\"); //由于访问string的时候可能会出现乱码情况，所以保险起见，可以将其转换为utf-8格式 //对于其他的自定义Requet都是同理的，均需要在重写parseNetworkResponse方法时设置编码格式，避免乱码的出现 &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; Intent intent = new Intent(); intent.setClass(MainActivity.this, StringRequestActivity.class); intent.putExtra(\"string_request\", result); startActivity(intent); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; //出错的时候做的一些处理 Intent intent = new Intent(); intent.setClass(MainActivity.this, StringRequestActivity.class); intent.putExtra(\"string_request\", getResources().getString(R.string.error_message)); startActivity(intent); &#125; &#125; ); 由于不同的网页的编码格式不同，为了防止中文乱码情况的出现，代码中将其设置为utf-8即可得到解决。其他的Request如果要避免乱码的出现，也应该采取类似的方法进行处理。 ③ 将StringRequest对象add进RequestQueue1mQueue.add(stringRequest); 看看截图 StringRequest 使用JsonRequest有的时候我们不仅需要简单的String资源，还需要获取Json数据，当然Volley也帮我们提供了获取Json的接口，这个就是JsonRequest，使用JsonRequest与StringRequest类似。这里作为例子接收的是北京的天气预报的json对象，获取到的json对象直接打印出来，当然我们还可以获取里面的内容，我将会在自定义的GsonRequest中作介绍。 ① 获取一个RequestQueue1RequestQueue mQueue = Volley.newRequestQueue(this); ② 构造一个JsonRequest对象1234567891011121314151617181920JsonObjectRequest jsonObjectRequest=new JsonObjectRequest(\"http://www.weather.com.cn/data/cityinfo/101010100.html\" , new Response.Listener&lt;JSONObject&gt;() &#123; @Override public void onResponse(JSONObject response) &#123; Log.d(\"JsonObject\", response.toString()); Intent intent = new Intent(); intent.setClass(MainActivity.this, JsonRequestActivity.class); intent.putExtra(\"json_request\", response.toString()); startActivity(intent); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); Intent intent = new Intent(); intent.setClass(MainActivity.this, JsonRequestActivity.class); intent.putExtra(\"json_request\", getResources().getString(R.string.error_message)); startActivity(intent); &#125; &#125;); ③ 将JsonRequest对象add进RequestQueue1mQueue.add(jsonObjectRequest); 看看截图 JsonRequest 使用ImageRequest获取网络上的图片资源是一个很普通的需求，虽然Volley有这个功能，但是放到现在来看都已不是什么稀奇事了，而且功能比较单一，所以这里就简单介绍一下。 ① 获取一个RequestQueue1RequestQueue mQueue = Volley.newRequestQueue(this); ② 构造一个ImageRequest对象123456789101112131415ImageRequest imageRequest=new ImageRequest(\"http://wensibo.top/img/avatar.jpg\" , new Response.Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; Log.d(\"SUCCESS\", \"成功返回ImageRequest\"); iv_image_request.setImageBitmap(response); &#125; &#125;, 0, 0, Bitmap.Config.RGB_565, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.d(\"ERROR\", \"返回ImageRequest失败\"); iv_image_request.setImageResource(R.drawable.failed_image); &#125; &#125; ); 可以看到，ImageRequest的构造函数接收六个参数，第一个参数就是图片的URL地址，这个没什么需要解释的。第二个参数是图片请求成功的回调，这里我们把返回的Bitmap参数设置到ImageView中。第三第四个参数分别用于指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定成0的话就表示不管图片有多大，都不会进行压缩。第五个参数用于指定图片的颜色属性，Bitmap.Config下的几个常量都可以在这里使用，其中ARGB_8888可以展示最好的颜色属性，每个图片像素占据4个字节的大小，而RGB_565则表示每个图片像素占据2个字节大小。第六个参数是图片请求失败的回调，这里我们当请求失败时在ImageView中显示一张默认图片。 ③ 将JsonRequest对象add进RequestQueue1mQueue.add(jsonObjectRequest); 看看截图 ImageRequest加载成功 ImageRequest加载失败 使用ImageLoaderVolley在请求网络图片方面除了ImageRequest之外，还有另外一个更加高效的ImageLoader。ImageLoader用于加载网络上的图片，并且它的内部也是使用ImageRequest来实现的，不过ImageLoader明显要比ImageRequest更加高效，因为它不仅可以帮我们对图片进行缓存，还可以过滤掉重复的链接，避免重复发送请求。由于ImageLoader已经不是继承自Request的了，所以它的用法也和我们之前学到的内容有所不同，总结起来大致可以分为以下四步： ① 获取一个RequestQueue1RequestQueue mQueue = Volley.newRequestQueue(this); ② 构造一个ImageLoader对象123456789ImageLoader imageLoader = new ImageLoader(mQueue, new ImageCache() &#123; @Override public void putBitmap(String url, Bitmap bitmap) &#123; &#125; @Override public Bitmap getBitmap(String url) &#123; return null; &#125; ); ImageLoader的构造函数接收两个参数，第一个参数就是RequestQueue对象，第二个参数是一个ImageCache对象，这里我们先new出一个空的ImageCache的实现即可。具体的ImageCache待会讲解。 ③构造一个ImageListener对象1ImageListener listener = imageLoader.getImageListener(iv_image_loader, R.drawable.failed_image, R.drawable.failed_image); getImageListener()方法接收三个参数，第一个参数指定用于显示图片的ImageView控件，第二个参数指定加载图片的过程中显示的图片，第三个参数指定加载图片失败的情况下显示的图片。 ④调用ImageLoader的get()方法加载网络上的图片1imageLoader.get(\"http://wensibo.top/img/avatar.jpg\", listener); 最后，调用ImageLoader的get()方法来加载图片，get()方法接收两个参数，第一个参数就是图片的URL地址，第二个参数则是刚刚获取到的ImageListener对象。当然，如果你想对图片的大小进行限制，也可以使用get()方法的重载，指定图片允许的最大宽度和高度，如下所示： 1imageLoader.get(\"http://wensibo.top/img/avatar.jpg\", listener,200,200); 关于ImageCache刚才讲到ImageLoader的构造函数的第二个参数是一个ImageCache对象，刚才介绍的ImageLoader的优点也在于此。他能起到图片缓存的作用。接下来我们就自己写一个呗！这里我们新建一个BitmapCache并实现了ImageCache接口：1234567891011121314151617181920212223242526public class BitmapCache implements ImageCache&#123; private LruCache&lt;String, Bitmap&gt; mCache; public BitmapCache() &#123; //将缓存图片的大小设置为8M int maxSize = 8 * 1024 * 1024; mCache = new LruCache&lt;String, Bitmap&gt;(maxSize)&#123; @Override protected int sizeOf(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight(); &#125; &#125;; &#125; @Override public Bitmap getBitmap(String url) &#123; return mCache.get(url); &#125; @Override public void putBitmap(String url, Bitmap bitmap) &#123; mCache.put(url, bitmap); &#125;&#125; 这里我们将缓存图片的大小设置为8M。接着修改创建ImageLoader实例的代码，第二个参数传入BitmapCache的实例： 1ImageLoader imageLoader = new ImageLoader(mQueue, new BitmapCache()); 看看效果吧！ ImageLoader 下节课我们将一起自定义Request来满足我们的使用！come on ！","categories":[{"name":"一口一口吃掉Volley","slug":"一口一口吃掉Volley","permalink":"http://www.wensibo.top/categories/一口一口吃掉Volley/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"http://www.wensibo.top/tags/Volley/"},{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/tags/Android/"}]},{"title":"一口一口吃掉Volley（一）","slug":"一口一口吃掉Volley（一）","date":"2017-02-16T14:14:25.000Z","updated":"2018-10-21T08:26:21.520Z","comments":true,"path":"2017/02/16/一口一口吃掉Volley（一）/","link":"","permalink":"http://www.wensibo.top/2017/02/16/一口一口吃掉Volley（一）/","excerpt":"本次编写的Volley教程现在看来其实已经跟不上时代了，但是技术总有它光辉的一面。所以想和大家一起通过源码解析的方式学习优秀开源项目的精髓。本次教程将先会和大家一起了解一下Volley的前世今生，摸清他的底细之后再学会如何使用，我已经做好一个Volley的Sample了，欢迎你star或者fork，最后才从源码的角度上来分析Volley的工作流程。","text":"本次编写的Volley教程现在看来其实已经跟不上时代了，但是技术总有它光辉的一面。所以想和大家一起通过源码解析的方式学习优秀开源项目的精髓。本次教程将先会和大家一起了解一下Volley的前世今生，摸清他的底细之后再学会如何使用，我已经做好一个Volley的Sample了，欢迎你star或者fork，最后才从源码的角度上来分析Volley的工作流程。网上关于Volley的文章很多，但是反复看了很久，值得推荐的依旧是郭霖的文章，写的真心不错。我也借鉴了他的很多思路，不过也做了修改，希望大家一起学习。 Android Volley完全解析(一)，初识Volley的基本用法Android Volley完全解析(二)，使用Volley加载网络图片Android Volley完全解析(三)，定制自己的Request Android Volley完全解析(四)，带你从源码的角度理解VolleyAndroid官方Volley教程（英文好的同学可以自学）Volley的Github主页 瞧瞧Volley是何物Volley简介Google在2013年的I/O大会上(是的今年的IO大会很快就会发布android8.0了)正式发布了Volley，google官方称Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮。Volley名称的由来是：12a burst or emission of many things or a large amount at once.突然或大量的东西或大量的一次。 别想歪了哦😏，所以顾名思义，Volley特别适合数据量不大但是通信频繁的场景。 Volley的用武之地Volley可是说是把AsyncHttpClient和Universal-Image-Loader的优点集于了一身，既可以像AsyncHttpClient一样非常简单地进行HTTP通信，也可以像Universal-Image-Loader一样轻松加载网络上的图片。除了简单易用之外，Volley在性能方面也进行了大幅度的调整，它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。 Volley提供给我们的功能 Json，图像等异步下载 网络请求的排序（scheduling） 网络请求的优先级处理 缓存 多级别取消请求 和 Activity 的生命周期联动（Activity 结束时同时取消所有网络请求） Volley的优点 非常适合进行数据量不大，但通信频繁的网络操作 可直接在主线程调用服务端并处理返回结果（这一点可以很方便的更新UI） 可以取消请求，容易扩展，面向接口编程 网络请求线程NetworkDispatcher默认开启了4个和1个CacheDispatcher总共5个线程 通过使用标准的HTTP缓存机制保持磁盘和内存响应的一致 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现 Volley的缺点 使用的是httpclient、HttpURLConnection 6.0不支持httpclient了，如果想支持得添加org.apache.http.legacy.jar 对大文件下载 Volley的表现非常糟糕 只支持http请求 图片加载性能一般 最重要的一点就是现在已经过时了，已经有其他诸如okhttp等优秀开源框架可以代替 最后先给大家看一下最终程序的运行效果 Volley程序截图 下节课我们讲一起编写一个小程序来实现Volley的一些基本功能，see u ^_+","categories":[{"name":"一口一口吃掉Volley","slug":"一口一口吃掉Volley","permalink":"http://www.wensibo.top/categories/一口一口吃掉Volley/"}],"tags":[{"name":"Volley","slug":"Volley","permalink":"http://www.wensibo.top/tags/Volley/"},{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/tags/Android/"}]},{"title":"一口一口吃掉Hexo（六）【已修复问题】","slug":"一口一口吃掉Hexo（六）【已修复问题】","date":"2017-01-13T06:52:04.000Z","updated":"2018-10-21T08:26:21.248Z","comments":true,"path":"2017/01/13/一口一口吃掉Hexo（六）【已修复问题】/","link":"","permalink":"http://www.wensibo.top/2017/01/13/一口一口吃掉Hexo（六）【已修复问题】/","excerpt":"不知不觉已经更新到了最后一节了，很开心你能看到这一节，相信你也已经在你的虚拟主机上成功部署了你的网站，但是可能总会遇到一些问题，也想让你的网站变得更好，这一节，我将与你分享一些解决错误的方法以及如何提高你网站的访问速度。一起来吧！本篇文章已经得到更新，我已经将Hexo配置404页面的问题以及部署到Nginx的问题得到了解决，你可以点击这里/)查看详细的更新","text":"不知不觉已经更新到了最后一节了，很开心你能看到这一节，相信你也已经在你的虚拟主机上成功部署了你的网站，但是可能总会遇到一些问题，也想让你的网站变得更好，这一节，我将与你分享一些解决错误的方法以及如何提高你网站的访问速度。一起来吧！本篇文章已经得到更新，我已经将Hexo配置404页面的问题以及部署到Nginx的问题得到了解决，你可以点击这里/)查看详细的更新 请详细观看这份文档如果你是使用Indigo主题的，，那么最重要的就是这份文档了，里面列出了许多你可能会遇到的问题，如果这里没有列出，或者这里的回答满足不了你，请给作者发Issue，或者你也可以站内留言 提高网站的访问速度最开始的时候网站的访问速度出奇的慢，在控制台观察知道是头像加载的时候拖慢了速度，要知道我的头像只有300K，无奈只能压缩图片大小了，推荐这个在线压缩图片的网站，把头像压缩成了20K，这下加载就不会龟速了。 推广你的网站网站推广其实质就是SEO(搜索引擎优化)，提高你网站在网络的可见度，那么可以通过很多方式去增加网站的访问量。 向搜索引擎提交你的网站地址。这是至关重要的，也是十分有效的。 如果你有访问量比较客观的网络工具，例如我的博客园博客，可以在上面增加你网站的外链，吸引用户来访问你的网站。 在社交工具上分享你的网站内容，并附上你的链接。 优化好你的网站，这个是核心，搜索引擎只有觉得你的网站是面向用户的才会给你加分。如果你能做到以上列出的4点，相信你的网站访问量会很可观，当然我也在持续努力中。 后记本次系列教程到这里就结束啦，如果你对Hexo建站有什么问题或者对我的教程有任何的建议，请你联系我，让我们一起分享吧！","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"一口一口吃掉Hexo（五）【有更新】","slug":"一口一口吃掉Hexo（五）【有更新】","date":"2017-01-13T03:56:15.000Z","updated":"2018-10-21T08:26:21.348Z","comments":true,"path":"2017/01/13/一口一口吃掉Hexo（五）【有更新】/","link":"","permalink":"http://www.wensibo.top/2017/01/13/一口一口吃掉Hexo（五）【有更新】/","excerpt":"通过前四节的内容，相信你已经能够在你的虚拟主机上成功部署网站，并且能够通过你自己的域名访问你的网站了，接下来要做的就是日常管理你的文章了。包括如何新建一篇文章，删除文章以及修改文章当然还有同步到Github啦，一起来吧！","text":"通过前四节的内容，相信你已经能够在你的虚拟主机上成功部署网站，并且能够通过你自己的域名访问你的网站了，接下来要做的就是日常管理你的文章了。包括如何新建一篇文章，删除文章以及修改文章当然还有同步到Github啦，一起来吧！ 在虚拟主机中管理文章新建一篇文章使用如下命令你可以新建一篇文章123hexo new &lt;title&gt;例如hexo new 第一篇文章 当然你也可以直接在blog\\source\\_posts目录下直接新建一个yourtitle.md文件，这样就算是新建了一篇文章，但是这样创建的文章需要在最上方添加如下说明：1234567title: hello worlddate: 2017-01-12 20:37:15tags:- hello world- hellocategories: [first]--- 请注意hexo的格式比较严格，必须要在属性后面的冒号之后紧跟一个空格，后面跟内容。 如果是标签的话，在 - 后紧跟一个空格，再填写标签内容。 如果有多个标签，可以换行以此按照原来的格式继续填写。 分类的话，我尝试了多次，只有再添加一个分类的时候才能正常显示，如果你想在一片文章中添加多个分类的话，好像是会有如下图所示的问题的，当然我觉得每篇文章属于一个分类就够了吧！ 多categories异常 如果想要显示文章的摘要，那就这样写，需要说明的是，摘要也会出现在文章的详细页面中，你可以看看我的文章 。123这里写摘要，但是在文章详细页面同样也是会出现的！&lt;!--more--&gt;这里写正文 删除一篇文章hexo似乎没有专门的命令来删除一篇文章吧，删除的手法也很简单，就是在blog\\source\\_posts目录下直接删除指定文章，刷新一下你的网站就可以看到变化了。 修改一篇文章文章的修改应该是很频繁的吧，其实就是打开你想修改的文件，直接在里面修改保存，但是这样似乎见不到效果，很多时候你刷新一下页面只能见到如下情况： NoTitle 如果真的遇到了，最粗暴的方法就是在git上使用上按住键盘Ctrl+C关闭服务器，之后再使用 hexo s 开启服务器，就可以看到变化了。 开始将文章发布到你的网站 每一次修改完文章，包括你删除文章，都需要使用如下命令将生成新的静态页面，这些页面将会存放在blog/public文件夹下，所以每一次都需要将这个文件夹直接拷贝到nginx/html文件夹下，这样才能保证每一次你发布的文章能够及时的更新。 1hexo g 同步你的文章内容到Github很多时候，为了以防服务器遭受不测，避免你话费许久写好的文章不翼而飞，就备份到Github中的 yourname.github.io 项目吧！首先先试用下面的命令生成本地静态文件123hexo g或者hexo generate 接着使用deploy命令部署同步到github123hexo d或者hexo deploy 我不会告诉你使用下面的命令可以一步到位1hexo g -d","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"一口一口吃掉Hexo（四）【更新了错误】","slug":"一口一口吃掉Hexo（四）【更新了错误】","date":"2017-01-12T13:56:15.000Z","updated":"2018-10-21T08:26:21.316Z","comments":true,"path":"2017/01/12/一口一口吃掉Hexo（四）【更新了错误】/","link":"","permalink":"http://www.wensibo.top/2017/01/12/一口一口吃掉Hexo（四）【更新了错误】/","excerpt":"人总是不会满足于现状，接下来我们就可以让我们的朋友们通过独立域名访问我们的网站了，但是这肯定是要花点钱的，所以这篇文章难免会出现一些推销信息，希望这会对你有用，话不多说动手吧！","text":"人总是不会满足于现状，接下来我们就可以让我们的朋友们通过独立域名访问我们的网站了，但是这肯定是要花点钱的，所以这篇文章难免会出现一些推销信息，希望这会对你有用，话不多说动手吧！ 购买一个域名我的域名是在阿里云购买的，因为是.top域名，所以比较便宜，第一年才3块钱，如果是土豪，就买其他的吧，但是如果你现在是在校大学生的话，腾讯云的学生优惠活动可以一元钱购买域名和空间，不是为最佳的选择。如果你选择了腾讯云的学生优惠活动，那么请你先注册好账号，并且通过实名认证以及学生认证，这样才可以开始学生优惠活动的抢购活动，活动开抢时间为每天的中午12点，调好闹钟摆好姿势啦，不过我觉得挺好抢的。祝好运😉如果你已经买好了域名，并且不打算买空间，只想用Github上的存储空间，那就来吧！ 域名解析来到你域名的管理系统，点击域名解析，添加两条解析，如图所示： 域名解析 两条记录类型都是CNAME，主机记录分别为www以及@，线路最好选择海外，毕竟Github对吧😙，记录值则是写你的yourname.github.io。同样等待几分钟之后就可以进行访问了，你会发现如果你在访问https://yourname.github.io ，它会自动转到你的域名，当然你也可以直接使用你的域名进行访问。 购买空间域名我是在阿里云很早就买了，但是空间是在腾讯云买的，我买的虚拟主机是Windows Server2012 版本，当然主机的类型对网站的搭建并没有多大影响，基本的操作大同小异。 域名解析如果你还买了空间，那就同样来到你域名的管理系统，点击域名解析，应当按照如下所示的进行设置： 域名解析 在虚拟主机中搭建你的网站这一步其实就是将你在本地的工作重复进行一遍，请见第二节/)，按照这一节可以在虚拟主机中访问localhost:4000进入你的网站。 使用nginx反向代理其实经过上一步，你的朋友们可以通过yourwebsitename:4000访问你的网站了，但是这样也太不帅了吧，所以我们可以使用nginx监听80端口，将所有的请求返回80端口，这样你的朋友只要访问你的域名就可以直接进入网站主页了，而不用加上4000端口。 下载Nginx并解压至c:\\nginx。 启动Nginx。进入c:\\nginx，双击nginx.exe，或者打开cmd，进入Nginx目录，执行命令start nginx。默认的端口号为80。 直接访问浏览器localhost,正常情况下，就能看到Nginx的欢迎界面了。如果不对，90%的可能是因为80端口占用问题，打开配置Nginx配置文件，修改一下默认端口就行了。 修改端口号。修改c:\\nginx\\conf\\nginx.conf，将其中的server节点修改如下，记得要把最后一行错误页也修改了，这样当你访问你的网站的时候，出现路径不存在的情况时，会自动跳转到该页面： 1234567891011121314server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html/public; index index.html; &#125; error_page 404 /404.html; 通过Hexo g命令生成的静态站点，默认就是Hexo站点目录中的public文件夹。将生成好的静态站点（也就是public/目录），拷贝至Nginx目录下的html文件夹中。然后修改Nginx配置文件。记得将public文件夹全部拷贝哦！ 重启nginx。在任务管理器关闭nginx.exe再重新开启或者在命令行中使用如下命令重启nginx。 1nginx -s reload 重新访问localhost，就可以看到Hexo静态站点了。这里要注意浏览器缓存的问题。 开心吗？如果幸运的话，到此为止，你就可以使用yourwebsitename访问你的网站了，如果有任何问题，可以在站内留言或者自行google。","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"一口一口吃掉Hexo（三）","slug":"一口一口吃掉Hexo(三)","date":"2017-01-12T12:37:15.000Z","updated":"2018-10-21T08:26:21.280Z","comments":true,"path":"2017/01/12/一口一口吃掉Hexo(三)/","link":"","permalink":"http://www.wensibo.top/2017/01/12/一口一口吃掉Hexo(三)/","excerpt":"相信通过前一节的学习，你已经在你的本地部署好了你的网站，那么接下来就让你的朋友们通过网络访问你的网站吧！通过这一节你将免费拥有一个“域名”（其实是一个二级域名，但是真的是免费的哦），同时你也会拥有一个免费的存储空间，用于存放你网站的文件资料。那就跟着我来吧！！！","text":"相信通过前一节的学习，你已经在你的本地部署好了你的网站，那么接下来就让你的朋友们通过网络访问你的网站吧！通过这一节你将免费拥有一个“域名”（其实是一个二级域名，但是真的是免费的哦），同时你也会拥有一个免费的存储空间，用于存放你网站的文件资料。那就跟着我来吧！！！ 新建一个仓库如果你还没有自己的Github账户，那就那就返回上一节创建Github账户，并且配置好本地的Git，使之与Github账户建立连接。 新建一个仓库，名字为yourname.github.io（例如我的github账户名称为Wensibob），那么名字就是Wensibob.github.io。 修改_config.yml记得上一节我讲过_config.yml文件，我们会经常跟他打交道，对的就是他啦！记得是根目录下的_config.yml文件哦！ 按照如下的代码修改该文件中的deploy部分。同样将yourname改为你的账户名字 1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 记住下面的额写法是错的哦！别进坑： 1234deploy: type: github repo: https://github.com/yourname/yourname.github.io.git branch: master 安装Hexo支持Git的插件 1npm install hexo-deployer-git --save 生成静态文件，基本上你每次修改你的文章，都需要用到它 123hexo g或者hexo generate 部署你的网站 123hexo d或者hexo deploy 知道Git提示你Deploy Done，就说明你部署成功了，接下来刷新一下你的Github的这个项目就会发现已经push进来了。 等待片刻吧！不知道为什么，如果你现在就访问https://yourname.github.io （yourname换成你的账户名字），你会发现并没有用，但是稍待片刻，或许是5分钟吧，你就可以正常访问了，但是记住如果你使用http访问的话，你可能会发现并访问不了，这个时候可以使用https进行访问。 下一节你将可以通过你自己的域名访问你的网站。","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"一口一口吃掉Hexo（二）【新增配置404】","slug":"一口一口吃掉Hexo（二）【新增配置404】","date":"2017-01-12T09:34:25.000Z","updated":"2018-10-21T08:26:21.216Z","comments":true,"path":"2017/01/12/一口一口吃掉Hexo（二）【新增配置404】/","link":"","permalink":"http://www.wensibo.top/2017/01/12/一口一口吃掉Hexo（二）【新增配置404】/","excerpt":"本次系列教程的第二篇文章我会介绍如何在本地安装Hexo，请注意我使用的Windows系统，如果你是Mac或者Ubuntu，请参考官方文档，理论上来说会比windows简单。","text":"本次系列教程的第二篇文章我会介绍如何在本地安装Hexo，请注意我使用的Windows系统，如果你是Mac或者Ubuntu，请参考官方文档，理论上来说会比windows简单。 本地安装Hexo安装Git 下载并安装Git。 如果你已经在本地使用过Git，并且绑定了你的Github账号，那么请看下一步吧!如果你是首次使用Git，那么你应当帮顶一下你的Github账号，在这里注册你的Github账号。 使用下面的命令创建SSH Key。 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub8两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key。 安装Node.js到这里下载并安装程序。 安装Hexo所有的环境搭建好之后就可以打开git bash，并使用下面的命令进行安装。1$ npm install -g hexo-cli 搭建网站安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 这个过程需要一定的时间，请耐心等待。建成之后的目录结构大致如下，可能会有所差异，并无大碍。1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml 是网站的配置信息，大部分时候你会使用到他。 source 目录下面存放的是你编写的博客文章，在 _posts 目录下为你已经发表的文章，在 _drafts 目录下为你存放的草稿文章，当然你可能没有这个文件夹，因为一开始你还没有新建草稿文章。 themes 目录为你的博客网站使用的主题，程序默认的主题landscape，他长这样： landscape 本地调试Hexo###启动你的网站 使用如下命令进入你的博客网站目录，例如我的目录为/e/blog。 1cd /e/blog 执行如下命令启动Hexo服务。 123hexo s或者hexo server 如果幸运的话，执行完上面的命令之后你将可以通过浏览器访问localhost:4000看到博客网站的主页，他大概长这样，你已经看过了对吧。 landscape 如果你出现的问题,请联系我或者自行google。 本地更换主题如果你不喜欢默认主题的话，那就在这里找到你喜欢的吧！相信总有一款适合你。我这个系列的教程将会使用Indigo这个主题，基本来说设置大同小异，他长这样： Indigo 安装主题确认你的Hexo版本在3.0以上，以及Node版本为6.x以上，进入Hexo根目录（例如我的为/e/blog），执行以下命令。1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 依赖安装在Hexo的根目录下安装下面的依赖，如果你已经安装过了，那就不用再次安装。 Less1$ npm install hexo-renderer-less --save Feed1$ npm install hexo-generator-feed --save Json-content1$ npm install hexo-generator-json-content --save QRCode用于生成分享二维码1$ npm install hexo-helper-qrcode --save 开启标签页当初就是在这里没有开启，所以最后点击“标签“的时候是会出现异常的1hexo new page tags 修改blog/source/tags/index.md 123layout: tagscomments: false--- 开启分类页1hexo new page categories 修改blog/source/categories/index.md123layout: categoriescomments: false--- 大坑之404页面配置新建一个404.html文件，具体的样式你可以自己写，网上应该也挺多的，记得将它放在blog/public下，就放这里就行了，网上很多人说放在source下，亲试不可用！ 开心地浏览吧！同样是打开浏览器，访问localhost:4000，就可以看到亲切的Indigo主题了。如果你发现遇到了问题，请你来到这里查看解决方法，如果这里不能满足你，请像作者发Issues，或者站内留言or给我发邮件Wensibob@gmail.com 下回见!!!","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"一口一口吃掉Hexo（一）","slug":"一口一口吃掉Hexo(一)","date":"2017-01-11T12:43:25.000Z","updated":"2018-10-21T08:26:21.376Z","comments":true,"path":"2017/01/11/一口一口吃掉Hexo(一)/","link":"","permalink":"http://www.wensibo.top/2017/01/11/一口一口吃掉Hexo(一)/","excerpt":"这里是我的个人博客网站，点击这里你可以到我的首页瞧瞧。我之前使用的是第三方的博客平台——博客园，点击这里可以看到我的博客园首页。 在看到Hexo之后，我深深的为之着迷，尤其是看到了Material Design主题的Hexo，我多想我自己的博客网站也长这样，于是就开始动手啦，前后花费了4天啊，感觉要废了😭 这也是我写这个系列教程的原因，希望后来者能够少填坑，但是我现在目前的一些配置还不太完善，还需要自己去摸索，也希望看到这个系列文章的你尽管吐槽☺ 废话的最后我要感谢我目前使用的主题Indigo的作者王昱森，感谢他解决我的一些提问，也感谢他为了维护这个主题所做的工作；另外我的许多配置都参考了该作者的github教程。","text":"这里是我的个人博客网站，点击这里你可以到我的首页瞧瞧。我之前使用的是第三方的博客平台——博客园，点击这里可以看到我的博客园首页。 在看到Hexo之后，我深深的为之着迷，尤其是看到了Material Design主题的Hexo，我多想我自己的博客网站也长这样，于是就开始动手啦，前后花费了4天啊，感觉要废了😭 这也是我写这个系列教程的原因，希望后来者能够少填坑，但是我现在目前的一些配置还不太完善，还需要自己去摸索，也希望看到这个系列文章的你尽管吐槽☺ 废话的最后我要感谢我目前使用的主题Indigo的作者王昱森，感谢他解决我的一些提问，也感谢他为了维护这个主题所做的工作；另外我的许多配置都参考了该作者的github教程。 来看看Hexo是什么吧关于Hexo 以下是官方对Hexo的定义:123Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 其实对于程序员来说，只要是自己喜欢的，就算不是简单的也会自己去捣鼓的，要有一个不费折腾的心。如果你对Hexo很感兴趣那我会推荐他的官网给你，在这里你可以你可以仔细阅读他的文档，当然我觉得他的文档也不够详尽，但是如果你遇到问题了，也可以在我的网站中留言或者发email给我，我会尽我所能给你帮助。 关于Indigo Indigo使用了类似Android的MD设计模式，几乎在Google自家的网页设计中，这种设计语言运用自如，但是运用在博客网站中我却是第一次见到的，所以才会有想要试试的心态。 通过本次系列教程你会学会什么 通过本系列的教程，你将会建立一个自己的博客网站，你可以拥有自己的域名，可以自己维护自己的网站，这会是一个很有诱惑的目标吧！但是为了避免你到处跳坑，所以请你务必按照我的教程一步一步配置。需要说明的是本次教程我使用的操作系统为Win10，理论上来说其他系统会比windows要更加简便，但是上了微软的船再也下不来了😐。","categories":[{"name":"一口一口吃掉Hexo","slug":"一口一口吃掉Hexo","permalink":"http://www.wensibo.top/categories/一口一口吃掉Hexo/"}],"tags":[{"name":"使用Hexo建立个人博客网站","slug":"使用Hexo建立个人博客网站","permalink":"http://www.wensibo.top/tags/使用Hexo建立个人博客网站/"}]},{"title":"setSupportActionBar(toolbar)导致程序崩溃闪退","slug":"setSupportActionBar(toolbar)导致程序崩溃闪退","date":"2016-09-06T06:24:45.000Z","updated":"2018-10-21T08:26:20.916Z","comments":true,"path":"2016/09/06/setSupportActionBar(toolbar)导致程序崩溃闪退/","link":"","permalink":"http://www.wensibo.top/2016/09/06/setSupportActionBar(toolbar)导致程序崩溃闪退/","excerpt":"最近在做一个项目，使用了第三方的开源项目，主要是想实现android5.0之后推出的MaterialDesign的风格，但是代码已经写好了，发现一运行就闪退，所以就开始debug，发现问题出现在12Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar);","text":"最近在做一个项目，使用了第三方的开源项目，主要是想实现android5.0之后推出的MaterialDesign的风格，但是代码已经写好了，发现一运行就闪退，所以就开始debug，发现问题出现在12Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(toolbar); 很显然应该是在第二行出错了，再根据logcat上的日志：123This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_SUPPORT_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead. 所以应当是与activity中的ActionBar有冲突，最后尝试多次知道，是要在清单文件中设置activity的style（只要有用到这一行代码的activity都需要在该activity节点下定义style），可以按照如下设置123456789&lt;activity android:name=\".MainActivity\" android:label=\"test\" android:theme=\"@style/MaterialDrawerTheme.Light.DarkToolbar\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这里指的就是第三行了，这样就不会造成程序崩溃了。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"toolbar导致程序崩溃闪退","slug":"toolbar导致程序崩溃闪退","permalink":"http://www.wensibo.top/tags/toolbar导致程序崩溃闪退/"}]},{"title":"【原创+译文】官方文档中声明的如何创建抽屉导航栏(Navigation Drawer)","slug":"【原创+译文】官方文档中声明的如何创建抽屉导航栏(Navigation Drawer)","date":"2016-09-03T03:01:45.000Z","updated":"2018-10-21T08:26:20.432Z","comments":true,"path":"2016/09/03/【原创+译文】官方文档中声明的如何创建抽屉导航栏(Navigation Drawer)/","link":"","permalink":"http://www.wensibo.top/2016/09/03/【原创+译文】官方文档中声明的如何创建抽屉导航栏(Navigation Drawer)/","excerpt":"抽屉式导航栏是显示在屏幕的左边缘，它是应用程序的主导航选项面板。它大部分时间是处于隐藏状态的，但是当用户从屏幕的左边缘挥动手指时它就会显示出来，而在应用程序的顶层，用户触摸操作栏上的应用程序图标也可以将其显示出来。 本课程介绍在可用的API 支持库下如何实现导航抽屉DrawerLayout。","text":"抽屉式导航栏是显示在屏幕的左边缘，它是应用程序的主导航选项面板。它大部分时间是处于隐藏状态的，但是当用户从屏幕的左边缘挥动手指时它就会显示出来，而在应用程序的顶层，用户触摸操作栏上的应用程序图标也可以将其显示出来。 本课程介绍在可用的API 支持库下如何实现导航抽屉DrawerLayout。 首先我们可以看一下最终的效果图： DrawerLayout效果图 1、创建一个抽屉布局文件（Drawer Layout）要添加一个抽屉式导航，首先你必须要声明你的用户界面的根布局为DrawerLayout对象。在DrawerLayout里面，添加一个主视图内容的view对象（当抽屉被隐藏的时候显示在屏幕上的 视图）和另外一个包含抽屉导航视图的view对象。 例如，下面的布局采用了包含两个子视图的DrawerLayout：一个是FrameLayout，包含了主要内容（在运行时由填充Fragment），和一个ListView的导航抽屉。 123456789101112131415161718192021222324&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;!-- 主视图 --&gt; &lt;FrameLayout android:id=\"@+id/content_frame\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;!-- 抽屉视图 --&gt; &lt;ListView android:id=\"@+id/left_drawer\" android:layout_width=\"240dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"#111\" android:choiceMode=\"singleChoice\" android:divider=\"@android:color/transparent\" android:dividerHeight=\"0dp\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 这个布局文件演示了一些比较重要的布局特点，如下： 主内容视图（上面的FrameLayout）必须是DrawerLayout布局对象的第一个子view对象，这是因为xml文件意味着是z排序（即空间上的上下排序，也就是说抽屉导航栏应该位于住内容视图的垂直上方）。 主内容视图的view对象的两个属性：layout_width、layout_height必须是match_parent的，这是因为当抽屉导航栏被隐藏的时候他便是整个UI。 抽屉视图要指定其宽度的单位为dp，高度与父视图相匹配。抽屉的宽度应该不超过320dp，这样用户可以随时看到主要内容视图的一些部分。 抽屉视图（ListView）必须用 android:layout_gravity 属性来指定他的水平重力方向。为了支持从右到左（RTL）的语言，应该要指定其属性为”start” ，而不是”left” 。 2、初始化抽屉列表在你的Activity中，首先要做的事之一就是初始化抽屉导航栏中的列表项。至于你要如何做取决于你的应用程序中的内容，但是通常情况下抽屉导航栏都是包含了一个ListView，所以列表应该由Adapter来填充（如ArrayAdapter或者SimpleCursorAdapter）。 例如下面将告诉你如何用字符串数组初始化抽屉导航栏列表： 123456789101112131415161718192021222324public class MainActivity extends Activity &#123; private String[] mPlanetTitles; private DrawerLayout mDrawerLayout; private ListView mDrawerList; ... @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mPlanetTitles = getResources().getStringArray(R.array.planets_array); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerList = (ListView) findViewById(R.id.left_drawer); // Set the adapter for the list view mDrawerList.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.drawer_list_item, mPlanetTitles)); // Set the list's click listener mDrawerList.setOnItemClickListener(new DrawerItemClickListener()); ... &#125;&#125; 此代码还调用setOnItemClickListener()来接收抽屉导航栏列表的点击事件。下一节将展示如何实现此接口，以实现当用户选择一个项目后更改主内容视图。 3、处理导航的点击事件当用户选择在抽屉导航栏里列表中的项目时，系统调用OnItemClickListener接口中的onItemClick()方法以返回给OnItemClickListener() 。你要在onItemClick()方法中做什么样的处理取决于你如何实现你的的应用程序结构。在下面的例子中，你将可以实现下面的内容：当点击抽屉导航栏中列表项里的item时，将会在住内容视图中插入一个不同的Fragment。(FrameLayout的id为 R.id.content_frame)。 1234567891011121314151617181920212223242526272829303132private class DrawerItemClickListener implements ListView.OnItemClickListener &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; selectItem(position); &#125;&#125;/** Swaps fragments in the main content view */private void selectItem(int position) &#123; // Create a new fragment and specify the planet to show based on position Fragment fragment = new PlanetFragment(); Bundle args = new Bundle(); args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position); fragment.setArguments(args); // Insert the fragment by replacing any existing fragment FragmentManager fragmentManager = getFragmentManager(); fragmentManager.beginTransaction() .replace(R.id.content_frame, fragment) .commit(); // Highlight the selected item, update the title, and close the drawer mDrawerList.setItemChecked(position, true); setTitle(mPlanetTitles[position]); mDrawerLayout.closeDrawer(mDrawerList);&#125;@Overridepublic void setTitle(CharSequence title) &#123; mTitle = title; getActionBar().setTitle(mTitle);&#125; 4、监听打开以及关闭抽屉导航栏的事件要监听抽屉打开和关闭事件，在你的DrawerLayout中调用setDrawerListener()并传入一个DrawerLayout.DrawerListener接口 。此接口为抽屉导航栏提供了回掉方法，如onDrawerOpened()和onDrawerClosed()。 然而，除了实现DrawerLayout.DrawerListener接口之外，如果你的Activity包含了ActionBar，你也可以继承ActionBarDrawerToggle这个类，这是因为ActionBarDrawerToggle类实现DrawerLayout.DrawerListener接口，所以你仍然可以复写这些方法，但是这对ActionBar图标和抽屉的交互也有一定的帮助。 正如在抽屉导航设计指南讨论的一样，当抽屉处于可见状态时你应该要修改操作栏（ActionBar）的内容，例如你应该要改变标题，并移除与主内容试图相关的列表项。下面的代码演示了如何通过实例化ActionBarDrawerToggle类并复写在DrawerLayout.DrawerListener中的回调方法，以达到这样的目的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends Activity &#123; private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; private CharSequence mDrawerTitle; private CharSequence mTitle; ... @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... mTitle = mDrawerTitle = getTitle(); mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) &#123; /** Called when a drawer has settled in a completely closed state. */ public void onDrawerClosed(View view) &#123; super.onDrawerClosed(view); getActionBar().setTitle(mTitle); invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu() &#125; /** Called when a drawer has settled in a completely open state. */ public void onDrawerOpened(View drawerView) &#123; super.onDrawerOpened(drawerView); getActionBar().setTitle(mDrawerTitle); invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu() &#125; &#125;; // Set the drawer toggle as the DrawerListener mDrawerLayout.setDrawerListener(mDrawerToggle); &#125; /* Called whenever we call invalidateOptionsMenu() */ @Override public boolean onPrepareOptionsMenu(Menu menu) &#123; // If the nav drawer is open, hide action items related to the content view boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList); menu.findItem(R.id.action_websearch).setVisible(!drawerOpen); return super.onPrepareOptionsMenu(menu); &#125;&#125; 下面将介绍ActionBarDrawerToggle构造函数的参数，并设置它来处理与操作栏图标交互所需的其他步骤。 5、如何通过应用程序图标打开或关闭抽屉导航栏用户可以通过来自或朝向屏幕的左边缘轻扫的手势来打开与关闭抽屉式导航栏，但如果你正在使用操作栏（ActionBar） ，你也应该允许用户通过触摸应用程序图标的方式打开或者关闭抽屉导航栏。而应用程序图标也应用一个特殊的图标注明抽屉的存在。你也可以通过实现上一节讲到的ActionBarDrawerToggle来实现这些行为。 为了使ActionBarDrawerToggle发挥作用，你将需要创建它的一个实例与它的构造方法，这需要下列参数： 持有该抽屉的Activity 一个DrawerLayout 用于作为抽屉指标的绘制资源（drawable resource），这里会提供一个android官方提供的图标包。 用来形容“打开抽屉”这一操作的字符串资源 用来形容“关闭抽屉”这一操作的字符串资源 最后，不管你是否已经创建了ActionBarDrawerToggle的子类作为抽屉的监听器，你还是需要在整个Activity的生命周期中的几个地方调用ActionBarDrawerToggle： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MainActivity extends Activity &#123; private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; ... public void onCreate(Bundle savedInstanceState) &#123; ... mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout); mDrawerToggle = new ActionBarDrawerToggle( this, /* host Activity */ mDrawerLayout, /* DrawerLayout object */ R.drawable.ic_drawer, /* nav drawer icon to replace 'Up' caret */ R.string.drawer_open, /* \"open drawer\" description */ R.string.drawer_close /* \"close drawer\" description */ ) &#123; /** Called when a drawer has settled in a completely closed state. */ public void onDrawerClosed(View view) &#123; super.onDrawerClosed(view); getActionBar().setTitle(mTitle); &#125; /** Called when a drawer has settled in a completely open state. */ public void onDrawerOpened(View drawerView) &#123; super.onDrawerOpened(drawerView); getActionBar().setTitle(mDrawerTitle); &#125; &#125;; // Set the drawer toggle as the DrawerListener mDrawerLayout.setDrawerListener(mDrawerToggle); getActionBar().setDisplayHomeAsUpEnabled(true); getActionBar().setHomeButtonEnabled(true); &#125; @Override protected void onPostCreate(Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); // Sync the toggle state after onRestoreInstanceState has occurred. mDrawerToggle.syncState(); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); mDrawerToggle.onConfigurationChanged(newConfig); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Pass the event to ActionBarDrawerToggle, if it returns // true, then it has handled the app icon touch event if (mDrawerToggle.onOptionsItemSelected(item)) &#123; return true; &#125; // Handle your other action bar items... return super.onOptionsItemSelected(item); &#125; ...&#125; 教程的最后，我提供了项目供你下载，希望这个教程能够帮到你。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"Navigation Drawer","slug":"Navigation-Drawer","permalink":"http://www.wensibo.top/tags/Navigation-Drawer/"}]},{"title":"如何避免Activity 被杀死","slug":"如何避免Activity 被杀死","date":"2016-08-13T06:15:05.000Z","updated":"2018-10-21T08:26:21.104Z","comments":true,"path":"2016/08/13/如何避免Activity 被杀死/","link":"","permalink":"http://www.wensibo.top/2016/08/13/如何避免Activity 被杀死/","excerpt":"我们都知道，在android系统中，内存不足的时候，系统是可以杀死任何暂停、停止或者销毁的Activity。这就意味着基本上没有在前台的Activity都会面临被关闭的可能。","text":"我们都知道，在android系统中，内存不足的时候，系统是可以杀死任何暂停、停止或者销毁的Activity。这就意味着基本上没有在前台的Activity都会面临被关闭的可能。 Android系统之所以采用这个机制，而不是像ios系统一样采用墓碑式的管理方式，是因为这样可以在一定程度上加快应用的响应速度，但是由于以前的android手机的性能比较落后，手机运行内存RAM基本上处于2G以内，所以就会导致一些不在前台的Activity有可能被回收，但是现在的智能手机性能已经足够强悍，拿我现在的这部手机——一加手机3（6GRAM）来说，但是之前官方表示为了手机的续航，将内存机制进行修改，使得当用户打开的应用超过一定数量的时候，系统就会对一些Activity进行回收，所以重新打开这些Activity的时候，就会出现重新加载的情况，这在打开大型游戏的时候比较常见。 那我们在开发的时候如何在系统资源吃紧的时候将一些必要的数据进行及时的存储保护，避免数据的丢失呢？ 我们来看官方API中给出的一个关于Activity的生命周期的图解： Activity生命周期 如果Activity在onPause()后被杀掉，那么onStop()和onDestroy()方法就不会被调用，所以如果在onPause()方法内更多的释放Activity资源，就会让Activity在后台被系统杀掉的几率降低。 但是杀死一个Activity并不会导致它从Activity堆栈中移除，相反如果Activity实现并使用了onSaveInstanceState()方法用来自定义的保存数据，那么Activity的状态就会被保存到Bundle中，这样当Activity被重新返回的时候，onCreate()方法会被再次调用，这样刚才保存有数据的Bundle对象就会被调用，将数据重新读取；但是该方法并不能保证在任何时候都能被调用。因此我们应该在onPause()方法中保存重要的数据到永久存储(即手机硬件内存中)而用onSaveInstanceState()来保存一些可以从当前屏幕快速恢复的数据(相对不重要的数据)。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"避免Activity 被杀死","slug":"避免Activity-被杀死","permalink":"http://www.wensibo.top/tags/避免Activity-被杀死/"}]},{"title":"SharePreference是如何实现的——序列化XML文件","slug":"SharePreference是如何实现的——序列化XML文件","date":"2016-04-29T15:01:45.000Z","updated":"2018-10-21T08:26:20.952Z","comments":true,"path":"2016/04/29/SharePreference是如何实现的——序列化XML文件/","link":"","permalink":"http://www.wensibo.top/2016/04/29/SharePreference是如何实现的——序列化XML文件/","excerpt":"还记得上一篇我们讲到了用SharePreference来存储数据，那么究竟它是如何实现的呢，今天我们就来仔细看看其实现的细节，我们给它一个准确的名字，叫做XML序列化器(XmlSerializer)。 不同于上面一篇的保存用户的登录名以及密码，这次我们保存设备中的信息，但是由于现在知识有限，我还不能够实现对设备中信息的读取，那么我就在程序中自己生成若干条信息，对这些生成的信息进行读取，并保存到位于SD卡的backup.xml文件中。在这里我是用两种方法对其进行存储并比较两种方法的优缺点，当然作为开发，我更建议使用待会讲到的第二种方法。","text":"还记得上一篇我们讲到了用SharePreference来存储数据，那么究竟它是如何实现的呢，今天我们就来仔细看看其实现的细节，我们给它一个准确的名字，叫做XML序列化器(XmlSerializer)。 不同于上面一篇的保存用户的登录名以及密码，这次我们保存设备中的信息，但是由于现在知识有限，我还不能够实现对设备中信息的读取，那么我就在程序中自己生成若干条信息，对这些生成的信息进行读取，并保存到位于SD卡的backup.xml文件中。在这里我是用两种方法对其进行存储并比较两种方法的优缺点，当然作为开发，我更建议使用待会讲到的第二种方法。 先来看看我们需要做到什么样的效果: 存储数据效果图 1、使用StringBuffer，将所有的内容逐一追加到该字符流中。1234567891011121314151617181920212223242526272829303132333435public void backUpSms1(View view)&#123; StringBuffer sb=new StringBuffer(); sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?&gt;\"); sb.append(\"&lt;smss&gt;\"); for (SmsInfo smsinfo: smsInfo) &#123; sb.append(\"&lt;sms&gt;\"); sb.append(\"&lt;address&gt;\"); sb.append(smsinfo.getAddress()); sb.append(\"&lt;/address&gt;\"); sb.append(\"&lt;date&gt;\"); sb.append(smsinfo.getDate()); sb.append(\"&lt;/date&gt;\"); sb.append(\"&lt;content&gt;\"); sb.append(smsinfo.getContent()); sb.append(\"&lt;/content&gt;\"); sb.append(\"&lt;type&gt;\"); sb.append(smsinfo.getType()); sb.append(\"&lt;/type&gt;\"); sb.append(\"&lt;/sms&gt;\"); &#125; sb.append(\"&lt;/smss&gt;\"); try &#123; File file =new File(Environment.getExternalStorageDirectory(), \"backUp1.xml\"); FileOutputStream fos =new FileOutputStream(file); fos.write(sb.toString().getBytes()); fos.close(); Toast.makeText( this, \"备份成功\",0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText( this, \"备份失败\",0).show(); &#125; &#125; 第一种方法相当简单，只是用了一个字符流，将所有的内容逐一追加就行了，可是当我们的短信中出现了一些比较特殊的字符，例如:”&lt;”或者是”&gt;”那么在读取并写入到xml文件的时候就会出错，这个时候打开该xml文件的时候将会报错；另外当我们需要在sms标签中加入一些属性，如图一所示，那么这个时候仅仅利用字符流来写就会变得冗杂，而且逻辑关系就不严谨了，所以这个时候我们就需要用到第二种方法了。 2、XML序列化器(使用XmlSerializer编辑xml文件)【推荐】123456789101112131415161718192021222324252627282930313233343536373839404142public void backUpSms2(View view) &#123; try &#123; //初始化序列号器，指定xml写入到哪个文件并指定写入的编码格式 XmlSerializer xmlSerializer =Xml.newSerializer(); File file =new File(Environment.getExternalStorageDirectory(), \"backUp2.xml\"); FileOutputStream fos=new FileOutputStream(file); xmlSerializer.setOutput(fos,\"utf-8\"); xmlSerializer.startDocument(\"utf-8\", true);//开始声明文件 xmlSerializer.startTag(null, \"smss\");//开始最外层标签 for (SmsInfo sms : smsInfo) &#123; xmlSerializer.startTag(null, \"sms\");//写入第一个标签 xmlSerializer.attribute(null, \"id\", sms.getId()+\"\");//第一个标签的属性 xmlSerializer.startTag(null, \"address\");//写入内一层的标签 xmlSerializer.text(sms.getAddress()); xmlSerializer.endTag(null, \"address\"); xmlSerializer.startTag(null, \"date\");//写入内一层的标签 xmlSerializer.text(sms.getDate()+\"\"); xmlSerializer.endTag(null, \"date\"); xmlSerializer.startTag(null, \"content\");//写入内一层的标签 xmlSerializer.text(sms.getContent()); xmlSerializer.endTag(null, \"content\"); xmlSerializer.startTag(null, \"type\");//写入内一层的标签 xmlSerializer.text(sms.getType()+\"\"); xmlSerializer.endTag(null, \"type\"); xmlSerializer.endTag(null, \"sms\");//结束标签 &#125; xmlSerializer.endTag(null, \"smss\");//结束最外层标签 xmlSerializer.endDocument();//结束声明文件 fos.close();//记得一定要关闭输出流 Toast.makeText( this, \"备份成功\",0).show(); &#125; catch (Exception e) &#123; e.printStackTrace(); Toast.makeText( this, \"备份失败\",0).show(); &#125; &#125; 使用XmlSerializer的时候有几个步骤：1、首先需要找到输出流，即通过setOutput方法将输出流以及编码格式传入；2、接着需要声明文件以及结束声明，这是通过startDocument以及endDocument这两个方法来实现的；3、接着就可以通过startTag以及startTag方法来声明标签以及结束标签，要声明标签的内容的时候可以通过text方法，当然这个方法只能允许传入String类型，所以对于其他数据类型，需要先对其进行转换；4、最后一点就是上面讲到的——要在标签中添加属性，那就需要通过attribute方法声明id属性。通过以上的讲解，我们可以得到以下的xml文件： &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"true\"?&gt; -&lt;smss&gt; -&lt;sms id=\"0\"&gt; &lt;address&gt;135000000000&lt;/address&gt; &lt;date&gt;1461845202224&lt;/date&gt; &lt;content&gt;内容为：0&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"1\"&gt; &lt;address&gt;135000000001&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：1&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"2\"&gt; &lt;address&gt;135000000002&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：2&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"3\"&gt; &lt;address&gt;135000000003&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：3&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"4\"&gt; &lt;address&gt;135000000004&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：4&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"5\"&gt; &lt;address&gt;135000000005&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：5&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"6\"&gt; &lt;address&gt;135000000006&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：6&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"7\"&gt; &lt;address&gt;135000000007&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：7&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"8\"&gt; &lt;address&gt;135000000008&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：8&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"9\"&gt; &lt;address&gt;135000000009&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：9&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"10\"&gt; &lt;address&gt;135000000010&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：10&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"11\"&gt; &lt;address&gt;135000000011&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：11&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"12\"&gt; &lt;address&gt;135000000012&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：12&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"13\"&gt; &lt;address&gt;135000000013&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：13&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"14\"&gt; &lt;address&gt;135000000014&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：14&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"15\"&gt; &lt;address&gt;135000000015&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：15&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"16\"&gt; &lt;address&gt;135000000016&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：16&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"17\"&gt; &lt;address&gt;135000000017&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：17&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"18\"&gt; &lt;address&gt;135000000018&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：18&lt;/content&gt; &lt;type&gt;2&lt;/type&gt; &lt;/sms&gt; -&lt;sms id=\"19\"&gt; &lt;address&gt;135000000019&lt;/address&gt; &lt;date&gt;1461845202225&lt;/date&gt; &lt;content&gt;内容为：19&lt;/content&gt; &lt;type&gt;1&lt;/type&gt; &lt;/sms&gt; &lt;/smss&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"http://www.wensibo.top/tags/SharedPreferences/"}]},{"title":"使用 SharedPreferences 实现数据的存储和读取","slug":"使用 SharedPreferences 实现数据的存储和读取","date":"2016-04-16T08:21:04.000Z","updated":"2018-10-21T08:26:21.168Z","comments":true,"path":"2016/04/16/使用 SharedPreferences 实现数据的存储和读取/","link":"","permalink":"http://www.wensibo.top/2016/04/16/使用 SharedPreferences 实现数据的存储和读取/","excerpt":"在开发的过程中我们必须遇到的就是如何对用户的数据进行有效的存储以及读取。我们举个例子，现在我们使用app，当我们登陆一个账号的时候选择记住密码软件就会记住我们的账号以及密码，我们退出当前账号，就可以直接点击登陆进入账号内部，而不需要再输入账号和密码了。那么这就是今天我们要说的，如何对用户输入的账号以及密码进行存储，并且进行显示。这里我们使用到了google工程师向我们推荐的一个API——SharedPreferences。","text":"在开发的过程中我们必须遇到的就是如何对用户的数据进行有效的存储以及读取。我们举个例子，现在我们使用app，当我们登陆一个账号的时候选择记住密码软件就会记住我们的账号以及密码，我们退出当前账号，就可以直接点击登陆进入账号内部，而不需要再输入账号和密码了。那么这就是今天我们要说的，如何对用户输入的账号以及密码进行存储，并且进行显示。这里我们使用到了google工程师向我们推荐的一个API——SharedPreferences。 关于SharedPreferences它是android.content下的一个接口，官方对他的描述是这样的：用于访问和修改getSharedPreferences(String, int)返回偏好设置数据(preference data)的一个接口。对于任何一组特殊的preferences，所有的客户端共享一个此类单独的实例。修改Preferences必须通过一个SharedPreferences.Editor对象，以确保当他们提交存储数据的操作时，preference值保持一致的状态。最后再提交数据的时候必须使用commit()方法将数据完全写入。 它的优点在于会对一些特殊的字符进行分辨，达到准确读取的目的，传统上我们选择以特殊分隔符来分割要存储的数据，这样虽然会简单点，但是如果用户舌设置的数据同样包含这个分隔符，那么将造成读取失误。 关于SharedPreferences的实例 这里我只介绍关键代码，整个工程可以在该链接下载。 使用saveUserInfo()方法来存储用户的数据：123456789101112131415161718192021222324/** * 保存用户名 密码的业务方法 * @param context 上下文 * @param username 用户名 * @param pas 密码 * @return true 保存成功 false 保存失败 */ public static void saveUserInfo(Context context,String username,String pas)&#123; /** * SharedPreferences将用户的数据存储到该包下的shared_prefs/config.xml文件中， * 并且设置该文件的读取方式为私有，即只有该软件自身可以访问该文件 */ SharedPreferences sPreferences=context.getSharedPreferences(&quot;config&quot;, context.MODE_PRIVATE); Editor editor=sPreferences.edit(); //当然sharepreference会对一些特殊的字符进行转义，使得读取的时候更加准确 editor.putString(&quot;username&quot;, username); editor.putString(&quot;password&quot;, pas); //这里我们输入一些特殊的字符来实验效果 editor.putString(&quot;specialtext&quot;, &quot;hajsdh&gt;&lt;?//&quot;); editor.putBoolean(&quot;or&quot;, true); editor.putInt(&quot;int&quot;, 47); //切记最后要使用commit方法将数据写入文件 editor.commit(); &#125; 当用户重新打开软件时使用如下代码将其显示出来：123456 //显示用户此前录入的数据SharedPreferences sPreferences=getSharedPreferences(\"config\", MODE_PRIVATE);String username=sPreferences.getString(\"username\", \"\");String password =sPreferences.getString(\"password\", \"\");ed_username.setText(username);ed_pasw.setText(password); 软件运行之后我们可以发现config.xml文件的内容如下：12345678&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;map&gt;&lt;string name=\"specialtext\"&gt;hajsdh&amp;gt;&amp;lt;?//&lt;/string&gt;&lt;string name=\"username\"&gt;dsa&lt;/string&gt;&lt;string name=\"password\"&gt;dasdasd&lt;/string&gt;&lt;int name=\"int\" value=\"47\" /&gt;&lt;boolean name=\"or\" value=\"true\" /&gt;&lt;/map&gt; 我们看到，在xml文件中“&gt;&lt;”被转以为“&gt;&lt;”，这也为数据的准确读取做好了规范。 运行截图： 运行截图 总结至此SharedPreferences的应用结束。在以后的开发过程中，应当多家注意使用官方推荐的API，这会对数据的安全以及数据的完整性有所保障。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"http://www.wensibo.top/tags/SharedPreferences/"}]},{"title":"如何实现微信5.0的滑动效果","slug":"如何实现微信5.0的滑动效果","date":"2016-04-10T08:21:04.000Z","updated":"2018-10-21T08:26:21.136Z","comments":true,"path":"2016/04/10/如何实现微信5.0的滑动效果/","link":"","permalink":"http://www.wensibo.top/2016/04/10/如何实现微信5.0的滑动效果/","excerpt":"作为初学者，虽然深知不可一步登天也应当脚踏实地，但是总会有一些奇思异想想要去实现。在实现第一个app的时候我们遇到的另一个头疼的问题便是如何实现像微信5.0版本过后的滑动效果，查阅官方文档以及借鉴网上大神的经验之后我们也顺利得到了一点思路。虽然我另外一个伙伴已经实现了此功能，但我总觉得有些许的冗杂，经过研究学习之后现在已经得到了优化，详见下文。","text":"作为初学者，虽然深知不可一步登天也应当脚踏实地，但是总会有一些奇思异想想要去实现。在实现第一个app的时候我们遇到的另一个头疼的问题便是如何实现像微信5.0版本过后的滑动效果，查阅官方文档以及借鉴网上大神的经验之后我们也顺利得到了一点思路。虽然我另外一个伙伴已经实现了此功能，但我总觉得有些许的冗杂，经过研究学习之后现在已经得到了优化，详见下文。 1、关于android.support.v4google提供了Android Support Library package 系列的包来保证来高版本sdk开发的向下兼容性，其中v4包是为了照顾1.6及更高版本而设计的，这个包是使用最广泛的，eclipse新建工程时，都默认带有了。但是我一开始在开发中一直指不到该包的源代码，一番搜索之后找到了解决方法：1、首先为工程build path，找到路径：android-sdk-windows\\extras\\android\\support\\v4\\android-support-v4.jar；2、导入该包并不能正确的找到源代码，需要在java bulid path –&gt;Order and Export下找到刚刚导入的support\\v4\\android-support-v4.jar，并将其选择到top位置；3、点击apply之后就可以顺利的查到源代码。 该包下比较常用的类有Fragment以及ViewPager，我的伙伴在实现该功能时使用的是Fragment+ViewPager，这也是官方一直推荐的，但是因为觉得有些许的冗杂，所以这里我只是用ViewPager来实现。关于该包下的这两个常用的类以及其他关键的UI效果的类大家可以查看文档了解，这里就不赘述。 2、具体实现为了美观，这里只显示关键代码，工程的整体代码可以到我的博客中下载： MainActivity关键代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public Object instantiateItem(ViewGroup container, int position) &#123; if (mViewList.get(position).getParent() != null) &#123; container.removeView(mViewList.get(position)); &#125; container.addView(mViewList.get(position)); return mViewList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mViewList.get(position)); &#125; @Override public int getCount() &#123; return mViewList.size(); &#125; &#125;); mViewPager.setOnPageChangeListener(new OnPageChangeListener() &#123; public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels)&#123; int x = (int)((position + positionOffset) * mTextView.getWidth()); ((View)mTextView.getParent()).scrollTo(-x, mTextView.getScrollY()); &#125; public void onPageSelected(int position)&#123; if(position == 0)&#123; radioButton1.setChecked(true); &#125;else if(position == 1)&#123; radioButton2.setChecked(true); &#125;else if(position == 2)&#123; radioButton3.setChecked(true); &#125;else if(position == 3)&#123; radioButton4.setChecked(true); &#125; &#125; public void onPageScrollStateChanged(int state)&#123; &#125; &#125;); &#125; int tmpState = 0; public int dip2px(float dipValue) &#123; final float scale = getResources().getDisplayMetrics().density; return (int) (dipValue * scale + 0.5f); &#125; public int px2dip(float pxValue) &#123; final float scale = getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; activity_main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#FFFFFFFF&quot; android:orientation=&quot;vertical&quot; &gt; &lt;RadioGroup android:id=&quot;@+id/radioGroup&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;RadioButton android:id=&quot;@+id/radioButton1&quot; style=&quot;@style/radioButtonStyle&quot; android:text=&quot;页面1&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radioButton2&quot; style=&quot;@style/radioButtonStyle&quot; android:text=&quot;页面2&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radioButton3&quot; style=&quot;@style/radioButtonStyle&quot; android:text=&quot;页面3&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/radioButton4&quot; style=&quot;@style/radioButtonStyle&quot; android:text=&quot;页面4&quot; /&gt; &lt;/RadioGroup&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;3dip&quot; android:orientation=&quot;horizontal&quot; &gt; &lt;TextView android:id=&quot;@+id/textView&quot; android:layout_width=&quot;200dip&quot; android:layout_height=&quot;3dip&quot; android:background=&quot;#FF336699&quot; android:textColor=&quot;#FFFF0000&quot; /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;1dip&quot; android:background=&quot;#FF336699&quot; /&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewPager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt; 3、具体效果 运行截图","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"微信滑动效果","slug":"微信滑动效果","permalink":"http://www.wensibo.top/tags/微信滑动效果/"}]},{"title":"安卓下如何使用JUnit进行软件测试","slug":"安卓下如何使用JUnit进行软件测试","date":"2016-04-04T14:56:04.000Z","updated":"2018-10-21T08:26:21.044Z","comments":true,"path":"2016/04/04/安卓下如何使用JUnit进行软件测试/","link":"","permalink":"http://www.wensibo.top/2016/04/04/安卓下如何使用JUnit进行软件测试/","excerpt":"软件测试作为程序员必备的一项技能是决定软件开发周期长短以及软件运行成败的关键，可以说好的软件不是代码写得好而是有效的测试决定的。本文将介绍在Android下利用eclipse进行开发时如何使用JUnit进行单元测试。","text":"软件测试作为程序员必备的一项技能是决定软件开发周期长短以及软件运行成败的关键，可以说好的软件不是代码写得好而是有效的测试决定的。本文将介绍在Android下利用eclipse进行开发时如何使用JUnit进行单元测试。 测试的分类（仅举例其中一些方法）根据测试是否知道代码 1、黑盒测试(测试的时候不知道具体代码):指的是把被测的软件看作是一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。 2、白盒测试(测试的时候需要了解具体的代码):指的是把盒子盖子打开，去研究里面的源代码和程序结果。是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。 3、灰盒测试(灰盒测试介于黑盒测试与白盒测试之间):可以这样理解，灰盒测试关注输出对于输入的正确性，同时也关注内部表现，但这种关注不象白盒那样详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态，有时候输出是正确的，但内部其实已经错误了，这种情况非常多，如果每次都通过白盒测试来操作，效率会很低，因此需要采取这样的一种灰盒的方法。 根据测试的粒度 1、方法测试(function test)：验证模块的功能。 2、单元测试(unit test):在最低的功能/参数上验证程序的准确性,比如测试一个函数的正确性。 3、集成测试(intergration test):验证几个互相有依赖关系的模块的功能。 根据测试的次数 1、冒烟测试(smoke test)：指的是测试人员在同一时间对软件进行大量的点击或者功能测试，测试软件遭到这样的压力时是否能够扛得住，关键在于同一个用户在极短的时间内对软件进行大量重复的测试。 2、压力测试(pressure test):指的是软件或者网站在同一时间内被大量的用户访问，突出的是软件或者网站被大量客户访问时的抗压能力，一般运用于大型网站的测试。 举例对其中的JUnit测试进行讲解这里我们想要对安卓应用程序中AppService类中的randomArray()方法进行单元测试。 注：试直接使用java的JUnit是无效的，应为java应用程序时在java虚拟机(JVM)运行的，而安卓程序则是在终端的Dalvik虚拟机运行的，所以直接对其进行JUnit测试会报错，故我们可以使用以下方法进行测试。 1、创建一个包，并在包下新建一个测试类(TestService)用来测试该方法，具体代码如下。 TestService类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.app.wolf;//AppService 的randomArray方法：public class AppService &#123;/** * 随机指定范围内N个不重复的数 在初始化的无重复待选数组中随机产生一个数放入结果中， * 将待选数组被随机到的数，用待选数组(len-1)下标对应的数替换 然后从len-2里随机产生下一个随机数，如此类推 * * @param max * 指定范围最大值 * @param min * 指定范围最小值 * @param n * 随机数个数 * @return int[] 随机数结果集 */ public static int[] randomArray(int min, int max, int n) &#123; int len = max - min + 1; if (max &lt; min || n &gt; len) &#123; return null; &#125; // 初始化给定范围的待选数组 int[] source = new int[len]; for (int i = min; i &lt; min + len; i++) &#123; source[i - min] = i; &#125; int[] result = new int[n]; Random rd = new Random(); int index = 0; //这个算法666，我理解的步骤应该是这样的 //1、首先初始化一个数组source，这个数组的长度是用户选择要开始游戏的人数，接着将数组中的元素分别是0~数组长度-1； //2、接着借用一个一个随机变量index,这个变量产生的随机数范围是0~数组长度-1； //3、最后将每一个index对应的source的内容对应到最后返回的result数组中； //最厉害的地方就是首先用index索引取得source数组中的内容，此时数组的长度减1，接着用数组的最后一个元素来代替之， //这样就不会出现数组中元素被重复使用的情况了。 for (int i = 0; i &lt; result.length; i++) &#123; // 待选数组0到(len-2)随机一个下标 index = Math.abs(rd.nextInt() % len--); // 将随机到的数放入结果集 result[i] = source[index]; // 将待选数组中被随机到的数，用待选数组(len-1)下标对应的数替换 source[index] = source[len]; &#125; for(int i:result)&#123; System.out.print(i+\"\\t\"); &#125; return result; &#125;&#125; TestService类： 12345678910111213141516171819202122package com.app.wolf.testService;import com.app.wolf.AppService;import android.R.integer;import android.test.AndroidTestCase;public class TestService extends AndroidTestCase &#123; /** * 用JUnit测试randomArray方法 * @throws Exception */ public void testRandomArray() throws Exception &#123; AppService service=new AppService(); int[] resultArray=service.randomArray(2, 7, 6); for(int result:resultArray)&#123; System.out.print(result+\"\\t\"); &#125; &#125;&#125; 2、如果直接在outline中对 testRandomArray()方法右击进行Android JUnit Test ，则会曝出以下异常：12WolfApp does not specify a android.test.InstrumentationTestRunner instrumentation or does not declare uses-library android.test.runner in its AndroidManifest.xml` 这是因为在AndroidManifest.xml中没有对 InstrumentationTestRunner 以及 uses-library 进行配置。 3、对于上面的错误，我们可以在AndroidManifest.xml文件加上以下的代码进行配置：1234567&lt;!-- 使用该行语句对instrumentation进行配置，但是值得注意的是targetPackage应该选择你想要测试的方法所在的包 --&gt; &lt;instrumentation android:name=\"android.test.InstrumentationTestRunner\" android:targetPackage=\"com.app.wolf\" &gt; &lt;/instrumentation&gt; &lt;!-- 使用改行代码可以对uses-library进行配置，但是必须放在application节点下 --&gt; &lt;uses-library android:name=\"android.test.runner\" /&gt; 对AndroidManifest.xml进行配置好了之后就回到第2步对该方法进行Android JUnit Test就能够成功执行了。 总结在测试的过程中应该适当地使用断言assert对程序进行测试，这对于检验程序的运行以及检查出错地方具有很有效的用处，但是本测试实验由于输出的为数组，要判断的话应该检查数组中的元素是否为要求的元素，这样检验起来会比较麻烦，所以笔者选择了打印输出的方式进行检验。","categories":[{"name":"Android","slug":"Android","permalink":"http://www.wensibo.top/categories/Android/"}],"tags":[{"name":"JUnit测试","slug":"JUnit测试","permalink":"http://www.wensibo.top/tags/JUnit测试/"}]},{"title":"将一个数组进行随机再排列","slug":"将一个数组进行随机再排列","date":"2016-04-03T14:35:04.000Z","updated":"2018-10-21T08:26:21.072Z","comments":true,"path":"2016/04/03/将一个数组进行随机再排列/","link":"","permalink":"http://www.wensibo.top/2016/04/03/将一个数组进行随机再排列/","excerpt":"我们在开发第一个app的时候遇到的一个比较有趣的算法，这种将一个数组重新进行随机排序的问题并不罕见，但是因为是初学者，所以在探讨这个算法的过程中也纠结了很久，当然最后的算法也是参考借鉴了且听风吟博主的一篇文章：http://wsjiang.iteye.com/blog/1775341 ，在此鸣谢！","text":"我们在开发第一个app的时候遇到的一个比较有趣的算法，这种将一个数组重新进行随机排序的问题并不罕见，但是因为是初学者，所以在探讨这个算法的过程中也纠结了很久，当然最后的算法也是参考借鉴了且听风吟博主的一篇文章：http://wsjiang.iteye.com/blog/1775341 ，在此鸣谢！ 问题的解决：1、假设想要将2~7这6个数字随机排序成一个数组，这里我们设置min为该范围的最小值2，max为该范围的上限7，n为想要在这个范围中取出多少个数字组成一个数组，当然当n等于范围的长度len即6时，那么得到的就是将原来的6个数字重新随机排序一遍。 2、为了方便我们引进一个初始化数组source，并将刚刚范围中的所有数字依次存进该数组中，则初始化数组source为{2,3,4,5,6,7}。 3、为了方便我们同样再引进另一个数组result作为最后返回的数组。在这里我们知道一开始len=6，那么就随机取得一个随机数index(0&lt;=index&lt;=len-1),接下来就要在source数组中找到index位置上的元素放入到result数组的第0位，这时应该将len自减，同时在source数组中将source[index]替换为source[len]。 流程图 4、以此类推直到数组result已满位置。最终得到的就是一个经过随机排序的数组。 5、代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestRandom &#123; /** * 该方法用于在制定范围即（min~max）内对min到max的所有数字进行重新随机排列，使他们形成一组随机数。 * 1、首先先初始化一个长度为(max-min+1)的数组source，数组的元素按照数字从大到小的顺序分别为min~max； * 2、每次取一个随机数index，0&lt;=index&lt;=(数组长度len-1)，同时len自减1， * 取出source数组中对应在index位置上的元素依次放进最终数组result，并且将source[index]替换为source[len]。 **/ public static int[] randomArray(int min,int max,int n)&#123; int len = max-min+1;//len为该范围内元素的个数 if(max &lt; min || n &gt; len)&#123; return null; &#125; //初始化给定范围的待选数组 int[] source = new int[len]; for (int i = min; i &lt; min+len; i++)&#123; source[i-min] = i; &#125; int[] result = new int[n]; Random rd = new Random(); int index = 0; for (int i = 0; i &lt; result.length; i++) &#123; //待选数组0到(len-2)随机一个下标 index = Math.abs(rd.nextInt() % len--); //将随机到的数放入结果集 result[i] = source[index]; //将待选数组中被随机到的数，用待选数组(len-1)下标对应的数替换 source[index] = source[len]; &#125; return result; &#125; public static void main(String[] args) &#123; for (int i = 0; i&lt;=5; i++) &#123; int result[]=TestRandom.randomArray(2,7,6); for (int num:result) &#123; System.out.print(num+\"\\t\"); &#125; System.out.println(); &#125; &#125;&#125; 6、运行结果如图，可见每次运行的结果都有可能不一样。 运行结果","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.wensibo.top/categories/JAVA/"}],"tags":[{"name":"数组排列","slug":"数组排列","permalink":"http://www.wensibo.top/tags/数组排列/"}]}]}